/* rccn.h -- generated by RCDEF */


/*--- TOPRAT ---*/

// TOPRAT record class
class TOPRAT : public record 
{ public:
    TOPRAT( basAnc *_b, TI i, SI noZ=0)  :  record( _b, i, noZ)  {} 
    virtual ~TOPRAT(); 
    TOPRAT& Copy( const TOPRAT& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    TOPRAT& operator=( const TOPRAT& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0);

    void freeDM();
    const char* When( IVLCH ivl) const;
    int tp_IsLastStep() const { return isLastDay && isEndDay && isEndHour; }
    int tp_IsLastHour() const { return isLastDay && isEndDay; }
    RC FC brFileCk();
    RC tp_CheckOutputFilePath( const char* filePath, const char** pMsg=NULL);
    void tp_SetOptions();
    RC tp_SetDerived();
    RC tp_SetCheckTimeSteps();
    RC tp_FazInit();
    void tp_ClearAuszFlags();
    RC tp_Wfile( int* pHotMo);
    RC tp_WthrInit();
    RC tp_LocInit();
    RC tp_LocDone();
    int tp_AuszWthrSource() const;
    RC tp_MainSim();
    RC tp_MainSimI();
    RC tp_SimDay();
    RC tp_SimHour();
    RC tp_Ausz( int hotMo);
    void tp_DoDateDowStuff();
    void tp_DTInit();
    void tp_DoDTStuff();
    void tp_tmrSnapshot();
    const char* tp_AuszDoing() const;
    RC tp_BegDesDay();
    RC tp_EndDesDay();
    BOO bAutoSizeCmd;
    NOYESCH chAutoSize;
    NOYESCH chSimulate;
    DOY tp_begDay;
    DOY tp_endDay;
    SI nDays;
    DOWCH jan1DoW;
    SI year;
    SI wuDays;
    SI tp_nSubSteps;
    CHP tp_wfName;
    CHP tp_TDVfName;
    FLOAT elevation;
    FLOAT refTemp;
    FLOAT refRH;
    FLOAT grndRefl;
    FLOAT tp_grndEmit;
    FLOAT tp_grndRf;
    FLOAT tp_soilDiff;
    FLOAT tp_soilCond;
    FLOAT tp_soilSpHt;
    FLOAT tp_soilDens;
    FLOAT tp_farFieldWidth;
    DGCH tp_deepGrndCnd;
    FLOAT tp_deepGrndDepth;
    FLOAT tp_deepGrndT;
    FLOAT tp_tol;
    FLOAT humTolF;
    FLOAT ebTolMon;
    FLOAT ebTolDay;
    FLOAT ebTolHour;
    FLOAT ebTolSubhr;
    INT tp_ebErrCount;
    FLOAT tp_grndMinDim;
    FLOAT tp_grndMaxGrthCoeff;
    TSCH tp_grndTimeStep;
    FLOAT tp_AWTrigT;
    FLOAT tp_AWTrigSlr;
    FLOAT tp_AWTrigH;
    FLOAT tp_ANTolAbs;
    FLOAT tp_ANTolRel;
    FLOAT tp_bldgAzm;
    SKYMODCH skyModel;
    SKYMODLWCH skyModelLW;
    EXSHMODELCH tp_exShadeModel;
    SLRINTERPMETH tp_slrInterpMeth;
    HUMTHCH humMeth;
    FLOAT dflExH;
    USI workDayMask;
    NOYESCH DT;
    DOY DTBegDay;
    DOY DTEndDay;
    FLOAT windSpeedMin;
    FLOAT windF;
    SI tp_terrainClass;
    FLOAT radBeamF;
    FLOAT radDiffF;
    VENTAVAILVC tp_ventAvail;
    ULI tp_GetVentAvail() const { return CHN( tp_ventAvail); }
    FLOAT tp_fVent;
    NOYESCH tp_hConvMod;
    SI verbose;
    LI tp_dbgPrintMask;
    LI tp_dbgPrintMaskC;
    LI tp_SetDbMask();
    FLOAT auszTol;
    FLOAT heatDsTDbO;
    FLOAT heatDsTWbO;
    SI tp_coolDsMo[13];
    DOY tp_coolDsDay[13];
    TI tp_coolDsCond[13];
    CHP tp_exePath;
    CHP tp_exeInfo;
    INT tp_exeCodeSize;
    CHP tp_progVersion;
    CHP tp_HPWHVersion;
    CHP tp_cmdLineArgs;
    SI runSerial;
    CHP runTitle;
    CHP runDateTime;
    NOYESCH tp_brs;
    NOYESCH tp_brHrly;
    CHP tp_brFileName;
    BOO tp_brMem;
    BOO tp_brDiscardable;
    CHP repHdrL;
    CHP repHdrR;
    SI repCpl;
    SI repLpp;
    SI repTopM;
    SI repBotM;
    CHP tp_repTestPfx;
    const char* tp_RepTestPfx() const;
    BOO tp_bAllCR;
    INT tp_exshNShade;
    INT tp_exshNRec;
    int tp_ExshCount();
    RC tp_ExshRunInit();
    RC tp_ExshBegHour();
    FLOAT relTol;
    FLOAT relTol1;
    FLOAT absTol;
    FLOAT absHumTol;
    FLOAT hiTol;
    FLOAT loTol;
    FLOAT latitude;
    FLOAT longitude;
    FLOAT timeZone;
    RC tp_Psychro();
    FLOAT tp_presAtm;
    FLOAT tp_refW;
    DBL tp_refWX;
    FLOAT tp_airSH;
    FLOAT airVK;
    FLOAT airRhoK;
    FLOAT airVshK;
    FLOAT airXK;
    FLOAT tp_hConvF;
    float airDens( float t) { return airRhoK / ( t + 459.67f); }	// air density for temp  lb/ft3
    float airSpv( float t)  { return airVK * (t + 459.67f); }		// air specific volume (1/density) ft3/lb
    float airX( float t)    { return airXK / (t + 459.67f); }		// air flow heat transfer (Btuh/cfm-F): vsh * 60
    INT tp_nDesDays;
    FLOAT auszSmTol;
    FLOAT auszTol2;
    FLOAT auszHiTol2;
    INT vrSum;
    TI dvriY;
    TI dvriM;
    TI dvriD;
    TI dvriH;
    TI dvriS;
    TI dvriHS;
    SI hrxFlg;
    SI shrxFlg;
    DBL tp_tmrInput;
    DBL tp_tmrAusz;
    DBL tp_tmrRun;
    DBL tp_tmrTotal;
    DBL tp_tmrAirNet;
    DBL tp_tmrAWTot;
    DBL tp_tmrAWCalc;
    DBL tp_tmrCond;
    DBL tp_tmrKiva;
    DBL tp_tmrBC;
    DBL tp_tmrZone;
    FLOAT tp_subhrDur;
    SI tp_nSubhrTicks;
    DBL tp_tickDurMin;
    DBL tp_tickDurHr;
    int tp_NHrTicks() const { return tp_nSubSteps*tp_nSubhrTicks; }
    ANAME monStr;
    CHP dateStr;
    IDATE tp_date;
    DOY jDay;
    DOY xJDay;
    SI iHr;
    SI iSubhr;
    SHOY shoy;
    BOO isDT;
    SI iHrST;
    DOY jDayST;
    BOO tp_autoSizing;
    BOO tp_pass1;
    BOO tp_pass1A;
    BOO tp_pass1B;
    BOO tp_pass2;
    BOO tp_sizing;
    INT tp_dsDayI;
    SI tp_dsDay;
    SI auszMon;
    IVLCH ivl;
    IVLCH isBegOf;
    IVLCH isEndOf;
    BOO isBegRun;
    BOO tp_isBegMainSim;
    BOO isFirstMon;
    BOO isLastDay;
    BOO isLastWarmupDay;
    BOO isBegHour;
    BOO isEndHour;
    BOO isBegDay;
    BOO isEndDay;
    BOO isBegMonth;
    BOO isEndMonth;
    BOO isSolarCalcDay;
    BOO isWarmup;
    SI dowh;
    BOO isHoliday;
    BOO isHoliTrue;
    BOO isWeHol;
    BOO isWeekend;
    BOO isBegWeek;
    BOO isWeekday;
    BOO isWorkDay;
    BOO isNonWorkDay;
    BOO isBegWorkWeek;
    BOO notDone;
    INT dsDayNIt;
    void tp_SetPvHrWthr();
    FLOAT radBeamHrAv;
    FLOAT radDiffHrAv;
    FLOAT radBeamShAv;
    FLOAT radDiffShAv;
    RC tp_WthrBegDay();
    RC tp_WthrFillDsDay( WFILE* pWF);
    RC tp_WthrBegHour();
    RC tp_WthrBegSubhr();
    FLOAT tDbOHr;
    FLOAT tDbOPvHr;
    FLOAT tDbOHrAv;
    FLOAT tDbOSh;
    FLOAT tDbOPvSh;
    FLOAT tDbOShAv;
    FLOAT tWbOHr;
    FLOAT tWbOPvHr;
    FLOAT tWbOHrAv;
    FLOAT tWbOSh;
    FLOAT tDpOHr;
    FLOAT tDpOPvHr;
    FLOAT tDpOHrAv;
    FLOAT tDpOSh;
    FLOAT tSkyHr;
    FLOAT tSkyPvHr;
    FLOAT tSkySh;
    FLOAT windSpeedHr;
    FLOAT windSpeedPvHr;
    FLOAT windSpeedHrAv;
    FLOAT windSpeedSh;
    FLOAT windSpeedSquaredSh;
    FLOAT windSpeedSqrtSh;
    FLOAT windSpeedPt8Sh;
    FLOAT windDirDegHr;
    float tp_WindPresV( float windV) const;
    float tp_WindFactor( float Z, int sheildClass, int terrainClass=0) const;
    FLOAT wOHr;
    FLOAT wOPvHr;
    FLOAT wOHrAv;
    FLOAT wOSh;
    FLOAT hOSh;
    FLOAT tp_airxOSh;
    FLOAT tp_rhoMoistOSh;
    FLOAT tp_rhoDryOSh;
    BOO ztuKf;
    BOO ahKf;
    BOO ahKf2;
    BOO hpKf;
    BOO cpKf;
    BOO tpKf;
    SI iter;
    FLOAT qcPeak;
    SI qcPeakH;
    SI qcPeakD;
    SI qcPeakM;
    FLOAT qhPeak;
    SI qhPeakH;
    SI qhPeakD;
    SI qhPeakM;
    AIRNET* tp_pAirNet;
    class Pumbra::Penumbra* tp_pPumbra;
    RC tp_PumbraInit();
    int tp_PumbraClearIf();
    void tp_PumbraDestroy();
    int tp_PumbraAvailability() const;
    RC tp_PumbraSetModel();
    SI ck5aa5;
    unsigned char sstat[278];		// fld status bytes (base class excluded)
};		// TOPRAT

// TOPRAT field numbers (subscripts for TOPRAT.sstat[] / sfirTOPRAT[])
#define TOPRAT_NAME 0
#define TOPRAT_OWNTI 1
#define TOPRAT_BAUTOSIZECMD 2
#define TOPRAT_CHAUTOSIZE 3
#define TOPRAT_CHSIMULATE 4
#define TOPRAT_BEGDAY 5
#define TOPRAT_ENDDAY 6
#define TOPRAT_NDAYS 7
#define TOPRAT_JAN1DOW 8
#define TOPRAT_YEAR 9
#define TOPRAT_WUDAYS 10
#define TOPRAT_NSUBSTEPS 11
#define TOPRAT_WFNAME 12
#define TOPRAT_TDVFNAME 13
#define TOPRAT_ELEVATION 14
#define TOPRAT_REFTEMP 15
#define TOPRAT_REFRH 16
#define TOPRAT_GRNDREFL 17
#define TOPRAT_GRNDEMIT 18
#define TOPRAT_GRNDRF 19
#define TOPRAT_SOILDIFF 20
#define TOPRAT_SOILCOND 21
#define TOPRAT_SOILSPHT 22
#define TOPRAT_SOILDENS 23
#define TOPRAT_FARFIELDWIDTH 24
#define TOPRAT_DEEPGRNDCND 25
#define TOPRAT_DEEPGRNDDEPTH 26
#define TOPRAT_DEEPGRNDT 27
#define TOPRAT_TOL 28
#define TOPRAT_HUMTOLF 29
#define TOPRAT_EBTOLMON 30
#define TOPRAT_EBTOLDAY 31
#define TOPRAT_EBTOLHOUR 32
#define TOPRAT_EBTOLSUBHR 33
#define TOPRAT_EBERRCOUNT 34
#define TOPRAT_GRNDMINDIM 35
#define TOPRAT_GRNDMAXGRTHCOEFF 36
#define TOPRAT_GRNDTIMESTEP 37
#define TOPRAT_AWTRIGT 38
#define TOPRAT_AWTRIGSLR 39
#define TOPRAT_AWTRIGH 40
#define TOPRAT_ANTOLABS 41
#define TOPRAT_ANTOLREL 42
#define TOPRAT_BLDGAZM 43
#define TOPRAT_SKYMODEL 44
#define TOPRAT_SKYMODELLW 45
#define TOPRAT_EXSHADEMODEL 46
#define TOPRAT_SLRINTERPMETH 47
#define TOPRAT_HUMMETH 48
#define TOPRAT_DFLEXH 49
#define TOPRAT_WORKDAYMASK 50
#define TOPRAT_DT 51
#define TOPRAT_DTBEGDAY 52
#define TOPRAT_DTENDDAY 53
#define TOPRAT_WINDSPEEDMIN 54
#define TOPRAT_WINDF 55
#define TOPRAT_TERRAINCLASS 56
#define TOPRAT_RADBEAMF 57
#define TOPRAT_RADDIFFF 58
#define TOPRAT_VENTAVAIL 59
#define TOPRAT_FVENT 60
#define TOPRAT_HCONVMOD 61
#define TOPRAT_VERBOSE 62
#define TOPRAT_DBGPRINTMASK 63
#define TOPRAT_DBGPRINTMASKC 64
#define TOPRAT_AUSZTOL 65
#define TOPRAT_HEATDSTDBO 66
#define TOPRAT_HEATDSTWBO 67
#define TOPRAT_COOLDSMO 68
#define TOPRAT_COOLDSDAY 81
#define TOPRAT_COOLDSCOND 94
#define TOPRAT_EXEPATH 107
#define TOPRAT_EXEINFO 108
#define TOPRAT_EXECODESIZE 109
#define TOPRAT_PROGVERSION 110
#define TOPRAT_HPWHVERSION 111
#define TOPRAT_CMDLINEARGS 112
#define TOPRAT_RUNSERIAL 113
#define TOPRAT_RUNTITLE 114
#define TOPRAT_RUNDATETIME 115
#define TOPRAT_BRS 116
#define TOPRAT_BRHRLY 117
#define TOPRAT_BRFILENAME 118
#define TOPRAT_BRMEM 119
#define TOPRAT_BRDISCARDABLE 120
#define TOPRAT_REPHDRL 121
#define TOPRAT_REPHDRR 122
#define TOPRAT_REPCPL 123
#define TOPRAT_REPLPP 124
#define TOPRAT_REPTOPM 125
#define TOPRAT_REPBOTM 126
#define TOPRAT_REPTESTPFX 127
#define TOPRAT_BALLCR 128
#define TOPRAT_EXSHNSHADE 129
#define TOPRAT_EXSHNREC 130
#define TOPRAT_RELTOL 131
#define TOPRAT_RELTOL1 132
#define TOPRAT_ABSTOL 133
#define TOPRAT_ABSHUMTOL 134
#define TOPRAT_HITOL 135
#define TOPRAT_LOTOL 136
#define TOPRAT_LATITUDE 137
#define TOPRAT_LONGITUDE 138
#define TOPRAT_TIMEZONE 139
#define TOPRAT_PRESATM 140
#define TOPRAT_REFW 141
#define TOPRAT_REFWX 142
#define TOPRAT_AIRSH 143
#define TOPRAT_AIRVK 144
#define TOPRAT_AIRRHOK 145
#define TOPRAT_AIRVSHK 146
#define TOPRAT_AIRXK 147
#define TOPRAT_HCONVF 148
#define TOPRAT_NDESDAYS 149
#define TOPRAT_AUSZSMTOL 150
#define TOPRAT_AUSZTOL2 151
#define TOPRAT_AUSZHITOL2 152
#define TOPRAT_VRSUM 153
#define TOPRAT_DVRIY 154
#define TOPRAT_DVRIM 155
#define TOPRAT_DVRID 156
#define TOPRAT_DVRIH 157
#define TOPRAT_DVRIS 158
#define TOPRAT_DVRIHS 159
#define TOPRAT_HRXFLG 160
#define TOPRAT_SHRXFLG 161
#define TOPRAT_TMRINPUT 162
#define TOPRAT_TMRAUSZ 163
#define TOPRAT_TMRRUN 164
#define TOPRAT_TMRTOTAL 165
#define TOPRAT_TMRAIRNET 166
#define TOPRAT_TMRAWTOT 167
#define TOPRAT_TMRAWCALC 168
#define TOPRAT_TMRCOND 169
#define TOPRAT_TMRKIVA 170
#define TOPRAT_TMRBC 171
#define TOPRAT_TMRZONE 172
#define TOPRAT_SUBHRDUR 173
#define TOPRAT_NSUBHRTICKS 174
#define TOPRAT_TICKDURMIN 175
#define TOPRAT_TICKDURHR 176
#define TOPRAT_MONSTR 177
#define TOPRAT_DATESTR 178
#define TOPRAT_DATE 179
#define TOPRAT_JDAY 180
#define TOPRAT_XJDAY 181
#define TOPRAT_IHR 182
#define TOPRAT_ISUBHR 183
#define TOPRAT_SHOY 184
#define TOPRAT_ISDT 185
#define TOPRAT_IHRST 186
#define TOPRAT_JDAYST 187
#define TOPRAT_AUTOSIZING 188
#define TOPRAT_PASS1 189
#define TOPRAT_PASS1A 190
#define TOPRAT_PASS1B 191
#define TOPRAT_PASS2 192
#define TOPRAT_SIZING 193
#define TOPRAT_DSDAYI 194
#define TOPRAT_DSDAY 195
#define TOPRAT_AUSZMON 196
#define TOPRAT_IVL 197
#define TOPRAT_ISBEGOF 198
#define TOPRAT_ISENDOF 199
#define TOPRAT_ISBEGRUN 200
#define TOPRAT_ISBEGMAINSIM 201
#define TOPRAT_ISFIRSTMON 202
#define TOPRAT_ISLASTDAY 203
#define TOPRAT_ISLASTWARMUPDAY 204
#define TOPRAT_ISBEGHOUR 205
#define TOPRAT_ISENDHOUR 206
#define TOPRAT_ISBEGDAY 207
#define TOPRAT_ISENDDAY 208
#define TOPRAT_ISBEGMONTH 209
#define TOPRAT_ISENDMONTH 210
#define TOPRAT_ISSOLARCALCDAY 211
#define TOPRAT_ISWARMUP 212
#define TOPRAT_DOWH 213
#define TOPRAT_ISHOLIDAY 214
#define TOPRAT_ISHOLITRUE 215
#define TOPRAT_ISWEHOL 216
#define TOPRAT_ISWEEKEND 217
#define TOPRAT_ISBEGWEEK 218
#define TOPRAT_ISWEEKDAY 219
#define TOPRAT_ISWORKDAY 220
#define TOPRAT_ISNONWORKDAY 221
#define TOPRAT_ISBEGWORKWEEK 222
#define TOPRAT_NOTDONE 223
#define TOPRAT_DSDAYNIT 224
#define TOPRAT_RADBEAMHRAV 225
#define TOPRAT_RADDIFFHRAV 226
#define TOPRAT_RADBEAMSHAV 227
#define TOPRAT_RADDIFFSHAV 228
#define TOPRAT_TDBOHR 229
#define TOPRAT_TDBOPVHR 230
#define TOPRAT_TDBOHRAV 231
#define TOPRAT_TDBOSH 232
#define TOPRAT_TDBOPVSH 233
#define TOPRAT_TDBOSHAV 234
#define TOPRAT_TWBOHR 235
#define TOPRAT_TWBOPVHR 236
#define TOPRAT_TWBOHRAV 237
#define TOPRAT_TWBOSH 238
#define TOPRAT_TDPOHR 239
#define TOPRAT_TDPOPVHR 240
#define TOPRAT_TDPOHRAV 241
#define TOPRAT_TDPOSH 242
#define TOPRAT_TSKYHR 243
#define TOPRAT_TSKYPVHR 244
#define TOPRAT_TSKYSH 245
#define TOPRAT_WINDSPEEDHR 246
#define TOPRAT_WINDSPEEDPVHR 247
#define TOPRAT_WINDSPEEDHRAV 248
#define TOPRAT_WINDSPEEDSH 249
#define TOPRAT_WINDSPEEDSQUAREDSH 250
#define TOPRAT_WINDSPEEDSQRTSH 251
#define TOPRAT_WINDSPEEDPT8SH 252
#define TOPRAT_WINDDIRDEGHR 253
#define TOPRAT_WOHR 254
#define TOPRAT_WOPVHR 255
#define TOPRAT_WOHRAV 256
#define TOPRAT_WOSH 257
#define TOPRAT_HOSH 258
#define TOPRAT_AIRXOSH 259
#define TOPRAT_RHOMOISTOSH 260
#define TOPRAT_RHODRYOSH 261
#define TOPRAT_ZTUKF 262
#define TOPRAT_AHKF 263
#define TOPRAT_AHKF2 264
#define TOPRAT_HPKF 265
#define TOPRAT_CPKF 266
#define TOPRAT_TPKF 267
#define TOPRAT_ITER 268
#define TOPRAT_QCPEAK 269
#define TOPRAT_QCPEAKH 270
#define TOPRAT_QCPEAKD 271
#define TOPRAT_QCPEAKM 272
#define TOPRAT_QHPEAK 273
#define TOPRAT_QHPEAKH 274
#define TOPRAT_QHPEAKD 275
#define TOPRAT_QHPEAKM 276
#define TOPRAT_CK5AA5 277

#define TOPRAT_NFIELDS 278  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirTOPRAT[];				// TOPRAT small fields-in-record table (srfd.cpp)

#define  makAncTOPRAT(name)        anc<TOPRAT> name( "top", sfirTOPRAT, TOPRAT_NFIELDS, RTTOPRAT) 
#define  makAncTOPRAT2(name,what)  anc<TOPRAT> name( what, sfirTOPRAT, TOPRAT_NFIELDS, RTTOPRAT)	// 'what' override


/*--- PYLINEAR ---*/

// PYLINEAR record structure
struct PYLINEAR
 { 
    DBL val(DBL x)        { return k[0] + k[1]*x; }
    RC normalize( record *r, SI fn, char *descrip, DBL x=1.0);
    FLOAT k[3];
};		// PYLINEAR

// PYLINEAR field numbers (subscripts for PYLINEAR.sstat[] / sfirPYLINEAR[])
#define PYLINEAR_K 0

#define PYLINEAR_NFIELDS 3  					// excludes rec start ovh; is # sstat[] bytes.



/*--- PYCUBIC ---*/

// PYCUBIC record structure
struct PYCUBIC
 { 
    DBL val(DBL x)        { return k[0] + k[1]*x + k[2]*x*x + k[3]*x*x*x; }
    RC normalize( record *r, SI fn, char *descrip, DBL x=1.0);
    FLOAT k[5];
};		// PYCUBIC

// PYCUBIC field numbers (subscripts for PYCUBIC.sstat[] / sfirPYCUBIC[])
#define PYCUBIC_K 0

#define PYCUBIC_NFIELDS 5  					// excludes rec start ovh; is # sstat[] bytes.



/*--- PYCUBIC2 ---*/

// PYCUBIC2 record structure
struct PYCUBIC2
 { 
    DBL val(DBL x)        { x -= k[4];  if (x < 0.)  x = 0.;  return k[0] + k[1]*x + k[2]*x*x + k[3]*x*x*x; }
    RC normalize( record *r, SI fn, char *descrip, DBL x=1.0);
    FLOAT k[6];
};		// PYCUBIC2

// PYCUBIC2 field numbers (subscripts for PYCUBIC2.sstat[] / sfirPYCUBIC2[])
#define PYCUBIC2_K 0

#define PYCUBIC2_NFIELDS 6  					// excludes rec start ovh; is # sstat[] bytes.



/*--- PYBIQUAD ---*/

// PYBIQUAD record structure
struct PYBIQUAD
 { 
    DBL val( DBL x, DBL y)        { return k[0] + k[1]*x + k[2]*x*x + k[3]*y + k[4]*y*y + k[5]*x*y; }
    RC normalize( record *r, SI fn, char *descX, char*descY, DBL x, DBL y, BOO noWarn=FALSE);
    RC normalizeCoil( AH *ah, SI fn);
    FLOAT k[7];
};		// PYBIQUAD

// PYBIQUAD field numbers (subscripts for PYBIQUAD.sstat[] / sfirPYBIQUAD[])
#define PYBIQUAD_K 0

#define PYBIQUAD_NFIELDS 7  					// excludes rec start ovh; is # sstat[] bytes.



/*--- PY4 ---*/

// PY4 record structure
struct PY4
 { 
    DBL val1( DBL x)  { DBL x2 = x*x;  return        k[1]*x + k[2]*x2 + k[3]*x2*x + k[4]*x2*x2; }
    FLOAT k[6];
};		// PY4

// PY4 field numbers (subscripts for PY4.sstat[] / sfirPY4[])
#define PY4_K 0

#define PY4_NFIELDS 6  					// excludes rec start ovh; is # sstat[] bytes.



/*--- INVERSE ---*/

// INVERSE record class
class INVERSE : public record 
{ public:
    INVERSE( basAnc *_b, TI i, SI noZ=0)  :  record( _b, i, noZ)  {} 
    virtual ~INVERSE() {} 
    INVERSE& Copy( const INVERSE& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    INVERSE& operator=( const INVERSE& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0) { record::Copy( pSrc, options); };

    RC iv_CkF();
    RC iv_Init();
    RC iv_Calc( IVLCH ivl);
    IVLCH iv_freq;
    FLOAT iv_X0;
    FLOAT iv_Y0;
    FLOAT iv_YTarg;
    FLOAT iv_X;
    FLOAT iv_Y;
    FLOAT iv_XEst;
    unsigned char sstat[10];		// fld status bytes (base class excluded)
};		// INVERSE

// INVERSE field numbers (subscripts for INVERSE.sstat[] / sfirINVERSE[])
#define INVERSE_NAME 0
#define INVERSE_OWNTI 1
#define INVERSE_FREQ 2
#define INVERSE_X0 3
#define INVERSE_Y0 4
#define INVERSE_YTARG 5
#define INVERSE_X 6
#define INVERSE_Y 7
#define INVERSE_XEST 8

#define INVERSE_NFIELDS 9  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirINVERSE[];				// INVERSE small fields-in-record table (srfd.cpp)

#define  makAncINVERSE(name)        anc<INVERSE> name( "Inverse", sfirINVERSE, INVERSE_NFIELDS, RTINVERSE) 
#define  makAncINVERSE2(name,what)  anc<INVERSE> name( what, sfirINVERSE, INVERSE_NFIELDS, RTINVERSE)	// 'what' override


/*--- WFILE ---*/

// WFILE record class
class WFILE : public record 
{ public:
    WFILE( basAnc *_b, TI i, SI noZ=0);
    virtual ~WFILE(); 
    WFILE& Copy( const WFILE& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    WFILE& operator=( const WFILE& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0);

    WFILE();
    void wf_Init();
    RC wf_Open( const char* wfName, const char* TDVfName, int erOp=ERR, int wrA=FALSE, char* hdr=NULL,
        float* clrnss=NULL, float* turbid=NULL, float* atmois=NULL);
    RC wf_Close( char *hdr=NULL);
    const char* wf_FilePath() const;
    RC wf_PackedOpen(const char* wfName, int erOp, int wrAccess, char* hdr, float* clrnss, float *turbid, float* atmois);
    RC wf_BsgsDecodeHdr( char* hdr, int erOp);
    RC wf_EtDecodeHdr( char* hdr, int erOp, float* clrnss, float* turbid, float* atmois);
    RC wf_DecodeHdrFields( char* hdr, struct WFHTAB* wfht0, int erOp);
    RC wf_FillWDYEAR( int erOp=WRN);
    enum { gshrFILEDAY, gshrDSDAY, gshrDSDAY0 };
    RC wf_GenSubhrRad( SLRINTERPMETH slrInterpMeth, int dayTy, int jDay);
    RC wf_GetSubhrRad( int jDay, int iHrST, int iSh, float& radBeamAv, float& radDiffAv);
    WDHR& wf_GetDsDayWDHR( int iHr);
    RC wf_GetDsDayHr( WDHR* pWd, int iHr, int erOp = WRN);
    RC wf_Read( WDHR* pWd, int jDay, int iHr, int erOp = WRN);
    USI* wf_PackedHrRead( int jDay, int iHr, int erOp = WRN);
    LI wf_PackedHrOffset( int jDay, int iHr, int erOp = WRN);
    RC wf_CSWOpen( const char* wfName, int erOp );
    RC wf_CSWRead( WDHR* pwd, int jDay, int iHr, int erOp );
    RC wf_CSWHdrVal( const char* key, const char* val, float& v, RC& rcAll, int erOp=WRN);
    RC wf_CSWHdrVal( const char* key, const char* val, int& v, RC& rcAll, int erOp=WRN);
    RC wf_CSWPosHr1( int erOp=WRN);
    RC wf_T24DLLOpen( const char* wfName, int erOp);
    RC wf_T24DLLRead( WDHR* pwd, int jDay, int iHr, int erOp);
    RC wf_EPWOpen( const char* wfName, int erOp );
    RC wf_EPWPosHr1( int erOp=WRN);
    RC wf_EPWRead( WDHR* pwd, int jDay, int iHr, int erOp );
    RC wf_TDVOpen( const char* TDVfName, int erOp);
    void wf_TDVInitHdrInfo();
    RC wf_TDVReadHdr( int erOp=WRN);
    RC wf_TDVPosHr1( int erOp=WRN);
    RC wf_TDVReadIf( WDHR* pwd, int erOp, int jDay, int iHr);
    RC wf_FixJday( DOY& jDay, int begDay );
    WFILEFORMAT wFileFormat;
    int wf_IsPacked() const { return wFileFormat==BSGS || wFileFormat==BSGSdemo || wFileFormat==ET1 || wFileFormat==ET2; }
    WFLOC loc;
    WFLID lid;
    SI yr;
    SI jd1;
    SI jdl;
    FLOAT lat;
    FLOAT lon;
    FLOAT tz;
    FLOAT elev;
    FLOAT taDbAvgYr;
    FLOAT tMainsAvgYr;
    FLOAT tMainsMinYr;
    SI solartime;
    WFLOC2 loc2;
    SI isLeap;
    SI firstDdm;
    SI lastDdm;
    SI winMOE;
    SI win99TDb;
    SI win97TDb;
    SI sum1TDb;
    SI sum1TWb;
    SI sum2TDb;
    SI sum2TWb;
    SI sum5TDb;
    SI sum5TWb;
    SI range;
    SI sumMonHi;
    WFLOC wf_TDVFileTimeStamp;
    ANAME wf_TDVFileTitle;
    SI hdrBytes;
    SI hourBytes;
    INT csvCols;
    YACAMP yac;
    YACAMP yacTDV;
    INT wf_TDVFileJHr;
    WDYEARP wf_pWDY;
    unsigned char sstat[40];		// fld status bytes (base class excluded)
};		// WFILE

// WFILE field numbers (subscripts for WFILE.sstat[] / sfirWFILE[])
#define WFILE_NAME 0
#define WFILE_OWNTI 1
#define WFILE_WFILEFORMAT 2
#define WFILE_LOC 3
#define WFILE_LID 4
#define WFILE_YR 5
#define WFILE_JD1 6
#define WFILE_JDL 7
#define WFILE_LAT 8
#define WFILE_LON 9
#define WFILE_TZ 10
#define WFILE_ELEV 11
#define WFILE_TADBAVGYR 12
#define WFILE_TMAINSAVGYR 13
#define WFILE_TMAINSMINYR 14
#define WFILE_SOLARTIME 15
#define WFILE_LOC2 16
#define WFILE_ISLEAP 17
#define WFILE_FIRSTDDM 18
#define WFILE_LASTDDM 19
#define WFILE_WINMOE 20
#define WFILE_WIN99TDB 21
#define WFILE_WIN97TDB 22
#define WFILE_SUM1TDB 23
#define WFILE_SUM1TWB 24
#define WFILE_SUM2TDB 25
#define WFILE_SUM2TWB 26
#define WFILE_SUM5TDB 27
#define WFILE_SUM5TWB 28
#define WFILE_RANGE 29
#define WFILE_SUMMONHI 30
#define WFILE_TDVFILETIMESTAMP 31
#define WFILE_TDVFILETITLE 32
#define WFILE_HDRBYTES 33
#define WFILE_HOURBYTES 34
#define WFILE_CSVCOLS 35
#define WFILE_YAC 36
#define WFILE_YACTDV 37
#define WFILE_TDVFILEJHR 38
#define WFILE_PWDY 39

#define WFILE_NFIELDS 40  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirWFILE[];				// WFILE small fields-in-record table (srfd.cpp)

#define  makAncWFILE(name)        anc<WFILE> name( "weatherFile", sfirWFILE, WFILE_NFIELDS, RTWFILE) 
#define  makAncWFILE2(name,what)  anc<WFILE> name( what, sfirWFILE, WFILE_NFIELDS, RTWFILE)	// 'what' override


/*--- WDHR ---*/

// WDHR record structure
struct WDHR
 { 
    void wd_Init( int options=0);
    WDHR& Copy( const WDHR& wd, int options=0);
    RC wd_WfReader( BOO nextHour, WFILE* pWF);
    void wd_Adjust( int iHrST);
    void wd_SetSolarValues( int jDayST, int iHrST);
    int wd_SunupBegEnd( int iHr, float& hrBeg, float& hrEnd) const;
    RC wd_Unpack( int iH, USI* pHour, int wFileFormat=ET1);
    RC wd_EstimateMissingET1( int iHr);
    float wd_CalcSkyTemp( int skyModelLW, int iHr);
    RC wd_CSWReadHr( WFILE* pWF, int jHr, int erOp=WRN);
    RC wd_TDVReadHr( WFILE* pWF, int jHr, int erOp=WRN);
    RC wd_EPWReadHr( WFILE* pWF, int jHr, int erOp=WRN);
    RC wd_GenDesCondHeating( WFILE* pWF, int jDayST, int iHrST);
    RC wd_UpdateDesCondHeating();
    void wd_FillFromDESCOND( const DESCOND& dc, int iHr);
    void wd_SetDayValues( const class WDDAY& wdd);
    void wd_SetDayValuesIfMissing( const class WDDAY& wdd);
    void wd_SetTdvElecHrRank( const class WDDAY& wdd);
    void wd_ShiftTdvElecHrRankForDST();
    bool wd_HasTdvData() const;
    FLOAT wd_sunupf;
    FLOAT wd_slAzm;
    FLOAT wd_slAlt;
    FLOAT wd_db;
    FLOAT wd_wb;
    FLOAT wd_DNI;
    FLOAT wd_DHI;
    FLOAT wd_bmrad;
    FLOAT wd_dfrad;
    FLOAT wd_wndDir;
    FLOAT wd_wndSpd;
    FLOAT wd_glrad;
    FLOAT wd_cldCvr;
    FLOAT wd_tSky;
    FLOAT wd_tGrnd;
    FLOAT wd_taDp;
    FLOAT wd_tMains;
    FLOAT wd_tdvElec;
    FLOAT wd_tdvFuel;
    FLOAT wd_taDbPk;
    FLOAT wd_taDbAvg;
    FLOAT wd_taDbPvPk;
    FLOAT wd_taDbAvg01;
    FLOAT wd_taDbAvg07;
    FLOAT wd_taDbAvg14;
    FLOAT wd_taDbAvg31;
    FLOAT wd_tdvElecPk;
    SI wd_tdvElecPkRank;
    FLOAT wd_tdvElecAvg;
    FLOAT wd_tdvElecPvPk;
    FLOAT wd_tdvElecAvg01;
    SI wd_tdvElecHrRank[25];
};		// WDHR

// WDHR field numbers (subscripts for WDHR.sstat[] / sfirWDHR[])
#define WDHR_SUNUPF 0
#define WDHR_SLAZM 1
#define WDHR_SLALT 2
#define WDHR_DB 3
#define WDHR_WB 4
#define WDHR_DNI 5
#define WDHR_DHI 6
#define WDHR_BMRAD 7
#define WDHR_DFRAD 8
#define WDHR_WNDDIR 9
#define WDHR_WNDSPD 10
#define WDHR_GLRAD 11
#define WDHR_CLDCVR 12
#define WDHR_TSKY 13
#define WDHR_TGRND 14
#define WDHR_TADP 15
#define WDHR_TMAINS 16
#define WDHR_TDVELEC 17
#define WDHR_TDVFUEL 18
#define WDHR_TADBPK 19
#define WDHR_TADBAVG 20
#define WDHR_TADBPVPK 21
#define WDHR_TADBAVG01 22
#define WDHR_TADBAVG07 23
#define WDHR_TADBAVG14 24
#define WDHR_TADBAVG31 25
#define WDHR_TDVELECPK 26
#define WDHR_TDVELECPKRANK 27
#define WDHR_TDVELECAVG 28
#define WDHR_TDVELECPVPK 29
#define WDHR_TDVELECAVG01 30
#define WDHR_TDVELECHRRANK 31

#define WDHR_NFIELDS 56  					// excludes rec start ovh; is # sstat[] bytes.



/*--- WFDATA ---*/

// WFDATA record class
class WFDATA : public record 
{ public:
    WFDATA( basAnc *_b, TI i, SI noZ=0)  :  record( _b, i, noZ)  {} 
    virtual ~WFDATA() {} 
    WFDATA& Copy( const WFDATA& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    WFDATA& operator=( const WFDATA& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0) { record::Copy( pSrc, options); };

    void wd_Init();
    WDHR d;
    unsigned char sstat[58];		// fld status bytes (base class excluded)
};		// WFDATA

// WFDATA field numbers (subscripts for WFDATA.sstat[] / sfirWFDATA[])
#define WFDATA_NAME 0
#define WFDATA_OWNTI 1
#define WFDATA_D 2

#define WFDATA_NFIELDS 58  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirWFDATA[];				// WFDATA small fields-in-record table (srfd.cpp)

#define  makAncWFDATA(name)        anc<WFDATA> name( "weather", sfirWFDATA, WFDATA_NFIELDS, RTWFDATA) 
#define  makAncWFDATA2(name,what)  anc<WFDATA> name( what, sfirWFDATA, WFDATA_NFIELDS, RTWFDATA)	// 'what' override


/*--- DESCOND ---*/

// DESCOND record class
class DESCOND : public record 
{ public:
    DESCOND( basAnc *_b, TI i, SI noZ=0)  :  record( _b, i, noZ)  {} 
    virtual ~DESCOND() {} 
    DESCOND& Copy( const DESCOND& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    DESCOND& operator=( const DESCOND& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0) { record::Copy( pSrc, options); };

    RC dc_CkF();
    DOY dc_GetDOY() const { return dc_doy; }
    RC dc_RunInit();
    RC dc_CheckFixSolar( int options);
    void dc_GenerateTemps( int iHr, float astCor, float& db, float& wb, float& dbAvg) const;
    DOY dc_doy;
    FLOAT dc_DB;
    FLOAT dc_MCDBR;
    FLOAT dc_MCWB;
    FLOAT dc_MCWBR;
    FLOAT dc_wndSpd;
    FLOAT dc_tauB;
    FLOAT dc_tauD;
    FLOAT dc_ebnSlrNoon;
    FLOAT dc_edhSlrNoon;
    unsigned char sstat[12];		// fld status bytes (base class excluded)
};		// DESCOND

// DESCOND field numbers (subscripts for DESCOND.sstat[] / sfirDESCOND[])
#define DESCOND_NAME 0
#define DESCOND_OWNTI 1
#define DESCOND_DOY 2
#define DESCOND_DB 3
#define DESCOND_MCDBR 4
#define DESCOND_MCWB 5
#define DESCOND_MCWBR 6
#define DESCOND_WNDSPD 7
#define DESCOND_TAUB 8
#define DESCOND_TAUD 9
#define DESCOND_EBNSLRNOON 10
#define DESCOND_EDHSLRNOON 11

#define DESCOND_NFIELDS 12  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirDESCOND[];				// DESCOND small fields-in-record table (srfd.cpp)

#define  makAncDESCOND(name)        anc<DESCOND> name( "DESCOND", sfirDESCOND, DESCOND_NFIELDS, RTDESCOND) 
#define  makAncDESCOND2(name,what)  anc<DESCOND> name( what, sfirDESCOND, DESCOND_NFIELDS, RTDESCOND)	// 'what' override


/*--- SURFGEOM ---*/

// SURFGEOM record structure
struct SURFGEOM
 { 
    SURFGEOM();
    ~SURFGEOM();
    void gx_SetParent( record* pParent, int options=0);
    RC gx_Init();
    bool gx_IsEmpty() const;
    RC gx_Validate( record* pParent, const char* what, int options=0);
    void gx_CopySubObjects();
    RC gx_CheckAndMakePolygon( int phase, int fn);
    int gx_GetAzmTilt( float& azm, float& tilt) const;
    RC gx_SetupShading ( int &nS, const class CT3D* MT, int options=0);
    void gx_ClearShading();
    int gx_CalcBeamShading( float& cosi, float& fBeam);
    record* gx_pParent;
    class SURFGEOMDET* gx_sgDet;
    MOUNTCH gx_mounting;
    INT gx_pnIdx;
    DBL gx_area;
    FLOAT gx_fBeam;
    INT gx_fBeamErrCount;
    FLOAT gx_vrtInp[37];
};		// SURFGEOM

// SURFGEOM field numbers (subscripts for SURFGEOM.sstat[] / sfirSURFGEOM[])
#define SURFGEOM_MOUNTING 0
#define SURFGEOM_PNIDX 1
#define SURFGEOM_AREA 2
#define SURFGEOM_FBEAM 3
#define SURFGEOM_FBEAMERRCOUNT 4
#define SURFGEOM_VRTINP 5

#define SURFGEOM_NFIELDS 42  					// excludes rec start ovh; is # sstat[] bytes.



/*--- SHADEX ---*/

// SHADEX record class
class SHADEX : public record 
{ public:
    SHADEX( basAnc *_b, TI i, SI noZ=0);
    virtual ~SHADEX() {} 
    SHADEX& Copy( const SHADEX& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    SHADEX& operator=( const SHADEX& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0);

    RC sx_Init();
    void FixUp();
    RC sx_CkF();
    RC Validate( int options=0);
    RC sx_SetupShading( int& nS, const class CT3D* MT, int options=0) { return sx_g.gx_SetupShading( nS, MT, options);}
    SURFGEOM sx_g;
    unsigned char sstat[44];		// fld status bytes (base class excluded)
};		// SHADEX

// SHADEX field numbers (subscripts for SHADEX.sstat[] / sfirSHADEX[])
#define SHADEX_NAME 0
#define SHADEX_OWNTI 1
#define SHADEX_G 2

#define SHADEX_NFIELDS 44  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirSHADEX[];				// SHADEX small fields-in-record table (srfd.cpp)

#define  makAncSHADEX(name)        anc<SHADEX> name( "SHADEX", sfirSHADEX, SHADEX_NFIELDS, RTSHADEX) 
#define  makAncSHADEX2(name,what)  anc<SHADEX> name( what, sfirSHADEX, SHADEX_NFIELDS, RTSHADEX)	// 'what' override


/*--- SGDIST ---*/

// SGDIST record structure
struct SGDIST
 { 
    SI sd_targTy;
    TI sd_targTi;
    FLOAT sd_FSO;
    FLOAT sd_FSC;
};		// SGDIST

// SGDIST field numbers (subscripts for SGDIST.sstat[] / sfirSGDIST[])
#define SGDIST_TARGTY 0
#define SGDIST_TARGTI 1
#define SGDIST_FSO 2
#define SGDIST_FSC 3

#define SGDIST_NFIELDS 4  					// excludes rec start ovh; is # sstat[] bytes.



/*--- HCI ---*/

// HCI record structure
struct HCI
 { 
    void hc_Init( float hc);
    double hc_HC( double hc);
    enum { hcHISTL=4 };
    FLOAT hc_history[4];
    INT hc_iXHist;
};		// HCI

// HCI field numbers (subscripts for HCI.sstat[] / sfirHCI[])
#define HCI_HISTORY 0
#define HCI_IXHIST 4

#define HCI_NFIELDS 5  					// excludes rec start ovh; is # sstat[] bytes.



/*--- SGTARG ---*/

// SGTARG record structure
struct SGTARG
 { 
    DBL st_bm;
    DBL st_df;
    DBL st_tot;
};		// SGTARG

// SGTARG field numbers (subscripts for SGTARG.sstat[] / sfirSGTARG[])
#define SGTARG_BM 0
#define SGTARG_DF 1
#define SGTARG_TOT 2

#define SGTARG_NFIELDS 3  					// excludes rec start ovh; is # sstat[] bytes.



/*--- SBCBASE ---*/

// SBCBASE record structure
struct SBCBASE
 { 
    virtual double sb_AreaNet() const = 0;
    virtual const char* sb_ParentName() const = 0;
    virtual int sb_Class() const = 0;
    FLOAT sb_absSlr;
    DBL sb_awAbsSlr;
    FLOAT sb_epsLW;
    TI sb_zi;
    DBL sb_F;
    DBL sb_Fp;
    DBL sb_frRad;
    DBL sb_fSky;
    DBL sb_fAir;
    FLOAT sb_hcNat;
    FLOAT sb_hcFrc;
    FLOAT sb_hcMult;
    FLOAT sb_hxa;
    FLOAT sb_hxr;
    FLOAT sb_hxtot;
    DBL sb_uRat;
    DBL sb_fRat;
    DBL sb_cx;
    double sb_sgf[ socCOUNT][ sgcCOUNT];
    SGTARG sb_sgTarg;
    DBL sb_sg;
    FLOAT sb_tSrf;
    FLOAT sb_tSrfls;
    DBL sb_qrAbs;
    FLOAT sb_txa;
    FLOAT sb_txr;
    FLOAT sb_txe;
    DBL sb_w;
    DBL sb_qSrf;
};		// SBCBASE

// SBCBASE field numbers (subscripts for SBCBASE.sstat[] / sfirSBCBASE[])
#define SBCBASE_ABSSLR 0
#define SBCBASE_AWABSSLR 1
#define SBCBASE_EPSLW 2
#define SBCBASE_ZI 3
#define SBCBASE_F 4
#define SBCBASE_FP 5
#define SBCBASE_FRRAD 6
#define SBCBASE_FSKY 7
#define SBCBASE_FAIR 8
#define SBCBASE_HCNAT 9
#define SBCBASE_HCFRC 10
#define SBCBASE_HCMULT 11
#define SBCBASE_HXA 12
#define SBCBASE_HXR 13
#define SBCBASE_HXTOT 14
#define SBCBASE_URAT 15
#define SBCBASE_FRAT 16
#define SBCBASE_CX 17
#define SBCBASE_SGTARG 18
#define SBCBASE_SG 21
#define SBCBASE_TSRF 22
#define SBCBASE_TSRFLS 23
#define SBCBASE_QRABS 24
#define SBCBASE_TXA 25
#define SBCBASE_TXR 26
#define SBCBASE_TXE 27
#define SBCBASE_W 28
#define SBCBASE_QSRF 29

#define SBCBASE_NFIELDS 30  					// excludes rec start ovh; is # sstat[] bytes.



/*--- SBC ---*/

// SBC record structure
struct SBC : public SBCBASE
 { 
    void sb_Init( XSURFP xs, int si);
    void sb_SGFInit();
    virtual double sb_AreaNet() const;
    virtual int sb_Class() const;
    void sb_CalcAwAbsSlr();
    virtual const char* sb_ParentName() const;
    int sb_HasHcNat() const;
    void sb_SetRunConstants( int dbPrint);
    void sb_SetCoeffs( double area, double uC);
    void sb_HCAmbient();
    float sb_CGrnd() const;
    void sb_SetCoeffsWallBG( float a[]);
    void sb_SetCoeffsFloorBG( float a4, float a5);
    void sb_HCZone();
    void sb_SetTx();
    double sb_QHT() const { return sb_qrAbs + sb_hxa*sb_txa + sb_hxr*sb_txr; }
    void sb_BalCheck();
    const char* sb_SideText();
    static void sb_DbPrintf( const char* tag, const SBC& sbcO, const SBC& sbcI);
    XSURFP sb_pXS;
    INT sb_si;
    DBL sb_fcWind;
    DBL sb_fcWind2;
    DBL sb_eta;
    DBL sb_widNom;
    DBL sb_lenNom;
    DBL sb_lenCharNat;
    DBL sb_lenEffWink;
    DBL sb_cosTilt;
    DBL sb_atvDeg;
    DBL sb_cosAtv;
    CONVMODELCH sb_hcModel;
    FLOAT sb_hcLChar;
    DBL sb_hcConst[3];
    GROUNDMODELCH sb_groundModel;
    FLOAT sb_cTaDbAvgYr;
    FLOAT sb_cTaDbAvg31;
    FLOAT sb_cTaDbAvg14;
    FLOAT sb_cTaDbAvg07;
    FLOAT sb_cTGrnd;
    FLOAT sb_rGrnd;
    FLOAT sb_rConGrnd;
    HCI sb_hCX;
};		// SBC

// SBC field numbers (subscripts for SBC.sstat[] / sfirSBC[])
#define SBC_ABSSLR 0
#define SBC_AWABSSLR 1
#define SBC_EPSLW 2
#define SBC_ZI 3
#define SBC_F 4
#define SBC_FP 5
#define SBC_FRRAD 6
#define SBC_FSKY 7
#define SBC_FAIR 8
#define SBC_HCNAT 9
#define SBC_HCFRC 10
#define SBC_HCMULT 11
#define SBC_HXA 12
#define SBC_HXR 13
#define SBC_HXTOT 14
#define SBC_URAT 15
#define SBC_FRAT 16
#define SBC_CX 17
#define SBC_SGTARG 18
#define SBC_SG 21
#define SBC_TSRF 22
#define SBC_TSRFLS 23
#define SBC_QRABS 24
#define SBC_TXA 25
#define SBC_TXR 26
#define SBC_TXE 27
#define SBC_W 28
#define SBC_QSRF 29
#define SBC_PXS 30
#define SBC_SI 31
#define SBC_FCWIND 32
#define SBC_FCWIND2 33
#define SBC_ETA 34
#define SBC_WIDNOM 35
#define SBC_LENNOM 36
#define SBC_LENCHARNAT 37
#define SBC_LENEFFWINK 38
#define SBC_COSTILT 39
#define SBC_ATVDEG 40
#define SBC_COSATV 41
#define SBC_HCMODEL 42
#define SBC_HCLCHAR 43
#define SBC_HCCONST 44
#define SBC_GROUNDMODEL 47
#define SBC_CTADBAVGYR 48
#define SBC_CTADBAVG31 49
#define SBC_CTADBAVG14 50
#define SBC_CTADBAVG07 51
#define SBC_CTGRND 52
#define SBC_RGRND 53
#define SBC_RCONGRND 54
#define SBC_HCX 55

#define SBC_NFIELDS 60  					// excludes rec start ovh; is # sstat[] bytes.



/*--- XSURF ---*/

// XSURF record structure
struct XSURF
 { 
    XSURF();
    ~XSURF();
    void xs_DeleteFENAW();
    void xs_Init( record* pParent, int options=0);
    XSURF& Copy( const XSURF* pXS, int options=0);
    RC xs_Validate( int options=0);
    SBC& xs_SBC( int si) { return si ? xs_sbcO : xs_sbcI; }
    const char* xs_Name() const;
    int xs_CanHaveExtSlr() const;
    RC xs_SetUNom();
    float& xs_AbsSlr( int io) { return xs_SBC( io).sb_absSlr; }
    float xs_AreaGlazed() const;
    void xs_SetRunConstants();
    void xs_AccumZoneValues();
    void xs_sbTest();
    RC xs_SubhrBC();
    RC xs_ASHWAT();
    RC xs_SubhrQS();
    RC xs_EndSubhr();
    void xs_AfterSubhr();
    void xs_AfterHour();
    TI xs_GetZi( int si) const;
    int xs_IsASHWAT() const;
    int xs_HasControlledShade() const;
    int xs_IsDelayed() const { return xs_msi != 0; }
    int xs_IsKiva() const;
    int xs_IsPerim() const;
    int xs_CanBeSGTarget() const;
    int xs_Class() const;
    int xs_TyFromTilt() const;
    void DbDump() const;
    record* xs_pParent;
    SI xs_ty;
    FLOAT xs_area;
    FLOAT azm;
    FLOAT tilt;
    FLOAT xs_dircos[3];
    FLOAT xs_depthBG;
    FLOAT xs_height;
    SFMODELCH xs_model;
    SFMODELCH xs_modelr;
    FLOAT xs_lThkF;
    class FENAW* xs_pFENAW[ 2];
    TI gti;
    FLOAT sco;
    FLOAT scc;
    SBC xs_sbcI;
    SBC xs_sbcO;
    FENMODELCH xs_fenModel;
    FLOAT xs_SHGC;
    FLOAT xs_fMult;
    FLOAT xs_UNFRC;
    SI xs_NGlz;
    EXSHDCH xs_exShd;
    INSHDCH xs_inShd;
    FLOAT xs_dirtLoss;
    EXCNDCH sfExCnd;
    FLOAT sfExT;
    TI sfAdjZi;
    FLOAT uI;
    FLOAT uC;
    FLOAT uX;
    FLOAT xs_Rf;
    FLOAT grndRefl;
    FLOAT vfSkyDf;
    FLOAT vfGrndDf;
    FLOAT vfSkyLW;
    FLOAT vfGrndLW;
    FLOAT xs_uval;
    FLOAT xs_UNom;
    FLOAT xs_UANom;
    FLOAT xs_rSrfNom[2];
    FLOAT xs_hSrfNom[2];
    FLOAT xs_cFctr;
    TI iwshad;
    TI xs_msi;
    FLOAT xs_tLrB[10];
    SI nsgdist;
    SGDIST sgdist[8];
};		// XSURF

// XSURF field numbers (subscripts for XSURF.sstat[] / sfirXSURF[])
#define XSURF_TY 0
#define XSURF_AREA 1
#define XSURF_AZM 2
#define XSURF_TILT 3
#define XSURF_DIRCOS 4
#define XSURF_DEPTHBG 7
#define XSURF_HEIGHT 8
#define XSURF_MODEL 9
#define XSURF_MODELR 10
#define XSURF_LTHKF 11
#define XSURF_GTI 12
#define XSURF_SCO 13
#define XSURF_SCC 14
#define XSURF_SBCI 15
#define XSURF_SBCO 75
#define XSURF_FENMODEL 135
#define XSURF_SHGC 136
#define XSURF_FMULT 137
#define XSURF_UNFRC 138
#define XSURF_NGLZ 139
#define XSURF_EXSHD 140
#define XSURF_INSHD 141
#define XSURF_DIRTLOSS 142
#define XSURF_SFEXCND 143
#define XSURF_SFEXT 144
#define XSURF_SFADJZI 145
#define XSURF_UI 146
#define XSURF_UC 147
#define XSURF_UX 148
#define XSURF_RF 149
#define XSURF_GRNDREFL 150
#define XSURF_VFSKYDF 151
#define XSURF_VFGRNDDF 152
#define XSURF_VFSKYLW 153
#define XSURF_VFGRNDLW 154
#define XSURF_UVAL 155
#define XSURF_UNOM 156
#define XSURF_UANOM 157
#define XSURF_RSRFNOM 158
#define XSURF_HSRFNOM 160
#define XSURF_CFCTR 162
#define XSURF_IWSHAD 163
#define XSURF_MSI 164
#define XSURF_TLRB 165
#define XSURF_NSGDIST 175
#define XSURF_SGDIST 176

#define XSURF_NFIELDS 208  					// excludes rec start ovh; is # sstat[] bytes.



/*--- PRI ---*/

// PRI record class
class PRI : public record 
{ public:
    PRI( basAnc *_b, TI i, SI noZ=0);
    virtual ~PRI() {} 
    PRI& Copy( const PRI& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    PRI& operator=( const PRI& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0);

    RC pr_Ckf( int options);
    void FixUp();
    XSURF x;
    FLOAT prLen;
    FLOAT prF2;
    TI xi;
    unsigned char sstat[214];		// fld status bytes (base class excluded)
};		// PRI

// PRI field numbers (subscripts for PRI.sstat[] / sfirPRI[])
#define PRI_NAME 0
#define PRI_OWNTI 1
#define PRI_X 2
#define PRI_PRLEN 210
#define PRI_PRF2 211
#define PRI_XI 212

#define PRI_NFIELDS 213  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirPRI[];				// PRI small fields-in-record table (srfd.cpp)

#define  makAncPRI(name)        anc<PRI> name( "perimeter", sfirPRI, PRI_NFIELDS, RTPRI) 
#define  makAncPRI2(name,what)  anc<PRI> name( what, sfirPRI, PRI_NFIELDS, RTPRI)	// 'what' override


/*--- SFI ---*/

// SFI record class
class SFI : public record 
{ public:
    SFI( basAnc *_b, TI i, SI noZ=0);
    virtual ~SFI(); 
    SFI& Copy( const SFI& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    SFI& operator=( const SFI& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0);

    virtual SFI& CopyFrom( const record* src, int copyName=1, int dupPtrs=0);
    RC sf_TopSf1();
    RC sf_CkfSURF( int options);
    RC sf_CkfSURFGround( int options);
    RC sf_CkfDOOR( int options);
    RC sf_CkfWINDOW( int options);
    RC sf_TopSf2();
    RC sf_MakMs();
    RC sf_SetupKiva();
    int sf_IsWallBG() const;
    int sf_IsFloorBG() const;
    int sf_IsBG() const;
    RC sf_BGWallSetup( class AR_MASSLAYER& arML);
    RC sf_BGFloorSetup( class AR_MASSLAYER& arML);
    RC sf_BGFinalizeLayers( class AR_MASSLAYER& arML, float RFilm, float RNom=-1.f);
    static int sf_IsSubhrly( int m);
    static int sf_IsDelayed( int m);
    static int sf_IsKiva( int m);
    static int sf_IsFD( int m);
    int sf_IsChild() const;
    SFI* sf_GetParent();
    const SFI* sf_GetParent() const;
    TI sf_GetZI( int si) const;
    ZNR* sf_GetZone( int si) const;
    RC Validate( int options=0);
    void FixUp();
    std::vector<TI> sf_sharedFndWalls;
    XSURF x;
    INT sfClass;
    FLOAT sfArea;
    FLOAT sfU;
    TI sfCon;
    OSTYCH sfTy;
    TI sfFnd;
    TI sfFndFloor;
    FLOAT sfExpPerim;
    FLOAT width;
    FLOAT height;
    FLOAT mult;
    TI xi;
    TI sf_msi;
    unsigned char sstat[224];		// fld status bytes (base class excluded)
};		// SFI

// SFI field numbers (subscripts for SFI.sstat[] / sfirSFI[])
#define SFI_NAME 0
#define SFI_OWNTI 1
#define SFI_X 2
#define SFI_SFCLASS 210
#define SFI_SFAREA 211
#define SFI_SFU 212
#define SFI_SFCON 213
#define SFI_SFTY 214
#define SFI_SFFND 215
#define SFI_SFFNDFLOOR 216
#define SFI_SFEXPPERIM 217
#define SFI_WIDTH 218
#define SFI_HEIGHT 219
#define SFI_MULT 220
#define SFI_XI 221
#define SFI_MSI 222

#define SFI_NFIELDS 223  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirSFI[];				// SFI small fields-in-record table (srfd.cpp)

#define  makAncSFI(name)        anc<SFI> name( "surface", sfirSFI, SFI_NFIELDS, RTSFI) 
#define  makAncSFI2(name,what)  anc<SFI> name( what, sfirSFI, SFI_NFIELDS, RTSFI)	// 'what' override


/*--- XSRAT ---*/

// XSRAT record class
class XSRAT : public record 
{ public:
    XSRAT( basAnc *_b, TI i, SI noZ=0);
    virtual ~XSRAT(); 
    XSRAT& Copy( const XSRAT& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    XSRAT& operator=( const XSRAT& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0);

    RC Validate( int options=0);
    void FixUp();
    void xr_SGAccumAbsTrans();
    void xr_SGFInit();
    void xr_SGFAccum( const double sgf[ sgcCOUNT]);
    void xr_SGIncTrans( int sunup, float verSun);
    void xr_SGMakeSGRATs();
    class Kiva::Aggregator* xr_kivaAggregator;
    RC xr_ApplyKivaResults();
    RC xr_KivaZoneAccum();
    TI nxXsurf;
    TI nxXsSpecT;
    XSURF x;
    unsigned char sstat[212];		// fld status bytes (base class excluded)
};		// XSRAT

// XSRAT field numbers (subscripts for XSRAT.sstat[] / sfirXSRAT[])
#define XSRAT_NAME 0
#define XSRAT_OWNTI 1
#define XSRAT_NXXSURF 2
#define XSRAT_NXXSSPECT 3
#define XSRAT_X 4

#define XSRAT_NFIELDS 212  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirXSRAT[];				// XSRAT small fields-in-record table (srfd.cpp)

#define  makAncXSRAT(name)        anc<XSRAT> name( "xsurf", sfirXSRAT, XSRAT_NFIELDS, RTXSRAT) 
#define  makAncXSRAT2(name,what)  anc<XSRAT> name( what, sfirXSRAT, XSRAT_NFIELDS, RTXSRAT)	// 'what' override


/*--- WSHADRAT ---*/

// WSHADRAT record class
class WSHADRAT : public record 
{ public:
    WSHADRAT( basAnc *_b, TI i, SI noZ=0)  :  record( _b, i, noZ)  {} 
    virtual ~WSHADRAT() {} 
    WSHADRAT& Copy( const WSHADRAT& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    WSHADRAT& operator=( const WSHADRAT& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0) { record::Copy( pSrc, options); };

    float SunlitFract( float gamma, float cosz) const;
    FLOAT wWidth;
    FLOAT wHeight;
    FLOAT ohDepth;
    FLOAT ohDistUp;
    FLOAT ohExL;
    FLOAT ohExR;
    FLOAT ohFlap;
    FLOAT lfDepth;
    FLOAT lfTopUp;
    FLOAT lfDistL;
    FLOAT lfBotUp;
    FLOAT rfDepth;
    FLOAT rfTopUp;
    FLOAT rfDistR;
    FLOAT rfBotUp;
    unsigned char sstat[18];		// fld status bytes (base class excluded)
};		// WSHADRAT

// WSHADRAT field numbers (subscripts for WSHADRAT.sstat[] / sfirWSHADRAT[])
#define WSHADRAT_NAME 0
#define WSHADRAT_OWNTI 1
#define WSHADRAT_WWIDTH 2
#define WSHADRAT_WHEIGHT 3
#define WSHADRAT_OHDEPTH 4
#define WSHADRAT_OHDISTUP 5
#define WSHADRAT_OHEXL 6
#define WSHADRAT_OHEXR 7
#define WSHADRAT_OHFLAP 8
#define WSHADRAT_LFDEPTH 9
#define WSHADRAT_LFTOPUP 10
#define WSHADRAT_LFDISTL 11
#define WSHADRAT_LFBOTUP 12
#define WSHADRAT_RFDEPTH 13
#define WSHADRAT_RFTOPUP 14
#define WSHADRAT_RFDISTR 15
#define WSHADRAT_RFBOTUP 16

#define WSHADRAT_NFIELDS 17  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirWSHADRAT[];				// WSHADRAT small fields-in-record table (srfd.cpp)

#define  makAncWSHADRAT(name)        anc<WSHADRAT> name( "shade", sfirWSHADRAT, WSHADRAT_NFIELDS, RTWSHADRAT) 
#define  makAncWSHADRAT2(name,what)  anc<WSHADRAT> name( what, sfirWSHADRAT, WSHADRAT_NFIELDS, RTWSHADRAT)	// 'what' override


/*--- MASSBC ---*/

// MASSBC record structure
struct MASSBC
 { 
    RC bc_Setup( int msi, int _ty, int si);
    TI bc_msi;
    SI bc_ty;
    TI bc_zi;
    FLOAT bc_exTa;
    FLOAT bc_exTr;
    FLOAT bc_rsurf;
    FLOAT bc_h;
    FLOAT bc_ha;
    RIGTARG rIg;
    DBL qxhnet;
    DBL qxdnet;
    DBL qxmnet;
    DBL qxhtot;
    DBL qxdtot;
    DBL qxmtot;
    FLOAT bc_surfTemp;
};		// MASSBC

// MASSBC field numbers (subscripts for MASSBC.sstat[] / sfirMASSBC[])
#define MASSBC_MSI 0
#define MASSBC_TY 1
#define MASSBC_ZI 2
#define MASSBC_EXTA 3
#define MASSBC_EXTR 4
#define MASSBC_RSURF 5
#define MASSBC_H 6
#define MASSBC_HA 7
#define MASSBC_RIG 8
#define MASSBC_QXHNET 9
#define MASSBC_QXDNET 10
#define MASSBC_QXMNET 11
#define MASSBC_QXHTOT 12
#define MASSBC_QXDTOT 13
#define MASSBC_QXMTOT 14
#define MASSBC_SURFTEMP 15

#define MASSBC_NFIELDS 16  					// excludes rec start ovh; is # sstat[] bytes.



/*--- MSRAT ---*/

// MSRAT record class
class MSRAT : public record 
{ public:
    MSRAT( basAnc *_b, TI i, SI noZ=0)  :  record( _b, i, noZ)  {} 
    virtual ~MSRAT(); 
    MSRAT& Copy( const MSRAT& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    MSRAT& operator=( const MSRAT& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0);

    ZNR* ms_GetZone( int si) const;
    void ms_RddInit( double t);
    void ms_StepMX( float dur, float tDbO);
    void ms_StepFD();
    double ms_InternalEnergy() const;
    int ms_IsMassless() const;
    inline int ms_NLayer() const;
    RC ms_SetMSBCTNODE( int erOp=WRN);
    void DelSubObjects( int options=0);
    RC ms_Make( SFI* sf, const CON* con, int options=0);
    const SFI* ms_GetSFI() const;
    const XSRAT* ms_GetXSRAT() const;
    XSRAT* ms_GetXSRAT();
    void ms_BegIvl( int ivl);
    void ms_EndIvl( int ivl);
    void ms_QXSurf( int ivl, double& qxNet, double& qxTot) const;
    RC ms_Enbal( int ivl, float tol, double& ovNet, double& ovTot);
    const char* ms_SurfBCDesc( int si) const;
    TI ms_sfi;
    INT ms_sfClass;
    TI ms_xri;
    FLOAT ms_area;
    BOO isSubhrly;
    BOO ms_isFD;
    MASSBC inside;
    MASSBC outside;
    FLOAT ms_UNom;
    FLOAT ms_tc;
    DBL ms_qBal[4];
    double& ms_QBal( int ivl) { return IvlData( ms_qBal, ivl); }
    DBL ms_qIE[4];
    double& ms_QIE( int ivl) { return IvlData( ms_qIE, ivl); }
    DBL ms_qIEDelta[4];
    double& ms_QIEDelta( int ivl) { return IvlData( ms_qIEDelta, ivl); }
    INT ms_flags[4];
    int& ms_Flags( int ivl) { return IvlData( ms_flags, ivl); }
    INT ms_ebErrCount;
    MASSMODELP ms_pMM;
    unsigned char sstat[60];		// fld status bytes (base class excluded)
};		// MSRAT

// MSRAT field numbers (subscripts for MSRAT.sstat[] / sfirMSRAT[])
#define MSRAT_NAME 0
#define MSRAT_OWNTI 1
#define MSRAT_SFI 2
#define MSRAT_SFCLASS 3
#define MSRAT_XRI 4
#define MSRAT_AREA 5
#define MSRAT_ISSUBHRLY 6
#define MSRAT_ISFD 7
#define MSRAT_INSIDE 8
#define MSRAT_OUTSIDE 24
#define MSRAT_UNOM 40
#define MSRAT_TC 41
#define MSRAT_QBAL 42
#define MSRAT_QIE 46
#define MSRAT_QIEDELTA 50
#define MSRAT_FLAGS 54
#define MSRAT_EBERRCOUNT 58
#define MSRAT_PMM 59

#define MSRAT_NFIELDS 60  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirMSRAT[];				// MSRAT small fields-in-record table (srfd.cpp)

#define  makAncMSRAT(name)        anc<MSRAT> name( "mass", sfirMSRAT, MSRAT_NFIELDS, RTMSRAT) 
#define  makAncMSRAT2(name,what)  anc<MSRAT> name( what, sfirMSRAT, MSRAT_NFIELDS, RTMSRAT)	// 'what' override


/*--- KIVA ---*/

// KIVA record class
class KIVA : public record 
{ public:
    KIVA( basAnc *_b, TI i, SI noZ=0)  :  record( _b, i, noZ)  {} 
    virtual ~KIVA(); 
    KIVA& Copy( const KIVA& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    KIVA& operator=( const KIVA& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0) { record::Copy( pSrc, options); };

    ZNR* kv_GetZone() const;
    RC kv_Create();
    RC kv_RddInit();
    RC kv_SetInitBCs(DOY jDay);
    RC kv_SetBCs();
    RC kv_Step(float dur);
    class Kiva::Instance* kv_instance;
    std::vector<TI> kv_walls;
    TI kv_floor;
    FLOAT kv_perimWeight;
    unsigned char sstat[4];		// fld status bytes (base class excluded)
};		// KIVA

// KIVA field numbers (subscripts for KIVA.sstat[] / sfirKIVA[])
#define KIVA_NAME 0
#define KIVA_OWNTI 1
#define KIVA_FLOOR 2
#define KIVA_PERIMWEIGHT 3

#define KIVA_NFIELDS 4  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirKIVA[];				// KIVA small fields-in-record table (srfd.cpp)

#define  makAncKIVA(name)        anc<KIVA> name( "kiva", sfirKIVA, KIVA_NFIELDS, RTKIVA) 
#define  makAncKIVA2(name,what)  anc<KIVA> name( what, sfirKIVA, KIVA_NFIELDS, RTKIVA)	// 'what' override


/*--- SGI ---*/

// SGI record class
class SGI : public record 
{ public:
    SGI( basAnc *_b, TI i, SI noZ=0)  :  record( _b, i, noZ)  {} 
    virtual ~SGI() {} 
    SGI& Copy( const SGI& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    SGI& operator=( const SGI& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0) { record::Copy( pSrc, options); };

    SIDECH sgSide;
    SGDIST d;
    unsigned char sstat[8];		// fld status bytes (base class excluded)
};		// SGI

// SGI field numbers (subscripts for SGI.sstat[] / sfirSGI[])
#define SGI_NAME 0
#define SGI_OWNTI 1
#define SGI_SGSIDE 2
#define SGI_D 3

#define SGI_NFIELDS 7  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirSGI[];				// SGI small fields-in-record table (srfd.cpp)

#define  makAncSGI(name)        anc<SGI> name( "sgdist", sfirSGI, SGI_NFIELDS, RTSGI) 
#define  makAncSGI2(name,what)  anc<SGI> name( what, sfirSGI, SGI_NFIELDS, RTSGI)	// 'what' override


/*--- SGRAT ---*/

// SGRAT record class
class SGRAT : public record 
{ public:
    SGRAT( basAnc *_b, TI i, SI noZ=0)  :  record( _b, i, noZ)  {} 
    virtual ~SGRAT() {} 
    SGRAT& Copy( const SGRAT& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    SGRAT& operator=( const SGRAT& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0) { record::Copy( pSrc, options); };

    void sg_ToTarg( float bmRad, float dfRad);
    void sg_DbDump() const;
    SI sg_addIt;
    SGTARGP sg_pTarg;
    BOO sg_isSubhrly;
    FLOATP sg_pControl;
    DBL sg_bmXBmF[24];
    DBL sg_dfXBmF[24];
    DBL sg_dfXDfF[24];
    unsigned char sstat[78];		// fld status bytes (base class excluded)
};		// SGRAT

// SGRAT field numbers (subscripts for SGRAT.sstat[] / sfirSGRAT[])
#define SGRAT_NAME 0
#define SGRAT_OWNTI 1
#define SGRAT_ADDIT 2
#define SGRAT_PTARG 3
#define SGRAT_ISSUBHRLY 4
#define SGRAT_PCONTROL 5
#define SGRAT_BMXBMF 6
#define SGRAT_DFXBMF 30
#define SGRAT_DFXDFF 54

#define SGRAT_NFIELDS 78  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirSGRAT[];				// SGRAT small fields-in-record table (srfd.cpp)

#define  makAncSGRAT(name)        anc<SGRAT> name( "solarGain", sfirSGRAT, SGRAT_NFIELDS, RTSGRAT) 
#define  makAncSGRAT2(name,what)  anc<SGRAT> name( what, sfirSGRAT, SGRAT_NFIELDS, RTSGRAT)	// 'what' override


/*--- GT ---*/

// GT record class
class GT : public record 
{ public:
    GT( basAnc *_b, TI i, SI noZ=0)  :  record( _b, i, noZ)  {} 
    virtual ~GT() {} 
    GT& Copy( const GT& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    GT& operator=( const GT& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0) { record::Copy( pSrc, options); };

    int gt_IsASHWAT() const { return gtFenModel == C_FENMODELCH_ASHWAT; }
    FLOAT gtSHGC;
    FLOAT gtSMSO;
    FLOAT gtSMSC;
    FLOAT gtFMult;
    PY4 gtPySHGC;
    FLOAT gtDMSHGC;
    FLOAT gtDMRBSol;
    FLOAT gtU;
    FLOAT gtUNFRC;
    SI gtNGlz;
    FENMODELCH gtFenModel;
    EXSHDCH gtExShd;
    INSHDCH gtInShd;
    FLOAT gtDirtLoss;
    unsigned char sstat[22];		// fld status bytes (base class excluded)
};		// GT

// GT field numbers (subscripts for GT.sstat[] / sfirGT[])
#define GT_NAME 0
#define GT_OWNTI 1
#define GT_GTSHGC 2
#define GT_GTSMSO 3
#define GT_GTSMSC 4
#define GT_GTFMULT 5
#define GT_GTPYSHGC 6
#define GT_GTDMSHGC 12
#define GT_GTDMRBSOL 13
#define GT_GTU 14
#define GT_GTUNFRC 15
#define GT_GTNGLZ 16
#define GT_GTFENMODEL 17
#define GT_GTEXSHD 18
#define GT_GTINSHD 19
#define GT_GTDIRTLOSS 20

#define GT_NFIELDS 21  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirGT[];				// GT small fields-in-record table (srfd.cpp)

#define  makAncGT(name)        anc<GT> name( "glazeType", sfirGT, GT_NFIELDS, RTGT) 
#define  makAncGT2(name,what)  anc<GT> name( what, sfirGT, GT_NFIELDS, RTGT)	// 'what' override


/*--- CON ---*/

// CON record class
class CON : public record 
{ public:
    CON( basAnc *_b, TI i, SI noZ=0)  :  record( _b, i, noZ)  {} 
    virtual ~CON() {} 
    CON& Copy( const CON& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    CON& operator=( const CON& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0) { record::Copy( pSrc, options); };

    RC cn_Layers( class AR_MASSLAYER& arML, int options=0) const;
    int cn_IsFramed() const {	return nFrmLr > 0; }
    FLOAT conU;
    SI nLr;
    SI nFrmLr;
    FLOAT r;
    FLOAT hc;
    FLOAT rNom;
    unsigned char sstat[8];		// fld status bytes (base class excluded)
};		// CON

// CON field numbers (subscripts for CON.sstat[] / sfirCON[])
#define CON_NAME 0
#define CON_OWNTI 1
#define CON_CONU 2
#define CON_NLR 3
#define CON_NFRMLR 4
#define CON_R 5
#define CON_HC 6
#define CON_RNOM 7

#define CON_NFIELDS 8  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirCON[];				// CON small fields-in-record table (srfd.cpp)

#define  makAncCON(name)        anc<CON> name( "construction", sfirCON, CON_NFIELDS, RTCON) 
#define  makAncCON2(name,what)  anc<CON> name( what, sfirCON, CON_NFIELDS, RTCON)	// 'what' override


/*--- LR ---*/

// LR record class
class LR : public record 
{ public:
    LR( basAnc *_b, TI i, SI noZ=0)  :  record( _b, i, noZ)  {} 
    virtual ~LR() {} 
    LR& Copy( const LR& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    LR& operator=( const LR& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0) { record::Copy( pSrc, options); };

    RC lr_TopLr();
    FLOAT lr_thk;
    TI lr_mati;
    TI lr_frmMati;
    FLOAT lr_frmFrac;
    FLOAT lr_uvy;
    FLOAT lr_r;
    FLOAT lr_vhc;
    unsigned char sstat[10];		// fld status bytes (base class excluded)
};		// LR

// LR field numbers (subscripts for LR.sstat[] / sfirLR[])
#define LR_NAME 0
#define LR_OWNTI 1
#define LR_THK 2
#define LR_MATI 3
#define LR_FRMMATI 4
#define LR_FRMFRAC 5
#define LR_UVY 6
#define LR_R 7
#define LR_VHC 8

#define LR_NFIELDS 9  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirLR[];				// LR small fields-in-record table (srfd.cpp)

#define  makAncLR(name)        anc<LR> name( "layer", sfirLR, LR_NFIELDS, RTLR) 
#define  makAncLR2(name,what)  anc<LR> name( what, sfirLR, LR_NFIELDS, RTLR)	// 'what' override


/*--- MAT ---*/

// MAT record class
class MAT : public record 
{ public:
    MAT( basAnc *_b, TI i, SI noZ=0)  :  record( _b, i, noZ)  {} 
    virtual ~MAT() {} 
    MAT& Copy( const MAT& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    MAT& operator=( const MAT& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0) { record::Copy( pSrc, options); };

    static double mt_CondT( float T, float kRtd, float kCT, float kTRat)
    {	return max( .001, kRtd*(1.+kCT*(T-kTRat))); }
    double mt_CondT( float T) const
    { return mt_CondT( T, mt_cond, mt_condCT, mt_condTRat); }
    static void mt_CondAB( float kRtd, float kCT, float kTRat, double& A, double& B)
    {	A = mt_CondT( 0.f, kRtd, kCT, kTRat); B = kCT*kRtd; }
    void mt_CondAB( double& A, double& B) const
    {	mt_CondAB( mt_cond, mt_condCT, mt_condTRat, A, B); }
    FLOAT mt_thk;
    FLOAT mt_cond;
    FLOAT mt_condTRat;
    FLOAT mt_condCT;
    FLOAT mt_spHt;
    FLOAT mt_dens;
    FLOAT mt_rNom;
    FLOAT mt_vhc;
    unsigned char sstat[10];		// fld status bytes (base class excluded)
};		// MAT

// MAT field numbers (subscripts for MAT.sstat[] / sfirMAT[])
#define MAT_NAME 0
#define MAT_OWNTI 1
#define MAT_THK 2
#define MAT_COND 3
#define MAT_CONDTRAT 4
#define MAT_CONDCT 5
#define MAT_SPHT 6
#define MAT_DENS 7
#define MAT_RNOM 8
#define MAT_VHC 9

#define MAT_NFIELDS 10  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirMAT[];				// MAT small fields-in-record table (srfd.cpp)

#define  makAncMAT(name)        anc<MAT> name( "material", sfirMAT, MAT_NFIELDS, RTMAT) 
#define  makAncMAT2(name,what)  anc<MAT> name( what, sfirMAT, MAT_NFIELDS, RTMAT)	// 'what' override


/*--- FOUNDATION ---*/

// FOUNDATION record class
class FOUNDATION : public record 
{ public:
    FOUNDATION( basAnc *_b, TI i, SI noZ=0)  :  record( _b, i, noZ)  {} 
    virtual ~FOUNDATION() {} 
    FOUNDATION& Copy( const FOUNDATION& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    FOUNDATION& operator=( const FOUNDATION& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0) { record::Copy( pSrc, options); };

    class Kiva::Foundation* fd_kivaFnd;
    RC fd_SetupKiva();
    FLOAT fd_wlHtAbvGrd;
    FLOAT fd_wlDpBlwSlb;
    TI fd_ftWlConi;
    unsigned char sstat[6];		// fld status bytes (base class excluded)
};		// FOUNDATION

// FOUNDATION field numbers (subscripts for FOUNDATION.sstat[] / sfirFOUNDATION[])
#define FOUNDATION_NAME 0
#define FOUNDATION_OWNTI 1
#define FOUNDATION_WLHTABVGRD 2
#define FOUNDATION_WLDPBLWSLB 3
#define FOUNDATION_FTWLCONI 4

#define FOUNDATION_NFIELDS 5  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirFOUNDATION[];				// FOUNDATION small fields-in-record table (srfd.cpp)

#define  makAncFOUNDATION(name)        anc<FOUNDATION> name( "foundation", sfirFOUNDATION, FOUNDATION_NFIELDS, RTFOUNDATION) 
#define  makAncFOUNDATION2(name,what)  anc<FOUNDATION> name( what, sfirFOUNDATION, FOUNDATION_NFIELDS, RTFOUNDATION)	// 'what' override


/*--- FNDBLOCK ---*/

// FNDBLOCK record class
class FNDBLOCK : public record 
{ public:
    FNDBLOCK( basAnc *_b, TI i, SI noZ=0)  :  record( _b, i, noZ)  {} 
    virtual ~FNDBLOCK() {} 
    FNDBLOCK& Copy( const FNDBLOCK& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    FNDBLOCK& operator=( const FNDBLOCK& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0) { record::Copy( pSrc, options); };

    TI fb_mati;
    FBXREFCH fb_x1Ref;
    FBZREFCH fb_z1Ref;
    FLOAT fb_x1;
    FLOAT fb_z1;
    FBXREFCH fb_x2Ref;
    FBZREFCH fb_z2Ref;
    FLOAT fb_x2;
    FLOAT fb_z2;
    unsigned char sstat[12];		// fld status bytes (base class excluded)
};		// FNDBLOCK

// FNDBLOCK field numbers (subscripts for FNDBLOCK.sstat[] / sfirFNDBLOCK[])
#define FNDBLOCK_NAME 0
#define FNDBLOCK_OWNTI 1
#define FNDBLOCK_MATI 2
#define FNDBLOCK_X1REF 3
#define FNDBLOCK_Z1REF 4
#define FNDBLOCK_X1 5
#define FNDBLOCK_Z1 6
#define FNDBLOCK_X2REF 7
#define FNDBLOCK_Z2REF 8
#define FNDBLOCK_X2 9
#define FNDBLOCK_Z2 10

#define FNDBLOCK_NFIELDS 11  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirFNDBLOCK[];				// FNDBLOCK small fields-in-record table (srfd.cpp)

#define  makAncFNDBLOCK(name)        anc<FNDBLOCK> name( "foundationBlock", sfirFNDBLOCK, FNDBLOCK_NFIELDS, RTFNDBLOCK) 
#define  makAncFNDBLOCK2(name,what)  anc<FNDBLOCK> name( what, sfirFNDBLOCK, FNDBLOCK_NFIELDS, RTFNDBLOCK)	// 'what' override


/*--- RFI ---*/

// RFI record class
class RFI : public record 
{ public:
    RFI( basAnc *_b, TI i, SI noZ=0)  :  record( _b, i, noZ)  {} 
    virtual ~RFI(); 
    RFI& Copy( const RFI& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    RFI& operator=( const RFI& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0);

    RC rf_CkF( int isExport);
    RC rf_CkF2( int isExport);
    RC rf_CheckForDupFileName();
    int rf_CheckAccessAndAlias( const char* fName, char* &fNameAlias, const char** ppMsg=NULL);
    CHP fileName;
    FILESTATCH fileStat;
    NOYESCH pageFmt;
    SI fileStatChecked;
    SI overWrite;
    SI wasNotEmpty;
    unsigned char sstat[8];		// fld status bytes (base class excluded)
};		// RFI

// RFI field numbers (subscripts for RFI.sstat[] / sfirRFI[])
#define RFI_NAME 0
#define RFI_OWNTI 1
#define RFI_FILENAME 2
#define RFI_FILESTAT 3
#define RFI_PAGEFMT 4
#define RFI_FILESTATCHECKED 5
#define RFI_OVERWRITE 6
#define RFI_WASNOTEMPTY 7

#define RFI_NFIELDS 8  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirRFI[];				// RFI small fields-in-record table (srfd.cpp)

#define  makAncRFI(name)        anc<RFI> name( "reportFile", sfirRFI, RFI_NFIELDS, RTRFI) 
#define  makAncRFI2(name,what)  anc<RFI> name( what, sfirRFI, RFI_NFIELDS, RTRFI)	// 'what' override


/*--- RI ---*/

// RI record class
class RI : public record 
{ public:
    RI( basAnc *_b, TI i, SI noZ=0)  :  record( _b, i, noZ)  {} 
    virtual ~RI(); 
    RI& Copy( const RI& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    RI& operator=( const RI& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0);

    RC ri_CkF();
    RC ri_oneRxp();
    TI zi;
    TI mtri;
    TI ahi;
    TI tui;
    TI ri_dhwMtri;
    TI ri_afMtri;
    BOO isExport;
    RPTYCH rpTy;
    IVLCH rpFreq;
    DOY rpDayBeg;
    DOY rpDayEnd;
    FLOAT rpBtuSf;
    LI rpCond;
    CHP rpTitle;
    SI rpCpl;
    RPTHDCH rpHeader;
    NOYESCH rpFooter;
    SI putAtEnd;
    TI coli;
    SI nCol;
    SI wid;
    INT vrh;
    unsigned char sstat[24];		// fld status bytes (base class excluded)
};		// RI

// RI field numbers (subscripts for RI.sstat[] / sfirRI[])
#define RI_NAME 0
#define RI_OWNTI 1
#define RI_ZI 2
#define RI_MTRI 3
#define RI_AHI 4
#define RI_TUI 5
#define RI_DHWMTRI 6
#define RI_AFMTRI 7
#define RI_ISEXPORT 8
#define RI_RPTY 9
#define RI_RPFREQ 10
#define RI_RPDAYBEG 11
#define RI_RPDAYEND 12
#define RI_RPBTUSF 13
#define RI_RPCOND 14
#define RI_RPTITLE 15
#define RI_RPCPL 16
#define RI_RPHEADER 17
#define RI_RPFOOTER 18
#define RI_PUTATEND 19
#define RI_COLI 20
#define RI_NCOL 21
#define RI_WID 22
#define RI_VRH 23

#define RI_NFIELDS 24  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirRI[];				// RI small fields-in-record table (srfd.cpp)

#define  makAncRI(name)        anc<RI> name( "report", sfirRI, RI_NFIELDS, RTRI) 
#define  makAncRI2(name,what)  anc<RI> name( what, sfirRI, RI_NFIELDS, RTRI)	// 'what' override


/*--- COL ---*/

// COL record class
class COL : public record 
{ public:
    COL( basAnc *_b, TI i, SI noZ=0);
    virtual ~COL(); 
    COL& Copy( const COL& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    COL& operator=( const COL& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0);

    virtual record& CopyFrom( const record *src, int copyName=1, int dupPtrs=0);
    virtual RC Validate( int options=0);
    CHP colHead;
    SI colGap;
    SI colWid;
    SI colDec;
    JUSTCH colJust;
    VALNDT colVal;
    TI nxColi;
    unsigned char sstat[10];		// fld status bytes (base class excluded)
};		// COL

// COL field numbers (subscripts for COL.sstat[] / sfirCOL[])
#define COL_NAME 0
#define COL_OWNTI 1
#define COL_COLHEAD 2
#define COL_COLGAP 3
#define COL_COLWID 4
#define COL_COLDEC 5
#define COL_COLJUST 6
#define COL_COLVAL 7
#define COL_NXCOLI 8

#define COL_NFIELDS 9  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirCOL[];				// COL small fields-in-record table (srfd.cpp)

#define  makAncCOL(name)        anc<COL> name( "reportCol", sfirCOL, COL_NFIELDS, RTCOL) 
#define  makAncCOL2(name,what)  anc<COL> name( what, sfirCOL, COL_NFIELDS, RTCOL)	// 'what' override


/*--- DVRI ---*/

// DVRI record class
class DVRI : public record 
{ public:
    DVRI( basAnc *_b, TI i, SI noZ=0)  :  record( _b, i, noZ)  {} 
    virtual ~DVRI(); 
    DVRI& Copy( const DVRI& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    DVRI& operator=( const DVRI& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0);

    void dv_vpDHWMtrRow( RXPORTINFO *rxt, TI dhwMtri=-1);
    void dv_vpAfMtrRow( RXPORTINFO *rxt, TI afMtri=-1);
    bool dv_IsReportActive( DOY jDay) const;
    TI mtri;
    TI dv_dhwMtri;
    TI dv_afMtri;
    TI ahi;
    TI tui;
    BOO isExport;
    BOO isAll;
    RPTYCH rpTy;
    IVLCH rpFreq;
    DOY rpDayBeg;
    DOY rpDayEnd;
    FLOAT rpBtuSf;
    LI rpCond;
    SI rpCondGiven;
    CHP rpTitle;
    SI rpCpl;
    RPTHDCH rpHeader;
    NOYESCH rpFooter;
    TI coli;
    SI nCol;
    SI wid;
    INT vrh;
    TI nextNow;
    unsigned char sstat[26];		// fld status bytes (base class excluded)
};		// DVRI

// DVRI field numbers (subscripts for DVRI.sstat[] / sfirDVRI[])
#define DVRI_NAME 0
#define DVRI_OWNTI 1
#define DVRI_MTRI 2
#define DVRI_DHWMTRI 3
#define DVRI_AFMTRI 4
#define DVRI_AHI 5
#define DVRI_TUI 6
#define DVRI_ISEXPORT 7
#define DVRI_ISALL 8
#define DVRI_RPTY 9
#define DVRI_RPFREQ 10
#define DVRI_RPDAYBEG 11
#define DVRI_RPDAYEND 12
#define DVRI_RPBTUSF 13
#define DVRI_RPCOND 14
#define DVRI_RPCONDGIVEN 15
#define DVRI_RPTITLE 16
#define DVRI_RPCPL 17
#define DVRI_RPHEADER 18
#define DVRI_RPFOOTER 19
#define DVRI_COLI 20
#define DVRI_NCOL 21
#define DVRI_WID 22
#define DVRI_VRH 23
#define DVRI_NEXTNOW 24

#define DVRI_NFIELDS 25  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirDVRI[];				// DVRI small fields-in-record table (srfd.cpp)

#define  makAncDVRI(name)        anc<DVRI> name( "dvri", sfirDVRI, DVRI_NFIELDS, RTDVRI) 
#define  makAncDVRI2(name,what)  anc<DVRI> name( what, sfirDVRI, DVRI_NFIELDS, RTDVRI)	// 'what' override


/*--- IMPF ---*/

// IMPF record class
class IMPF : public record 
{ public:
    IMPF( basAnc *_b, TI i, SI noZ=0)  :  record( _b, i, noZ)  {} 
    virtual ~IMPF(); 
    IMPF& Copy( const IMPF& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    IMPF& operator=( const IMPF& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0);

    BOO FC scanHdr();
    BOO FC readRec();
    BOO FC scanNextField();
    BOO    scanField( char *&p, char *&start);
    BOO FC readBuf();
    void FC close();
    void FC fnrtAl(SI nNfnr);
    CHP fileName;
    CHP imTitle;
    SI imPhaseSpare;
    IVLCH imFreq;
    NOYESCH hasHeader;
    NOYESCH imBinary;
    TI iffnmi;
    BOO isOpen;
    SI fh;
    LI posEndHdr;
    CHP buf;
    USI bufSz;
    USI bufN;
    BOO eofRead;
    BOO eof;
    USI bufI1;
    USI bufI2;
    USI lineNo;
    USI lineNoEndHdr;
    SI nFieldsScanned;
    BOO eorScanned;
    struct FNRT* fnrt;
    USI fnrtNAl;
    unsigned char sstat[24];		// fld status bytes (base class excluded)
};		// IMPF

// IMPF field numbers (subscripts for IMPF.sstat[] / sfirIMPF[])
#define IMPF_NAME 0
#define IMPF_OWNTI 1
#define IMPF_FILENAME 2
#define IMPF_IMTITLE 3
#define IMPF_IMPHASESPARE 4
#define IMPF_IMFREQ 5
#define IMPF_HASHEADER 6
#define IMPF_IMBINARY 7
#define IMPF_IFFNMI 8
#define IMPF_ISOPEN 9
#define IMPF_FH 10
#define IMPF_POSENDHDR 11
#define IMPF_BUF 12
#define IMPF_BUFSZ 13
#define IMPF_BUFN 14
#define IMPF_EOFREAD 15
#define IMPF_EOF 16
#define IMPF_BUFI1 17
#define IMPF_BUFI2 18
#define IMPF_LINENO 19
#define IMPF_LINENOENDHDR 20
#define IMPF_NFIELDSSCANNED 21
#define IMPF_EORSCANNED 22
#define IMPF_FNRTNAL 23

#define IMPF_NFIELDS 24  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirIMPF[];				// IMPF small fields-in-record table (srfd.cpp)

#define  makAncIMPF(name)        anc<IMPF> name( "importFile", sfirIMPF, IMPF_NFIELDS, RTIMPF) 
#define  makAncIMPF2(name,what)  anc<IMPF> name( what, sfirIMPF, IMPF_NFIELDS, RTIMPF)	// 'what' override


/*--- IFFNM ---*/

// IFFNM record class
class IFFNM : public record 
{ public:
    IFFNM( basAnc *_b, TI i, SI noZ=0)  :  record( _b, i, noZ)  {} 
    virtual ~IFFNM(); 
    IFFNM& Copy( const IFFNM& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    IFFNM& operator=( const IFFNM& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0);

    TI impfi;
    SI fnmiN;
    struct FNMT* fnmt;
    SI fnmtNAl;
    unsigned char sstat[6];		// fld status bytes (base class excluded)
};		// IFFNM

// IFFNM field numbers (subscripts for IFFNM.sstat[] / sfirIFFNM[])
#define IFFNM_NAME 0
#define IFFNM_OWNTI 1
#define IFFNM_IMPFI 2
#define IFFNM_FNMIN 3
#define IFFNM_FNMTNAL 4

#define IFFNM_NFIELDS 5  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirIFFNM[];				// IFFNM small fields-in-record table (srfd.cpp)

#define  makAncIFFNM(name)        anc<IFFNM> name( "impFileFldNames", sfirIFFNM, IFFNM_NFIELDS, RTIFFNM) 
#define  makAncIFFNM2(name,what)  anc<IFFNM> name( what, sfirIFFNM, IFFNM_NFIELDS, RTIFFNM)	// 'what' override


/*--- AUSZ ---*/

// AUSZ record structure
struct AUSZ
 { 
    int fazInit( float* xptr, BOO negFlag, record *r, SI fn, int isAusz);
    void az_CallPVF( void( AUSZ::*pvf)(), const char* fmt, ...);
    void rddiInit();
    void begP1Dsd();
    void begP1aDsdIter();
    BOO resizeIf( float x, BOO goose);
    BOO unsizeIf( float x);
    void endP1a();
    void begP1b();
    void endP1bDsd();
    void p2Init();
    void begP2Dsd();
    void begP2DsdIter();
    void endP2Dsd();
    void p2EndTest();
    void afterP2EndTest();
    void cvgTest();
    void final( record *r, record *ir, float over);
    BOO az_active;
    FLOATP az_px;
    BOO isNeg;
    FLOAT az_a;
    FLOAT az_b;
    FLOAT ldPk;
    FLOAT ldPkAs;
    FLOAT ldPkAs1;
    FLOAT plrPk;
    FLOAT plrPkAs;
    FLOAT xPk;
    FLOAT xPkAs;
    CHP az_doing;
    FLOAT e1;
    FLOAT e2;
    FLOAT orig;
};		// AUSZ

// AUSZ field numbers (subscripts for AUSZ.sstat[] / sfirAUSZ[])
#define AUSZ_AZ_ACTIVE 0
#define AUSZ_AZ_PX 1
#define AUSZ_ISNEG 2
#define AUSZ_AZ_A 3
#define AUSZ_AZ_B 4
#define AUSZ_LDPK 5
#define AUSZ_LDPKAS 6
#define AUSZ_LDPKAS1 7
#define AUSZ_PLRPK 8
#define AUSZ_PLRPKAS 9
#define AUSZ_XPK 10
#define AUSZ_XPKAS 11
#define AUSZ_AZ_DOING 12
#define AUSZ_E1 13
#define AUSZ_E2 14
#define AUSZ_ORIG 15

#define AUSZ_NFIELDS 16  					// excludes rec start ovh; is # sstat[] bytes.



/*--- CONVERGER ---*/

// CONVERGER record structure
struct CONVERGER
 { 
    CONVERGER( DBL _mxInc=1., DBL _mnMxInc=1.e-11, DBL _mnSigChg=1.e-4) { init(_mxInc, _mnMxInc, _mnSigChg); }
    void init( DBL _maxIncr=1., DBL _minMaxIncr=1.e-11, DBL _minSigChange=1.e-4);
    BOO doit( DBL &v, SI &nIter);
    BOO isSetup;
    DBL minSigChange;
    DBL minMaxIncr;
    DBL maxIncr;
    DBL v2;
    DBL v1;
    DBL v0;
    DBL d1;
    DBL d0;
    SI nRev;
    SI nitSince;
};		// CONVERGER

// CONVERGER field numbers (subscripts for CONVERGER.sstat[] / sfirCONVERGER[])
#define CONVERGER_ISSETUP 0
#define CONVERGER_MINSIGCHANGE 1
#define CONVERGER_MINMAXINCR 2
#define CONVERGER_MAXINCR 3
#define CONVERGER_V2 4
#define CONVERGER_V1 5
#define CONVERGER_V0 6
#define CONVERGER_D1 7
#define CONVERGER_D0 8
#define CONVERGER_NREV 9
#define CONVERGER_NITSINCE 10

#define CONVERGER_NFIELDS 11  					// excludes rec start ovh; is # sstat[] bytes.



/*--- AIRSTATE ---*/

// AIRSTATE record structure
struct AIRSTATE
 { 
    AIRSTATE() {}
    AIRSTATE( const AIRSTATE& as) { as_tdb=as.as_tdb; as_w=as.as_w; }
    AIRSTATE( double tdb, double w) : as_tdb( tdb), as_w( w) { }
    void as_Init() { as_tdb=0.; as_w=0.; }
    void as_Set( double tdb, double w) { as_tdb=tdb; as_w = w; }
    void as_Set( const AIRFLOW& af);
    void as_SetWFromRh( float rh) { as_w = psyHumRat2( as_tdb, rh); }
    float as_Twb() const { return psyTWetBulb( as_tdb, as_w); }
    float as_Enthalpy() const { return psyEnthalpy( as_tdb, as_w); }
    float as_RelHum() const { return psyRelHum4( as_tdb, as_w); }
    float as_RhoDry() const { return psyDenDryAir( as_tdb, as_w); }
    float as_RhoMoist() const { return psyDenMoistAir( as_tdb, as_w); }
    double as_AddQSen( double q, double amf);
    double as_AddQSen2( double q, double amf);
    double as_QSenDiff2( const AIRSTATE& as, double amf) const;
    double as_AddQLat( double q, double amf);
    double as_AddDeltaT( double dt) { as_tdb += dt; return as_tdb; }
    int as_AddQSenLat( float& qSen, float& qLat, double amf, float rhMax=1.f);
    AIRSTATE& as_MixF( float f, const AIRSTATE& asX) { return as_MixF( f, asX.as_tdb, asX.as_w); }
    AIRSTATE& as_MixF( float f, double tdb, double w);
    int as_IsEqual( const AIRSTATE& as, double tol=.001) const;
    int operator==( const AIRSTATE& as) const { return as_IsEqual( as); }
    int operator!=( const AIRSTATE& as) const { return !as_IsEqual( as); }
    static double af_HXEff( double xSup, double xExh, double eff) { return (1.-eff)*xSup + eff*xExh; }
    int as_HX( const AIRSTATE& asSup, float amfSup, const AIRSTATE& asExh, float amfExh, float effS, float effL);
    DBL as_tdb;
    DBL as_w;
};		// AIRSTATE

// AIRSTATE field numbers (subscripts for AIRSTATE.sstat[] / sfirAIRSTATE[])
#define AIRSTATE_TDB 0
#define AIRSTATE_W 1

#define AIRSTATE_NFIELDS 2  					// excludes rec start ovh; is # sstat[] bytes.



/*--- AIRFLOW ---*/

// AIRFLOW record structure
struct AIRFLOW : public AIRSTATE
 { 
    AIRFLOW() : AIRSTATE(), af_amf( 0.) { }
    AIRFLOW( double amf, double tdb, double w) { af_Init( amf, tdb, w); }
    double af_Tdb() const { return as_tdb; }
    double af_W() const { return as_w; }
    double af_Wmf() const { return af_amf*as_w; }
    void af_GetAirState( AIRSTATE& as) const { as.as_Set( as_tdb, as_w); }
    void af_SetAirState( const AIRSTATE& as) { as_Set( as.as_tdb, as.as_w); }
    void af_Init() { af_amf=0.; as_tdb=0.; as_w=0.; }
    void af_Init( double amf, double tdb, double w) { af_amf=amf;	as_tdb=tdb; as_w=w; }
    void af_Copy( const AIRFLOW& af){ af_amf=af.af_amf; as_tdb=af.as_tdb; as_w=af.as_w; }
    void af_Mix( const AIRFLOW& af);
    void af_AccumDry( double amf, double tdb, double w);
    void af_AccumDry( double amf, const AIRSTATE& as) { af_AccumDry( amf, as.as_tdb, as.as_w); }
    void af_AccumMoist( double amf, double tdb, double w) { af_AccumDry( amf*Top.tp_refWX, tdb, w); }
    double af_AmfCp()  const { return af_amf*Top.tp_airSH; }
    double af_AmfCpT() const { return af_amf*as_tdb*Top.tp_airSH; }
    double af_QLat( double wx) const { return af_amf*(as_w - wx)*PsyHCondWtr; }
    DBL af_amf;
};		// AIRFLOW

// AIRFLOW field numbers (subscripts for AIRFLOW.sstat[] / sfirAIRFLOW[])
#define AIRFLOW_TDB 0
#define AIRFLOW_W 1
#define AIRFLOW_AMF 2

#define AIRFLOW_NFIELDS 3  					// excludes rec start ovh; is # sstat[] bytes.



/*--- FAN ---*/

// FAN record structure
struct FAN
 { 
    RC fn_setup( FANAPPCH app, record *r, SI fanFn, float defVfDs, FAN* defCurveFrom);
    void fn_setup2( int options=0);
    double fn_puteVf( DBL /*CFLOW*/ vf, DBL /*TEMP*/ t, DBL /*FRAC*/ frOn=1.0);
    double fn_pute( DBL /*CFLOW*/ c, DBL /*TEMP*/ t, DBL /*FRAC*/ frOn=1.0);
    FANTYCH fanTy;
    FLOAT vfDs;
    FLOAT vfDs_As;
    FLOAT vfDs_AsNov;
    FLOAT vfMxF;
    FLOAT press;
    FLOAT eff;
    FLOAT shaftPwr;
    FLOAT elecPwr;
    MOTTYCH fn_motTy;
    FLOAT motEff;
    MOTPOSCH motPos;
    PYCUBIC2 curvePy;
    TI fn_mtri;
    ENDUSECH fn_endUse;
    BOO ausz;
    FLOAT outPower;
    FLOAT airPower;
    FLOAT cMx;
    FLOAT c;
    FLOAT t;
    FLOAT frOn;
    FLOAT p;
    FLOAT q;
    FLOAT dT;
    FLOAT qAround;
};		// FAN

// FAN field numbers (subscripts for FAN.sstat[] / sfirFAN[])
#define FAN_FANTY 0
#define FAN_VFDS 1
#define FAN_VFDS_AS 2
#define FAN_VFDS_ASNOV 3
#define FAN_VFMXF 4
#define FAN_PRESS 5
#define FAN_EFF 6
#define FAN_SHAFTPWR 7
#define FAN_ELECPWR 8
#define FAN_MOTTY 9
#define FAN_MOTEFF 10
#define FAN_MOTPOS 11
#define FAN_CURVEPY 12
#define FAN_MTRI 18
#define FAN_ENDUSE 19
#define FAN_AUSZ 20
#define FAN_OUTPOWER 21
#define FAN_AIRPOWER 22
#define FAN_CMX 23
#define FAN_C 24
#define FAN_T 25
#define FAN_FRON 26
#define FAN_P 27
#define FAN_Q 28
#define FAN_DT 29
#define FAN_QAROUND 30

#define FAN_NFIELDS 31  					// excludes rec start ovh; is # sstat[] bytes.



/*--- ZNISUB ---*/

// ZNISUB record structure
struct ZNISUB
 { 
    int IsCountable( int options) const { return options==0 || options==znModel; }
    float zn_HeightZ( float f) const;
    int zn_IsConvRad() const { return znModel >= C_ZNMODELCH_CZM; }
    int zn_IsUZ() const { return znModel >= C_ZNMODELCH_UZM; }
    ZNMODELCH znModel;
    FLOAT znArea;
    FLOAT znVol;
    FLOAT zn_floorZ;
    FLOAT zn_ceilingHt;
    FLOAT znCAir;
    FLOAT znCAirSh;
    FLOAT zn_HIRatio;
    FLOAT znAzm;
    BOO plenumRet;
    FLOAT znSC;
    FLOAT znTH;
    FLOAT znTD;
    FLOAT znTC;
    FLOAT znQMxH;
    FLOAT znQMxHRated;
    FLOAT znQMxC;
    FLOAT znQMxCRated;
    TI zn_rsi;
    FLOAT zn_hcFrcF;
    FLOAT zn_hcAirX;
    INT zn_hcAirXIsSet;
    FLOAT xfanFOn;
    FAN xfan;
    FLOAT infAC;
    FLOAT infELA;
    SI zn_infShld;
    SI zn_infStories;
    FLOAT zn_eaveZ;
    FLOAT zn_windFLkg;
    TI zn_afMtri;
    INT vrZdd;
};		// ZNISUB

// ZNISUB field numbers (subscripts for ZNISUB.sstat[] / sfirZNISUB[])
#define ZNISUB_ZNMODEL 0
#define ZNISUB_ZNAREA 1
#define ZNISUB_ZNVOL 2
#define ZNISUB_FLOORZ 3
#define ZNISUB_CEILINGHT 4
#define ZNISUB_ZNCAIR 5
#define ZNISUB_ZNCAIRSH 6
#define ZNISUB_HIRATIO 7
#define ZNISUB_ZNAZM 8
#define ZNISUB_PLENUMRET 9
#define ZNISUB_ZNSC 10
#define ZNISUB_ZNTH 11
#define ZNISUB_ZNTD 12
#define ZNISUB_ZNTC 13
#define ZNISUB_ZNQMXH 14
#define ZNISUB_ZNQMXHRATED 15
#define ZNISUB_ZNQMXC 16
#define ZNISUB_ZNQMXCRATED 17
#define ZNISUB_RSI 18
#define ZNISUB_HCFRCF 19
#define ZNISUB_HCAIRX 20
#define ZNISUB_HCAIRXISSET 21
#define ZNISUB_XFANFON 22
#define ZNISUB_XFAN 23
#define ZNISUB_INFAC 54
#define ZNISUB_INFELA 55
#define ZNISUB_INFSHLD 56
#define ZNISUB_INFSTORIES 57
#define ZNISUB_EAVEZ 58
#define ZNISUB_WINDFLKG 59
#define ZNISUB_AFMTRI 60
#define ZNISUB_VRZDD 61

#define ZNISUB_NFIELDS 62  					// excludes rec start ovh; is # sstat[] bytes.



/*--- ZNI ---*/

// ZNI record class
class ZNI : public record 
{ public:
    ZNI( basAnc *_b, TI i, SI noZ=0)  :  record( _b, i, noZ)  {} 
    virtual ~ZNI() {} 
    ZNI& Copy( const ZNI& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    ZNI& operator=( const ZNI& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0) { record::Copy( pSrc, options); };

    RC zi_Top( int re);
    ZNISUB i;
    unsigned char sstat[64];		// fld status bytes (base class excluded)
};		// ZNI

// ZNI field numbers (subscripts for ZNI.sstat[] / sfirZNI[])
#define ZNI_NAME 0
#define ZNI_OWNTI 1
#define ZNI_I 2

#define ZNI_NFIELDS 64  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirZNI[];				// ZNI small fields-in-record table (srfd.cpp)

#define  makAncZNI(name)        anc<ZNI> name( "zone", sfirZNI, ZNI_NFIELDS, RTZNI) 
#define  makAncZNI2(name,what)  anc<ZNI> name( what, sfirZNI, ZNI_NFIELDS, RTZNI)	// 'what' override


/*--- ZNR ---*/

// ZNR record class
class ZNR : public record 
{ public:
    ZNR( basAnc *_b, TI i, SI noZ=0);
    virtual ~ZNR(); 
    ZNR& Copy( const ZNR& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    ZNR& operator=( const ZNR& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0);

    void addRIgDist( RIGTARGTY targTy, TI targTi, float targFr);
    void zn_AddIZXFERs();
    TI zn_AddIZXFER( IZNVTYCH ty, const char* nmSfx, const AIRFLOW* pAF=NULL);
    TI zn_FindOrAddIZXFER( IZNVTYCH ty, const char* nmSfx, const AIRFLOW* pAF=NULL);
    XSRAT* zn_FindXSRAT( const char* xsName);
    MSRAT* zn_FindMSRAT( const char* xsName);
    void zn_AccumBalTermsQS( double area, const SBC& sbcI, const SBC& sbcO);
    void zn_EndSubhrQS( double area, double uC, SBC& sbcI, SBC& sbcO);
    void zn_InitSurfTotals();
    void zn_AccumSurfTotals( SBCBASE& S);
    void zn_FinalizeSurfTotals();
    void zn_DbDumpSGDIST( const char* tag) const;
    void zn_SetAirRadXArea();
    RC zn_RadX();
    RC zn_FFactors( struct SFPLIST& sfpList);
    RC zn_RddInit();
    RC zn_BegHour1();
    RC zn_BegHour2();
    RC zn_XFan();
    RC zn_BegSubhr1();
    RC zn_BegSubhr2();
    RC zn_InitSubhr();
    RC zn_LoadsSubhr( BOO azCf);
    void zn_GetAirState( AIRSTATE& as) const { as.as_Set( tz, wz); }
    void zn_GetAirStateLs( AIRSTATE& as) const { as.as_Set( tzls, wzls); }
    int zn_HasRSYS() const { return i.zn_rsi != 0; }
    RSYS* zn_GetRSYS();
    const RSYS* zn_GetRSYS() const;
    int zn_IsHCAvail( int what) const;
    float zn_VentTSup();
    double zn_TAirCR( double mCpT, double mCp, double qRad) const;
    double zn_TAirCR( double mCpT, double mCp) const;
    double zn_TRadCR( double tza, double qRad) const;
    double zn_TRadCR( double tza) const;
    double zn_QAirCR( double tza, double qRad) const;
    double zn_QAirCR( double tza) const;
    double zn_QsHvacCR( double tza, float fConv) const;
    double zn_AmfHvacCR( double tza, double tSup, double qRad) const;
    double zn_AmfHvacCR( double tza, double tSup) const;
    void zn_TAirFloatCR() { tz = zn_balC1 / zn_balC2; }
    void zn_SetRSYSAmf( float fSize, int iAux);
    void zn_SetRSYSAmfFromTSup();
    RC zn_CondixCR2();
    RC zn_AirFlowVsTsup();
    int zn_AssessVentUtility();
    int zn_OAVAttempt( double tSup);
    int zn_FVentCR();
    RC zn_CondixCR( ULI ventAvail);
    RC zn_AirRequest( RSYS* rs, int options=0);
    RC zn_AirX();
    RC zn_MoistureBalCR();
    RC zn_ComfortCR();
    void zn_DbDump() const;
    RC zn_AfterSubhr();
    RC zn_AfterHour();
    RC zn_InfilSetup();
    RC ztuEndSubhr();
    RC ztuCompute();
    RC ztuMode();
    RC ztuMdSeq();
    RC ztuAbs( SI md, BOO fromZtu, DBL &aqHvO, DBL &bHvO, DBL &wcO, DBL &wcO1, DBL &cO );
    DBL znW( DBL wc, DBL c, DBL tz, DBL &zLGain);
    void ztuMdSets( SI md);
    BOO nxTu( TU *&tu);
    BOO nxZhx( ZHX *&x);
    BOO nxZhxSt( ZHX *&x);
    int IsCountable( int options) const { return i.IsCountable( options); }
    int zn_IsConvRad() const { return i.zn_IsConvRad(); }
    int zn_IsUZ() const { return i.zn_IsUZ(); }
    int zn_IsSFModelSupported( int sfModel) const;
    void zn_SGClearTots();
    void zn_SGCavAbs();
    void zn_SGToZone();
    ZNISUB i;
    TI xsurf1;
    TI xsSpecT1;
    TI tu1;
    TI zhx1;
    TI zhx1St;
    BOO znSCF;
    FLOAT zn_stackc;
    FLOAT zn_windc;
    USI rIgDistNAl;
    USI rIgDistN;
    RIGDISTP rIgDist;
    WVect< SBCBASE*> zn_sbcList;
    DBL zn_surfA;
    DBL zn_surfASlr;
    DBL zn_ductA;
    DBL zn_surfEpsLWAvg;
    DBL zn_airRadXC1;
    DBL zn_airRadXC2;
    DBL zn_airRadXArea;
    DBL zn_FAir;
    DBL zn_airCxF;
    DBL zn_airCx;
    DBL rmTrans[2];
    FLOAT rmAbs;
    DBL adjRmAbs[2];
    DBL rmAbsCAir;
    DBL cavAbsCAir[2];
    DBL sgfCavBm[2];
    DBL sgfCavDf[2];
    DBL sgSaBm[2];
    DBL sgSaDf[2];
    DBL sgfCAirBm[2];
    DBL sgfCAirDf[2];
    DBL zn_uaSpecT;
    DBL zn_ua;
    DBL zn_UANom;
    DBL zn_ductCondUANom;
    DBL haMass;
    DBL zn_BGWallPerim;
    DBL zn_BGWallPA4;
    DBL zn_BGWallPA5;
    DBL qSgTot;
    SGTARG zn_sgTotTarg;
    RIGTARG qrIgTot;
    RIGTARG qrIgTotO;
    RIGTARG qrIgTotIz;
    RIGTARG qrIgAir;
    FLOAT qrIgMs;
    DBL znSGain;
    DBL znLGain;
    DBL znLitDmd;
    DBL znLitEu;
    DBL qsIgHr;
    DBL znXLGain;
    DBL znXLGainLs;
    DBL zn_aqLdHr;
    DBL zn_uaXSpecT;
    DBL aMassHr;
    DBL bcon;
    DBL bLdHr;
    DBL xqh;
    DBL qMsSg;
    DBL zn_qSgAir;
    SGTARG zn_sgAirTarg;
    DBL qSgTotSh;
    SGTARG zn_sgTotShTarg;
    DBL aMassSh;
    DBL zn_uaInfil;
    DBL zn_qIzXAnSh;
    DBL zn_qIzSh;
    DBL zn_pz0W[2];
    DBL zn_pz0;
    SI zn_ventUt;
    void zn_AccumAirFlow( int iV, double mDot, const AIRSTATE& as, double td=0.);
    DBL zn_aqLdSh;
    DBL zn_bLdSh;
    DBL zn_xqs;
    DBL zn_qDuctCondAir;
    DBL zn_qDuctCondRad;
    DBL zn_qDuctCond;
    DBL zn_qDHWLossAir;
    DBL zn_qDHWLossRad;
    DBL zn_qDHWLoss;
    void zn_CoupleDHWLossSubhr( double qLoss, float fR=0.5f);
    DBL zn_qHPWH;
    FLOAT zn_hpwhAirX;
    SI zn_anVentEffect;
    AIRFLOW zn_airNetI[2];
    double zn_AnAmfCp( int iV) const { return zn_airNetI[ iV].af_AmfCp(); }
    double zn_AnAmfCpT( int iV) const { return zn_airNetI[ iV].af_AmfCpT(); }
    double zn_AnAmf() const;
    double zn_NonAnIVAmf() const;
    FLOAT zn_fVentPrf;
    FLOAT zn_tzVent;
    FLOAT zn_fVent;
    DBL zn_anAmfCpVent;
    DBL zn_anAmfCpTVent;
    AIRFLOW zn_ductLkI;
    AIRFLOW zn_ductLkO;
    AIRFLOW zn_sysAirI;
    AIRFLOW zn_sysAirO;
    AIRFLOW zn_OAVRlfO;
    AIRFLOW zn_sysDepAirIls;
    DBL zn_nAirSh;
    DBL zn_dAirSh;
    DBL zn_nRadSh;
    DBL zn_dRadSh;
    DBL zn_cxSh;
    DBL zn_dRpCx;
    DBL zn_nRxCx;
    DBL zn_dRxCx;
    DBL zn_balC1;
    DBL zn_balC2;
    DBL zn_hcATMsSh;
    DBL zn_hrATMsSh;
    DBL zn_hcAMsSh;
    DBL zn_hrAMsSh;
    DBL zn_qCondQS;
    DBL zn_qCondMS;
    DBL zn_ieMass;
    DBL zn_ieMassls;
    INT zn_ebErrCount;
    DBL zn_rsAmfSysReq[2];
    FLOAT zn_rsFSize;
    DBL zn_rsAmfSup;
    DBL zn_rsAmfRet;
    DBL zn_rsAmfRetLs;
    FLOAT zn_tzsp;
    SI zn_hcMode;
    FLOAT zn_unMetHDH;
    FLOAT zn_unMetCDH;
    FLOAT zn_fConvH;
    FLOAT zn_fConvC;
    FLOAT zn_fConv;
    DBL aqHvO;
    DBL bHvO;
    DBL aq;
    DBL b;
    DBL cM;
    DBL qM;
    FLOAT cTot;
    DBL zn_qsHvac;
    DBL zn_qlHvac;
    DBL zn_qlIz;
    LI zn_wCase;
    LI zn_airMode;
    DBL zn_rho;
    DBL zn_rho0;
    DBL zn_rho0ls;
    DBL zn_dryAirMass;
    DBL zn_dryAirMassEff;
    FLOAT zn_ivAirX;
    FLOAT zn_airX;
    FLOAT zn_hcAirXls;
    FLOAT zn_hcFrc;
    FLOAT zn_windPresV;
    DBL wcSum;
    DBL wcSum1;
    DBL cSum;
    DBL tz;
    DBL aTz;
    DBL wz;
    FLOAT zn_relHum;
    FLOAT zn_relHumls;
    FLOAT zn_relHumlh;
    DBL zn_twb;
    DBL aWz;
    DBL tzls;
    DBL wzls;
    DBL tzlh;
    DBL tzlsDelta;
    DBL wzlsDelta;
    DBL zn_Rho0() const;
    DBL tr;
    DBL trls;
    DBL trlh;
    SI md;
    SI nMd;
    SI mdSeq[21];
    DBL tuCz;
    DBL tuCzWas;
    BOO spCf;
    BOO ztuCf;
    DBL xqhPr;
    DBL xqsPr;
    FLOAT qIzShPr;
    FLOAT tzlsPr;
    FLOAT wzlsPr;
    SI mdPr;
    DBL znLGainPr;
    unsigned char sstat[300];		// fld status bytes (base class excluded)
};		// ZNR

// ZNR field numbers (subscripts for ZNR.sstat[] / sfirZNR[])
#define ZNR_NAME 0
#define ZNR_OWNTI 1
#define ZNR_I 2
#define ZNR_XSURF1 64
#define ZNR_XSSPECT1 65
#define ZNR_TU1 66
#define ZNR_ZHX1 67
#define ZNR_ZHX1ST 68
#define ZNR_ZNSCF 69
#define ZNR_STACKC 70
#define ZNR_WINDC 71
#define ZNR_RIGDISTNAL 72
#define ZNR_RIGDISTN 73
#define ZNR_RIGDIST 74
#define ZNR_SURFA 75
#define ZNR_SURFASLR 76
#define ZNR_DUCTA 77
#define ZNR_SURFEPSLWAVG 78
#define ZNR_AIRRADXC1 79
#define ZNR_AIRRADXC2 80
#define ZNR_AIRRADXAREA 81
#define ZNR_FAIR 82
#define ZNR_AIRCXF 83
#define ZNR_AIRCX 84
#define ZNR_RMTRANS 85
#define ZNR_RMABS 87
#define ZNR_ADJRMABS 88
#define ZNR_RMABSCAIR 90
#define ZNR_CAVABSCAIR 91
#define ZNR_SGFCAVBM 93
#define ZNR_SGFCAVDF 95
#define ZNR_SGSABM 97
#define ZNR_SGSADF 99
#define ZNR_SGFCAIRBM 101
#define ZNR_SGFCAIRDF 103
#define ZNR_UASPECT 105
#define ZNR_UA 106
#define ZNR_UANOM 107
#define ZNR_DUCTCONDUANOM 108
#define ZNR_HAMASS 109
#define ZNR_BGWALLPERIM 110
#define ZNR_BGWALLPA4 111
#define ZNR_BGWALLPA5 112
#define ZNR_QSGTOT 113
#define ZNR_SGTOTTARG 114
#define ZNR_QRIGTOT 117
#define ZNR_QRIGTOTO 118
#define ZNR_QRIGTOTIZ 119
#define ZNR_QRIGAIR 120
#define ZNR_QRIGMS 121
#define ZNR_ZNSGAIN 122
#define ZNR_ZNLGAIN 123
#define ZNR_ZNLITDMD 124
#define ZNR_ZNLITEU 125
#define ZNR_QSIGHR 126
#define ZNR_ZNXLGAIN 127
#define ZNR_ZNXLGAINLS 128
#define ZNR_AQLDHR 129
#define ZNR_UAXSPECT 130
#define ZNR_AMASSHR 131
#define ZNR_BCON 132
#define ZNR_BLDHR 133
#define ZNR_XQH 134
#define ZNR_QMSSG 135
#define ZNR_QSGAIR 136
#define ZNR_SGAIRTARG 137
#define ZNR_QSGTOTSH 140
#define ZNR_SGTOTSHTARG 141
#define ZNR_AMASSSH 144
#define ZNR_UAINFIL 145
#define ZNR_QIZXANSH 146
#define ZNR_QIZSH 147
#define ZNR_PZ0W 148
#define ZNR_PZ0 150
#define ZNR_VENTUT 151
#define ZNR_AQLDSH 152
#define ZNR_BLDSH 153
#define ZNR_XQS 154
#define ZNR_QDUCTCONDAIR 155
#define ZNR_QDUCTCONDRAD 156
#define ZNR_QDUCTCOND 157
#define ZNR_QDHWLOSSAIR 158
#define ZNR_QDHWLOSSRAD 159
#define ZNR_QDHWLOSS 160
#define ZNR_QHPWH 161
#define ZNR_HPWHAIRX 162
#define ZNR_ANVENTEFFECT 163
#define ZNR_AIRNETI 164
#define ZNR_FVENTPRF 170
#define ZNR_TZVENT 171
#define ZNR_FVENT 172
#define ZNR_ANAMFCPVENT 173
#define ZNR_ANAMFCPTVENT 174
#define ZNR_DUCTLKI 175
#define ZNR_DUCTLKO 178
#define ZNR_SYSAIRI 181
#define ZNR_SYSAIRO 184
#define ZNR_OAVRLFO 187
#define ZNR_SYSDEPAIRILS 190
#define ZNR_NAIRSH 193
#define ZNR_DAIRSH 194
#define ZNR_NRADSH 195
#define ZNR_DRADSH 196
#define ZNR_CXSH 197
#define ZNR_DRPCX 198
#define ZNR_NRXCX 199
#define ZNR_DRXCX 200
#define ZNR_BALC1 201
#define ZNR_BALC2 202
#define ZNR_HCATMSSH 203
#define ZNR_HRATMSSH 204
#define ZNR_HCAMSSH 205
#define ZNR_HRAMSSH 206
#define ZNR_QCONDQS 207
#define ZNR_QCONDMS 208
#define ZNR_IEMASS 209
#define ZNR_IEMASSLS 210
#define ZNR_EBERRCOUNT 211
#define ZNR_RSAMFSYSREQ 212
#define ZNR_RSFSIZE 214
#define ZNR_RSAMFSUP 215
#define ZNR_RSAMFRET 216
#define ZNR_RSAMFRETLS 217
#define ZNR_TZSP 218
#define ZNR_HCMODE 219
#define ZNR_UNMETHDH 220
#define ZNR_UNMETCDH 221
#define ZNR_FCONVH 222
#define ZNR_FCONVC 223
#define ZNR_FCONV 224
#define ZNR_AQHVO 225
#define ZNR_BHVO 226
#define ZNR_AQ 227
#define ZNR_B 228
#define ZNR_CM 229
#define ZNR_QM 230
#define ZNR_CTOT 231
#define ZNR_QSHVAC 232
#define ZNR_QLHVAC 233
#define ZNR_QLIZ 234
#define ZNR_WCASE 235
#define ZNR_AIRMODE 236
#define ZNR_RHO 237
#define ZNR_RHO0 238
#define ZNR_RHO0LS 239
#define ZNR_DRYAIRMASS 240
#define ZNR_DRYAIRMASSEFF 241
#define ZNR_IVAIRX 242
#define ZNR_AIRX 243
#define ZNR_HCAIRXLS 244
#define ZNR_HCFRC 245
#define ZNR_WINDPRESV 246
#define ZNR_WCSUM 247
#define ZNR_WCSUM1 248
#define ZNR_CSUM 249
#define ZNR_TZ 250
#define ZNR_ATZ 251
#define ZNR_WZ 252
#define ZNR_RELHUM 253
#define ZNR_RELHUMLS 254
#define ZNR_RELHUMLH 255
#define ZNR_TWB 256
#define ZNR_AWZ 257
#define ZNR_TZLS 258
#define ZNR_WZLS 259
#define ZNR_TZLH 260
#define ZNR_TZLSDELTA 261
#define ZNR_WZLSDELTA 262
#define ZNR_TR 263
#define ZNR_TRLS 264
#define ZNR_TRLH 265
#define ZNR_MD 266
#define ZNR_NMD 267
#define ZNR_MDSEQ 268
#define ZNR_TUCZ 289
#define ZNR_TUCZWAS 290
#define ZNR_SPCF 291
#define ZNR_ZTUCF 292
#define ZNR_XQHPR 293
#define ZNR_XQSPR 294
#define ZNR_QIZSHPR 295
#define ZNR_TZLSPR 296
#define ZNR_WZLSPR 297
#define ZNR_MDPR 298
#define ZNR_ZNLGAINPR 299

#define ZNR_NFIELDS 300  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirZNR[];				// ZNR small fields-in-record table (srfd.cpp)

#define  makAncZNR(name)        anc<ZNR> name( "zone", sfirZNR, ZNR_NFIELDS, RTZNR) 
#define  makAncZNR2(name,what)  anc<ZNR> name( what, sfirZNR, ZNR_NFIELDS, RTZNR)	// 'what' override


/*--- ZNRES_IVL_SUB ---*/

// ZNRES_IVL_SUB record structure
struct ZNRES_IVL_SUB
 { 
    double zr_TotAbsSen() const;
    double zr_TotAbsLat() const;
    void zr_Init1( int options=0, const ZNR* zp=NULL);
    void zr_Zero() { memset( this, 0, sizeof( ZNRES_IVL_SUB)); }
    INT n;
    SI nHrHeat;
    SI nHrCool;
    SI nHrFanv;
    SI nHrNatv;
    SI nHrCeilFan;
    LI nIter;
    LI nHrUnMetH;
    LI nHrUnMetC;
    LI nShVentH;
    LI nSubhr;
    LI nSubhrLX;
    FLOAT tAir;
    FLOAT tRad;
    FLOAT PMV7730;
    FLOAT PPD7730;
    FLOAT ivAirX;
    FLOAT pz0;
    FLOAT wAir;
    FLOAT qCond;
    FLOAT qsInfil;
    FLOAT qSlr;
    FLOAT qsIg;
    FLOAT qMass;
    FLOAT qsIz;
    FLOAT qsMech;
    FLOAT eqfVentHr;
    FLOAT qlInfil;
    FLOAT qlIg;
    FLOAT qlIz;
    FLOAT qlAir;
    FLOAT qlMech;
    FLOAT qsBal;
    FLOAT qlBal;
    FLOAT qlX;
    FLOAT unMetHDH;
    FLOAT unMetCDH;
    FLOAT qscHvac;
    FLOAT qshHvac;
    FLOAT qcMech;
    FLOAT qhMech;
    FLOAT qvMech;
    FLOAT litDmd;
    FLOAT litEu;
};		// ZNRES_IVL_SUB

// ZNRES_IVL_SUB field numbers (subscripts for ZNRES_IVL_SUB.sstat[] / sfirZNRES_IVL_SUB[])
#define ZNRES_IVL_SUB_N 0
#define ZNRES_IVL_SUB_NHRHEAT 1
#define ZNRES_IVL_SUB_NHRCOOL 2
#define ZNRES_IVL_SUB_NHRFANV 3
#define ZNRES_IVL_SUB_NHRNATV 4
#define ZNRES_IVL_SUB_NHRCEILFAN 5
#define ZNRES_IVL_SUB_NITER 6
#define ZNRES_IVL_SUB_NHRUNMETH 7
#define ZNRES_IVL_SUB_NHRUNMETC 8
#define ZNRES_IVL_SUB_NSHVENTH 9
#define ZNRES_IVL_SUB_NSUBHR 10
#define ZNRES_IVL_SUB_NSUBHRLX 11
#define ZNRES_IVL_SUB_TAIR 12
#define ZNRES_IVL_SUB_TRAD 13
#define ZNRES_IVL_SUB_PMV7730 14
#define ZNRES_IVL_SUB_PPD7730 15
#define ZNRES_IVL_SUB_IVAIRX 16
#define ZNRES_IVL_SUB_PZ0 17
#define ZNRES_IVL_SUB_WAIR 18
#define ZNRES_IVL_SUB_QCOND 19
#define ZNRES_IVL_SUB_QSINFIL 20
#define ZNRES_IVL_SUB_QSLR 21
#define ZNRES_IVL_SUB_QSIG 22
#define ZNRES_IVL_SUB_QMASS 23
#define ZNRES_IVL_SUB_QSIZ 24
#define ZNRES_IVL_SUB_QSMECH 25
#define ZNRES_IVL_SUB_EQFVENTHR 26
#define ZNRES_IVL_SUB_QLINFIL 27
#define ZNRES_IVL_SUB_QLIG 28
#define ZNRES_IVL_SUB_QLIZ 29
#define ZNRES_IVL_SUB_QLAIR 30
#define ZNRES_IVL_SUB_QLMECH 31
#define ZNRES_IVL_SUB_QSBAL 32
#define ZNRES_IVL_SUB_QLBAL 33
#define ZNRES_IVL_SUB_QLX 34
#define ZNRES_IVL_SUB_UNMETHDH 35
#define ZNRES_IVL_SUB_UNMETCDH 36
#define ZNRES_IVL_SUB_QSCHVAC 37
#define ZNRES_IVL_SUB_QSHHVAC 38
#define ZNRES_IVL_SUB_QCMECH 39
#define ZNRES_IVL_SUB_QHMECH 40
#define ZNRES_IVL_SUB_QVMECH 41
#define ZNRES_IVL_SUB_LITDMD 42
#define ZNRES_IVL_SUB_LITEU 43

#define ZNRES_IVL_SUB_NFIELDS 44  					// excludes rec start ovh; is # sstat[] bytes.



/*--- ZNRES_SUB ---*/

// ZNRES_SUB record structure
struct ZNRES_SUB
 { 
    ZNRES_IVL_SUB Y;
    ZNRES_IVL_SUB M;
    ZNRES_IVL_SUB D;
    ZNRES_IVL_SUB H;
    ZNRES_IVL_SUB S;
};		// ZNRES_SUB

// ZNRES_SUB field numbers (subscripts for ZNRES_SUB.sstat[] / sfirZNRES_SUB[])
#define ZNRES_SUB_Y 0
#define ZNRES_SUB_M 44
#define ZNRES_SUB_D 88
#define ZNRES_SUB_H 132
#define ZNRES_SUB_S 176

#define ZNRES_SUB_NFIELDS 220  					// excludes rec start ovh; is # sstat[] bytes.



/*--- ZNRES ---*/

// ZNRES record class
class ZNRES : public record 
{ public:
    ZNRES( basAnc *_b, TI i, SI noZ=0)  :  record( _b, i, noZ)  {} 
    virtual ~ZNRES() {} 
    ZNRES& Copy( const ZNRES& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    ZNRES& operator=( const ZNRES& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0) { record::Copy( pSrc, options); };

    ZNR* zr_GetZone() const;
    LI zr_GetRunTotalLI( int fn) const;
    void zr_InitPrior();
    void zr_InitCurr();
    ZNRES_SUB curr;
    ZNRES_SUB prior;
    unsigned char sstat[442];		// fld status bytes (base class excluded)
};		// ZNRES

// ZNRES field numbers (subscripts for ZNRES.sstat[] / sfirZNRES[])
#define ZNRES_NAME 0
#define ZNRES_OWNTI 1
#define ZNRES_CURR 2
#define ZNRES_PRIOR 222

#define ZNRES_NFIELDS 442  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirZNRES[];				// ZNRES small fields-in-record table (srfd.cpp)

#define  makAncZNRES(name)        anc<ZNRES> name( "znRes", sfirZNRES, ZNRES_NFIELDS, RTZNRES) 
#define  makAncZNRES2(name,what)  anc<ZNRES> name( what, sfirZNRES, ZNRES_NFIELDS, RTZNRES)	// 'what' override


/*--- ANDAT ---*/

// ANDAT record structure
struct ANDAT
 { 
    void ad_ClearResults();
    void ad_Setup( IZXRAT* pIZXRAT);
    void ad_SetupPresDep();
    RC ad_MassFlow( double delP);
    void ad_SetFromFixedAVF( double avf);
    void ad_DupHERV( const ANDAT& ad);
    IZXRATP ad_pIZXRAT;
    FLOAT ad_Ae;
    FLOAT ad_AeLin;
    DBL ad_delP;
    DBL ad_mdotP;
    DBL ad_dmdp;
    DBL ad_mdotB;
    DBL ad_mdotX;
    DBL ad_xDelpF;
    DBL ad_xMbm;
    DBL ad_tdFan;
    DBL ad_pFan;
};		// ANDAT

// ANDAT field numbers (subscripts for ANDAT.sstat[] / sfirANDAT[])
#define ANDAT_PIZXRAT 0
#define ANDAT_AE 1
#define ANDAT_AELIN 2
#define ANDAT_DELP 3
#define ANDAT_MDOTP 4
#define ANDAT_DMDP 5
#define ANDAT_MDOTB 6
#define ANDAT_MDOTX 7
#define ANDAT_XDELPF 8
#define ANDAT_XMBM 9
#define ANDAT_TDFAN 10
#define ANDAT_PFAN 11

#define ANDAT_NFIELDS 12  					// excludes rec start ovh; is # sstat[] bytes.



/*--- IZXRAT ---*/

// IZXRAT record class
class IZXRAT : public record 
{ public:
    IZXRAT( basAnc *_b, TI i, SI noZ=0);
    virtual ~IZXRAT() {} 
    IZXRAT& Copy( const IZXRAT& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    IZXRAT& operator=( const IZXRAT& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0) { record::Copy( pSrc, options); };

    void FixUp();
    RC Validate( int options=0);
    RC iz_CkfIZXFER();
    void iz_ClearResults( int iV);
    RC iz_Setup( IZXRAT* izie);
    void iz_AfMtrCats();
    void iz_SetupAfMtrs();
    RC iz_SetupNonAirNet();
    bool iz_HasVentEffect() const;
    bool iz_MightBeNatVent() const;
    RC iz_BegHour();
    RC iz_BegSubhr();
    void iz_SetupPresDep();
    void iz_GetZn2Conditions();
    void iz_ClearZn2Conditions();
    void iz_GetExteriorConditions( float windPresV);
    RC iz_SetupHERV();
    RC iz_Calc();
    RC iz_MassFlow( int iV);
    RC iz_ZoneXfers( int iV);
    RC iz_EndSubhr();
    BOOL iz_IsAirNet() const { return iz_nvcntrl > C_IZNVTYCH_TWOWAY; }
    BOOL iz_CanHaveAFCat() const { return iz_IsAirNet(); }
    BOOL iz_IsExterior() const { return iz_nvcntrl == C_IZNVTYCH_ANEXT || iz_nvcntrl == C_IZNVTYCH_ANEXTFAN || iz_nvcntrl == C_IZNVTYCH_ANEXTFLOW; }
    BOOL iz_IsAirNetIZ() const { return iz_nvcntrl == C_IZNVTYCH_ANIZ || iz_nvcntrl == C_IZNVTYCH_ANIZFAN || iz_nvcntrl == C_IZNVTYCH_ANIZFLOW || iz_nvcntrl == C_IZNVTYCH_ANHORIZ || iz_IsHERVIZ(); }
    BOOL iz_IsHERV() const { return iz_nvcntrl == C_IZNVTYCH_ANHERV; }
    BOOL iz_IsHERVIZ() const { return iz_IsHERV() && iz_zi2 != 0 && iz_zi1 != iz_zi2; }
    int iz_IsCZ( int iZn) const;
    BOOL iz_IsFan() const { return iz_nvcntrl == C_IZNVTYCH_ANIZFAN || iz_nvcntrl == C_IZNVTYCH_ANEXTFAN; }
    BOOL iz_HasFan() const { return iz_IsFan() || iz_IsHERV(); }
    BOOL iz_IsFlow() const { return iz_nvcntrl == C_IZNVTYCH_ANIZFLOW || iz_nvcntrl == C_IZNVTYCH_ANEXTFLOW; }
    BOOL iz_IsDuctLk() const { return iz_nvcntrl == C_IZNVTYCH_ANDUCTLK; }
    BOOL iz_IsSysAir() const { return iz_nvcntrl == C_IZNVTYCH_ANSYSAIR; }
    BOOL iz_IsSysOrDuct() const { return iz_IsDuctLk() || iz_IsSysAir(); }
    BOOL iz_IsOAVRelief() const { return iz_nvcntrl == C_IZNVTYCH_ANOAVRLF; }
    void iz_SetFromAF( const AIRFLOW* pAF);
    BOOL iz_IsFixedFlow() const { return iz_HasFan() || iz_IsFlow() || iz_IsDuctLk() || iz_IsSysAir(); }
    BOOL iz_IsIZ() const { return !iz_IsAirNet() || iz_IsAirNetIZ(); }
    void iz_SetFromMCp( double mCp, double mCpT=0.);
    static const double delPLinear;
    TI iz_zi1;
    TI iz_zi2;
    FLOAT iz_ua;
    IZNVTYCH iz_nvcntrl;
    AFCAT iz_afCatI;
    AFMTR* iz_pAfMtr1;
    AFMTR* iz_pAfMtr2;
    bool iz_doingAfMtr;
    SI iz_afMtrCat1;
    SI iz_afMtrCat2;
    FLOAT iz_a1;
    FLOAT iz_a2;
    FLOAT iz_L1;
    FLOAT iz_L2;
    FLOAT iz_hz;
    FLOAT iz_stairAngle;
    FLOAT iz_cd;
    FLOAT iz_exp;
    FLOAT iz_cpr;
    FLOAT iz_vfMin;
    FLOAT iz_vfMax;
    FLOAT iz_ASEF;
    FLOAT iz_LEF;
    FLOAT iz_SRE;
    FLOAT iz_ASRE;
    FLOAT iz_RVFanHeatF;
    FLOAT iz_vfExhRat;
    FLOAT iz_EATR;
    FAN iz_fan;
    const AIRFLOW* iz_pAF;
    FLOAT iz_nvcoeff;
    AIRSTATE iz_air1;
    AIRSTATE iz_air2;
    inline float iz_T( int i) { return i ? iz_air2.as_tdb : iz_air1.as_tdb; }
    FLOAT iz_rho1;
    FLOAT iz_rho2;
    inline float iz_Rho( int i) { return i ? iz_rho2 : iz_rho1; }
    FLOAT iz_pres2;
    ANDAT iz_ad[2];
    FLOAT iz_amfNom;
    unsigned char sstat[92];		// fld status bytes (base class excluded)
};		// IZXRAT

// IZXRAT field numbers (subscripts for IZXRAT.sstat[] / sfirIZXRAT[])
#define IZXRAT_NAME 0
#define IZXRAT_OWNTI 1
#define IZXRAT_ZI1 2
#define IZXRAT_ZI2 3
#define IZXRAT_UA 4
#define IZXRAT_NVCNTRL 5
#define IZXRAT_AFCATI 6
#define IZXRAT_AFMTRCAT1 7
#define IZXRAT_AFMTRCAT2 8
#define IZXRAT_A1 9
#define IZXRAT_A2 10
#define IZXRAT_L1 11
#define IZXRAT_L2 12
#define IZXRAT_HZ 13
#define IZXRAT_STAIRANGLE 14
#define IZXRAT_CD 15
#define IZXRAT_EXP 16
#define IZXRAT_CPR 17
#define IZXRAT_VFMIN 18
#define IZXRAT_VFMAX 19
#define IZXRAT_ASEF 20
#define IZXRAT_LEF 21
#define IZXRAT_SRE 22
#define IZXRAT_ASRE 23
#define IZXRAT_RVFANHEATF 24
#define IZXRAT_VFEXHRAT 25
#define IZXRAT_EATR 26
#define IZXRAT_FAN 27
#define IZXRAT_NVCOEFF 58
#define IZXRAT_AIR1 59
#define IZXRAT_AIR2 61
#define IZXRAT_RHO1 63
#define IZXRAT_RHO2 64
#define IZXRAT_PRES2 65
#define IZXRAT_AD 66
#define IZXRAT_AMFNOM 90

#define IZXRAT_NFIELDS 91  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirIZXRAT[];				// IZXRAT small fields-in-record table (srfd.cpp)

#define  makAncIZXRAT(name)        anc<IZXRAT> name( "izXfer", sfirIZXRAT, IZXRAT_NFIELDS, RTIZXRAT) 
#define  makAncIZXRAT2(name,what)  anc<IZXRAT> name( what, sfirIZXRAT, IZXRAT_NFIELDS, RTIZXRAT)	// 'what' override


/*--- AIRNET ---*/

// AIRNET record structure
struct AIRNET
 { 
    AIRNET();
    virtual ~AIRNET();
    RC an_Calc( int vMode);
    void an_ClearResults( int vMode);
    inline double& an_JAC(int i, int j) { return *(an_jac + i*an_nz + j); }
    DBLP an_jac;
    DBLP an_V1;
    DBLP an_V2;
    DBLP an_mdotAbs;
    INTP an_didLast;
    INT an_nz;
    INT an_resultsClear[2];
};		// AIRNET

// AIRNET field numbers (subscripts for AIRNET.sstat[] / sfirAIRNET[])
#define AIRNET_JAC 0
#define AIRNET_V1 1
#define AIRNET_V2 2
#define AIRNET_MDOTABS 3
#define AIRNET_DIDLAST 4
#define AIRNET_NZ 5
#define AIRNET_RESULTSCLEAR 6

#define AIRNET_NFIELDS 8  					// excludes rec start ovh; is # sstat[] bytes.



/*--- DBC ---*/

// DBC record structure
struct DBC : public SBCBASE
 { 
    void sb_Init( DUCTSEG* pDS);
    virtual double sb_AreaNet() const;
    virtual const char* sb_ParentName() const;
    virtual int sb_Class() const;
    void sb_SetRunConstants( ZNR* zpx);
    void sb_SetCoeffs( ZNR* zpx);
    DUCTSEGP sb_pDS;
};		// DBC

// DBC field numbers (subscripts for DBC.sstat[] / sfirDBC[])
#define DBC_ABSSLR 0
#define DBC_AWABSSLR 1
#define DBC_EPSLW 2
#define DBC_ZI 3
#define DBC_F 4
#define DBC_FP 5
#define DBC_FRRAD 6
#define DBC_FSKY 7
#define DBC_FAIR 8
#define DBC_HCNAT 9
#define DBC_HCFRC 10
#define DBC_HCMULT 11
#define DBC_HXA 12
#define DBC_HXR 13
#define DBC_HXTOT 14
#define DBC_URAT 15
#define DBC_FRAT 16
#define DBC_CX 17
#define DBC_SGTARG 18
#define DBC_SG 21
#define DBC_TSRF 22
#define DBC_TSRFLS 23
#define DBC_QRABS 24
#define DBC_TXA 25
#define DBC_TXR 26
#define DBC_TXE 27
#define DBC_W 28
#define DBC_QSRF 29
#define DBC_PDS 30

#define DBC_NFIELDS 31  					// excludes rec start ovh; is # sstat[] bytes.



/*--- DUCTSEG ---*/

// DUCTSEG record class
class DUCTSEG : public record 
{ public:
    DUCTSEG( basAnc *_b, TI i, SI noZ=0);
    virtual ~DUCTSEG(); 
    DUCTSEG& Copy( const DUCTSEG& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    DUCTSEG& operator=( const DUCTSEG& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0);

    void ds_Init( int options=0);
    ZNR* ds_GetExZone() const;
    RSYS* ds_GetRSYS() const;
    DUCTSEGRES* ds_GetDUCTSEGRES() const;
    RC ds_Ckf();
    bool ds_IsRound() const;
    RC ds_TopDS( const DUCTSEG* pDSi);
    void ds_SetRunConstants();
    RC ds_SetSizeFromAVF( float avf);
    double ds_InsulK( float T) const { return ds_insulKA + ds_insulKB * T; }
    int ds_IsSupply() const { return ds_ty == C_DUCTTYCH_SUP; }
    RC ds_BegHour();
    RC ds_BegSubhr();
    AIRSTATE ds_CalcFL( const AIRSTATE& as, double amf);
    AIRSTATE ds_CalcFLRev( const AIRSTATE& as);
    void ds_FinalizeSh( float runF);
    void ds_AfterSubhr();
    void ds_DbDump() const;
    DUCTTYCH ds_ty;
    DBC ds_sbcO;
    FLOAT ds_exArea;
    FLOAT ds_diam;
    FLOAT ds_len;
    FLOAT ds_branchLen;
    SI ds_branchCount;
    FLOAT ds_branchCFA;
    FLOAT ds_airVelDs;
    FLOAT ds_inArea;
    FLOAT ds_insulR;
    TI ds_insulMati;
    DBL ds_insulKA;
    DBL ds_insulKB;
    FLOAT ds_insulThk;
    FLOAT ds_insulThkEff;
    DBL ds_RconvIn;
    DBL ds_Rduct;
    DBL ds_Uduct;
    FLOAT ds_insulREff;
    EXCNDCH ds_exCnd;
    FLOAT ds_leakF;
    DBL ds_uaTot;
    FLOAT ds_beta;
    AIRSTATE ds_air[4];
    DBL ds_amfFL;
    DBL ds_qCondFL;
    DBL ds_qCond;
    DBL ds_qCondAir;
    DBL ds_qCondRad;
    DBL ds_qLeakSen;
    DBL ds_qLeakLat;
    unsigned char sstat[72];		// fld status bytes (base class excluded)
};		// DUCTSEG

// DUCTSEG field numbers (subscripts for DUCTSEG.sstat[] / sfirDUCTSEG[])
#define DUCTSEG_NAME 0
#define DUCTSEG_OWNTI 1
#define DUCTSEG_TY 2
#define DUCTSEG_SBCO 3
#define DUCTSEG_EXAREA 34
#define DUCTSEG_DIAM 35
#define DUCTSEG_LEN 36
#define DUCTSEG_BRANCHLEN 37
#define DUCTSEG_BRANCHCOUNT 38
#define DUCTSEG_BRANCHCFA 39
#define DUCTSEG_AIRVELDS 40
#define DUCTSEG_INAREA 41
#define DUCTSEG_INSULR 42
#define DUCTSEG_INSULMATI 43
#define DUCTSEG_INSULKA 44
#define DUCTSEG_INSULKB 45
#define DUCTSEG_INSULTHK 46
#define DUCTSEG_INSULTHKEFF 47
#define DUCTSEG_RCONVIN 48
#define DUCTSEG_RDUCT 49
#define DUCTSEG_UDUCT 50
#define DUCTSEG_INSULREFF 51
#define DUCTSEG_EXCND 52
#define DUCTSEG_LEAKF 53
#define DUCTSEG_UATOT 54
#define DUCTSEG_BETA 55
#define DUCTSEG_AIR 56
#define DUCTSEG_AMFFL 64
#define DUCTSEG_QCONDFL 65
#define DUCTSEG_QCOND 66
#define DUCTSEG_QCONDAIR 67
#define DUCTSEG_QCONDRAD 68
#define DUCTSEG_QLEAKSEN 69
#define DUCTSEG_QLEAKLAT 70

#define DUCTSEG_NFIELDS 71  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirDUCTSEG[];				// DUCTSEG small fields-in-record table (srfd.cpp)

#define  makAncDUCTSEG(name)        anc<DUCTSEG> name( "DuctSeg", sfirDUCTSEG, DUCTSEG_NFIELDS, RTDUCTSEG) 
#define  makAncDUCTSEG2(name,what)  anc<DUCTSEG> name( what, sfirDUCTSEG, DUCTSEG_NFIELDS, RTDUCTSEG)	// 'what' override


/*--- DUCTSEGRES_IVL_SUB ---*/

// DUCTSEGRES_IVL_SUB record structure
struct DUCTSEGRES_IVL_SUB
 { 
    void dsr_Clear() { memset(this, 0, sizeof(DUCTSEGRES_IVL_SUB)); }
    void dsr_Accum( const DUCTSEGRES_IVL_SUB* src, int firstFlg, int lastFlg);
    INT n;
    FLOAT qhCond;
    FLOAT qhLeakSen;
    FLOAT qhTotSen;
    FLOAT qcCond;
    FLOAT qcLeakSen;
    FLOAT qcTotSen;
    FLOAT qcLeakLat;
};		// DUCTSEGRES_IVL_SUB

// DUCTSEGRES_IVL_SUB field numbers (subscripts for DUCTSEGRES_IVL_SUB.sstat[] / sfirDUCTSEGRES_IVL_SUB[])
#define DUCTSEGRES_IVL_SUB_N 0
#define DUCTSEGRES_IVL_SUB_QHCOND 1
#define DUCTSEGRES_IVL_SUB_QHLEAKSEN 2
#define DUCTSEGRES_IVL_SUB_QHTOTSEN 3
#define DUCTSEGRES_IVL_SUB_QCCOND 4
#define DUCTSEGRES_IVL_SUB_QCLEAKSEN 5
#define DUCTSEGRES_IVL_SUB_QCTOTSEN 6
#define DUCTSEGRES_IVL_SUB_QCLEAKLAT 7

#define DUCTSEGRES_IVL_SUB_NFIELDS 8  					// excludes rec start ovh; is # sstat[] bytes.



/*--- DUCTSEGRES_SUB ---*/

// DUCTSEGRES_SUB record structure
struct DUCTSEGRES_SUB
 { 
    DUCTSEGRES_IVL_SUB Y;
    DUCTSEGRES_IVL_SUB M;
    DUCTSEGRES_IVL_SUB D;
    DUCTSEGRES_IVL_SUB H;
    DUCTSEGRES_IVL_SUB S;
};		// DUCTSEGRES_SUB

// DUCTSEGRES_SUB field numbers (subscripts for DUCTSEGRES_SUB.sstat[] / sfirDUCTSEGRES_SUB[])
#define DUCTSEGRES_SUB_Y 0
#define DUCTSEGRES_SUB_M 8
#define DUCTSEGRES_SUB_D 16
#define DUCTSEGRES_SUB_H 24
#define DUCTSEGRES_SUB_S 32

#define DUCTSEGRES_SUB_NFIELDS 40  					// excludes rec start ovh; is # sstat[] bytes.



/*--- DUCTSEGRES ---*/

// DUCTSEGRES record class
class DUCTSEGRES : public record 
{ public:
    DUCTSEGRES( basAnc *_b, TI i, SI noZ=0)  :  record( _b, i, noZ)  {} 
    virtual ~DUCTSEGRES() {} 
    DUCTSEGRES& Copy( const DUCTSEGRES& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    DUCTSEGRES& operator=( const DUCTSEGRES& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0) { record::Copy( pSrc, options); };

    DUCTSEGRES_SUB curr;
    unsigned char sstat[42];		// fld status bytes (base class excluded)
};		// DUCTSEGRES

// DUCTSEGRES field numbers (subscripts for DUCTSEGRES.sstat[] / sfirDUCTSEGRES[])
#define DUCTSEGRES_NAME 0
#define DUCTSEGRES_OWNTI 1
#define DUCTSEGRES_CURR 2

#define DUCTSEGRES_NFIELDS 42  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirDUCTSEGRES[];				// DUCTSEGRES small fields-in-record table (srfd.cpp)

#define  makAncDUCTSEGRES(name)        anc<DUCTSEGRES> name( "DUCTSEGRes", sfirDUCTSEGRES, DUCTSEGRES_NFIELDS, RTDUCTSEGRES) 
#define  makAncDUCTSEGRES2(name,what)  anc<DUCTSEGRES> name( what, sfirDUCTSEGRES, DUCTSEGRES_NFIELDS, RTDUCTSEGRES)	// 'what' override


/*--- RSYS ---*/

// RSYS record class
class RSYS : public record 
{ public:
    RSYS( basAnc *_b, TI i, SI noZ=0)  :  record( _b, i, noZ)  {} 
    virtual ~RSYS(); 
    RSYS& Copy( const RSYS& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    RSYS& operator=( const RSYS& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0);

    RC rs_CkF();
    RC rs_CkFCd( int mode);
    RC rs_CkFAuxHeat();
    RC rs_TopRSys1();
    RC rs_TopRSys2();
    int rs_IsZoneServed( const ZNR* zp) const { return zp->i.zn_rsi == ss; }
    RC rs_FazInit( int isAusz);
    RC rs_RddInit( int isAusz);
    void rs_RddiInit();
    RC rs_pass1AtoB();
    RC rs_begP1b();
    RC rs_endP1DsdIter( int auszMode);
    RC rs_endAutosize();
    void rs_AuszFinal();
    float rs_ClgCapNomTons( float nearest=-1.f);
    float rs_ClgCapForAMF( float amf) const;
    float rs_AMFForClgCap( float cap95) const;
    float rs_HtgCapForAMF( float amf) const;
    float rs_AMFForHtgCap( float capH) const;
    void rs_SetRunConstants();
    void rs_SetMTRPtrs();
    RC rs_SetupSizes( BOOL bAlways=TRUE);
    RC rs_SetupCapH( float avfH=-1.f, int options=0);
    void rs_SetupFanC( float avfC=-1.f);
    RC rs_SetupCapC( float avfC=-1.f, int options=0);
    RC rs_SetDuctSizes();
    void rs_SetModeAndClear( int rsModeNew, float speedF=1.f);
    void rs_ClearSubhrResults( int options=0);
    RC rs_BegHour();
    RC rs_BegSubhr();
    RC rs_EndSubhr();
    RC rs_AfterSubhr();
    RC rs_AfterHour();
    void rs_EnteringAirState();
    int rs_IsModeAvailable( int rsMode);
    int rs_IsAutoSizing() const;
    int rs_SupplyAirState( int rsMode, float speedF=1.f);
    bool rs_IsSupplyAirTempUseful( int rsMode, float tSup, float& tSupUseful) const;
    float rs_SupplyDSEAndDucts(AIRSTATE& as, float amf = -1.f);
    void rs_SupplyDSEAndDuctsRev( AIRSTATE& as);
    float rs_TSupVarFlow( float fAmf, AIRSTATE& as);
    double rs_ZoneAirRequest( double znAmfSup, int iAux=0);
    RC rs_AllocateZoneAir();
    RC rs_TotalAirRequestForSpeedF( float speedF, int options=0);
    double rs_FxCapForSpeedF( double& speedF);
    RC rs_FindRequiredSpeedF();
    RC rs_FindSpeedFForTSup( double tSup);
    double rs_TSupForSpeedF( double& speedF);
    double rs_AmfRequired( double tSup);
    float rs_ACReqCap95( float senLoad);
    RC rs_FinalizeSh();
    float rs_FanHRtdPerTon( float capNomTons);
    void rs_ACFactors();
    void rs_Cooling( int auszMode=rsmOFF);
    void rs_CoolingSHR();
    void rs_CoolingEff1Spd();
    void rs_CoolingCapF1Spd();
    void rs_GetPerfClg( float& capTot, float& capSen, float& pwrIn) const;
    RC rs_PerfMapAC();
    RC rs_PerfDataASHP();
    void rs_PerfDataASHP1( FILE* f,	float tDbOut);
    float rs_PerfASHP( int ashpModel, float tDbOut, float& COP, float fanHAdj=0.f);
    float rs_PerfASHP2( int ashpModel, float tDbOut, float fanHAdj, float& capHt, float& inpHt, float& capDfHt, float& capHtMin, float& inpHtMin, float& capDfHtMin, float COPAdjF=1.f);
    int rs_IsASHP() const { return rs_type == C_RSYSTYCH_ASHP || rs_type == C_RSYSTYCH_ASHPPKGRM || rs_IsASHPHydronic() || rs_IsASHPVC(); }
    int rs_IsASHPHydronic() const { return rs_type == C_RSYSTYCH_ASHPHYD; }
    bool rs_IsVCHtg() const { return rs_IsASHPVC(); }
    bool rs_IsVCClg() const { return rs_IsASHPVC(); }
    bool rs_IsVC() const { return rs_IsASHPVC(); }
    bool rs_IsASHPVC() const { return rs_type == C_RSYSTYCH_ASHPVC; }
    bool rs_IsElecHeat() const { return rs_IsASHP() || rs_type==C_RSYSTYCH_ACRES || rs_type==C_RSYSTYCH_ACPKGRMRES || rs_type==C_RSYSTYCH_RES; }
    bool rs_IsFuelAuxH() const { return rs_typeAuxH == C_AUXHEATTY_FURN; }
    bool rs_IsPkgRoom() const { return rs_IsASHPPkgRoom() || rs_IsACPkgRoom(); }
    bool rs_IsASHPPkgRoom() const { return rs_type==C_RSYSTYCH_ASHPPKGRM; }
    bool rs_IsACPkgRoom() const { return rs_type==C_RSYSTYCH_ACPKGRM || rs_type==C_RSYSTYCH_ACPKGRMFURN || rs_type==C_RSYSTYCH_ACPKGRMRES; }
    bool rs_HasDefrost() const { return rs_IsASHP() && !rs_IsASHPPkgRoom() && rs_defrostModel != C_RSYSDEFROSTMODELCH_NONE; }
    bool rs_CanHeat() const { return rs_type != C_RSYSTYCH_AC && rs_type != C_RSYSTYCH_ACPKGRM; }
    bool rs_CanCool() const { return rs_type != C_RSYSTYCH_FURN && rs_type != C_RSYSTYCH_RES; }
    bool rs_CanOAV() const { return rs_OAVType != C_RSYSOAVTYCH_NONE; }
    bool rs_CanHaveAuxHeat() const { return rs_IsASHP(); }
    ZNR* rs_GetOAVReliefZn() const;
    void rs_OAVSetup();
    void rs_OAVAirFlow();
    int rs_OAVAttempt();
    static double rs_CallCalcHSPF( void* pO, double &cop17);
    RC rs_HSPFMatchASHP();
    float rs_HSPFCheckASHP( int options=0);
    static float rs_DHR( float capHt);
    RC rs_SetupASHP();
    RC rs_SetRunConstantsASHP();
    float rs_CapRat1747() const;
    float rs_CapRat0547() const;
    float rs_Cap35Default( float cap47, float cap17) const;
    float rs_Inp35Default( float inp47, float inp17) const;
    float rs_Cap05Default( float cap47, float cap17) const;
    float rs_CapHtCurSpeedF() const;
    float rs_CapDfHtCurSpeedF() const;
    float rs_InpHtCurSpeedF() const;
    float rs_Cap115Default( float cap95, float cap82) const;
    float rs_Inp115Default( float inp95, float inp82) const;
    RC rs_SetDefaultsClg();
    RC rs_SetupBtwxtClg();
    RC rs_SetupBtwxt( class Btwxt::RegularGridInterpolator* &pRgi, const std::vector<struct VSPERFP> ppV);
    RC rs_GetPerfBtwxt( class Btwxt::RegularGridInterpolator* pRgi, float tdbOut, float& cap, float& inp, float& capMin, float& inpMin);
    void rs_AuszFinalASHP();
    float rs_CapEffASHP( float tdbout=-999.f, int ashpModel=0, float fanHRtd=-1.f, float fanHOpr=-1.f, float COPAdjF=-1.f);
    float rs_CapEffASHP2();
    static double rs_CallCalcCapHt( void* pO, double &cop17);
    double rs_CapHtForCap47( float cap47);
    RC rs_SizeASHP( float dsnLoad, float tdbOut);
    void rs_DefaultCapNomsIf();
    enum { rsmOFF, rsmHEAT, rsmCOOL, rsmOAV, rsmCOUNT };
    float rs_Cap47FromCap95ASHP( float cap95) const;
    float rs_Cap95FromCap47ASHP( float cap47) const;
    RSYSTYCH rs_type;
    CHP rs_desc;
    NOYESCH rs_perfMap;
    DBL rs_areaServed;
    INT rs_zonesServed;
    TI rs_elecMtri;
    TI rs_fuelMtri;
    MTR* rs_pMtrElec; MTR* rs_pMtrFuel; MTR* rs_pMtrHeat; MTR* rs_pMtrAux;
    FLOAT rs_parElec;
    FLOAT rs_parFuel;
    FLOAT rs_capNomH;
    FLOAT rs_capNomC;
    FAN rs_fan;
    NOYESCH rs_adjForFanHt;
    AIRSTATE rs_asRet;
    AIRSTATE rs_asIn;
    DBL rs_twbIn;
    AIRSTATE rs_asOut;
    AIRSTATE rs_asOutAux;
    AIRSTATE rs_asSup;
    AIRSTATE rs_asSupAux;
    FLOAT rs_tSupLs;
    FLOAT rs_DSEH;
    FLOAT rs_DSEC;
    INT rs_isAuszH;
    INT rs_isAuszC;
    FLOAT rs_tdDesH;
    FLOAT rs_tdDesC;
    FLOAT rs_fxCap[2];
    FLOAT rs_fxCapCDay;
    FLOAT rs_fxCapHDay;
    FLOAT rs_fxCapHTarg;
    FLOAT rs_fxCapHAsF;
    FLOAT rs_fxCapCTarg;
    FLOAT rs_fxCapCAsF;
    FLOAT rs_fxCapAuxHTarg;
    AUSZ rs_auszH;
    AUSZ rs_auszC;
    FLOAT rs_HSPF;
    FLOAT rs_cap47;
    FLOAT rs_COP47;
    FLOAT rs_cap35;
    FLOAT rs_COP35;
    FLOAT rs_cap17;
    FLOAT rs_COP17;
    FLOAT rs_cap05;
    FLOAT rs_COP05;
    FLOAT rs_capRat1747;
    FLOAT rs_capRat0547;
    FLOAT rs_capRat9547;
    FLOAT rs_loadFMin47;
    FLOAT rs_loadFMin17;
    FLOAT rs_loadFMin05;
    float rs_CapMin47() const { return rs_cap47*rs_loadFMin47; }
    float rs_CapMin17() const { return rs_cap17*rs_loadFMin17; }
    float rs_CapMin05() const { return rs_cap05*rs_loadFMin05; }
    FLOAT rs_COPMin47;
    FLOAT rs_COPMin35;
    FLOAT rs_COPMin17;
    FLOAT rs_COPMin05;
    FLOAT rs_CdH;
    FLOAT rs_inp47;
    FLOAT rs_inp35;
    FLOAT rs_inp17;
    FLOAT rs_inp05;
    FLOAT rs_ASHPCapF[2];
    FLOAT rs_ASHPInpF[2];
    class Btwxt::RegularGridInterpolator* rs_pRgiHtg[ 2];
    AUXHEATTY rs_typeAuxH;
    AUXHEATCTRL rs_ctrlAuxH;
    FLOAT rs_capAuxH;
    FLOAT rs_capAuxHInp;
    FLOAT rs_AFUEAuxH;
    FLOAT rs_effAuxH;
    INT rs_underSizedAuxCount;
    FLOAT rs_ASHPLockOutT;
    RSYSDEFROSTMODELCH rs_defrostModel;
    FLOAT rs_AFUE;
    FLOAT rs_capH;
    FLOAT rs_capH_As;
    FLOAT rs_capH_AsNov;
    FLOAT rs_fanHRtdH;
    FLOAT rs_fanPwrH;
    FLOAT rs_fanHeatH;
    FLOAT rs_amfH;
    FLOAT rs_effHt;
    FLOAT rs_capHt;
    FLOAT rs_inpHt;
    FLOAT rs_capDfHt;
    FLOAT rs_capHtMin;
    FLOAT rs_inpHtMin;
    FLOAT rs_capDfHtMin;
    FLOAT rs_COPHtAdj;
    FLOAT rs_cap95;
    FLOAT rs_cap95_As;
    FLOAT rs_cap95_AsNov;
    FLOAT rs_COP95;
    FLOAT rs_EER95;
    FLOAT rs_SEER;
    FLOAT rs_cap115;
    FLOAT rs_COP115;
    FLOAT rs_capRat11595;
    FLOAT rs_cap82;
    FLOAT rs_COP82;
    FLOAT rs_capRat8295;
    FLOAT rs_loadFMin115;
    FLOAT rs_loadFMin95;
    FLOAT rs_loadFMin82;
    float rs_CapMin115() const { return rs_cap115*rs_loadFMin115; }
    float rs_CapMin95() const { return rs_cap95*rs_loadFMin95; }
    float rs_CapMin82() const { return rs_cap82*rs_loadFMin82; }
    FLOAT rs_COPMin115;
    FLOAT rs_COPMin95;
    FLOAT rs_COPMin82;
    class Btwxt::RegularGridInterpolator* rs_pRgiClg;
    FLOAT rs_vfPerTon;
    FLOAT rs_fanPwrC;
    FLOAT rs_fanHeatC;
    FLOAT rs_fanDeltaTC;
    FLOAT rs_amfC;
    FLOAT rs_CdC;
    FLOAT rs_rhInTest;
    FLOAT rs_rhIn;
    FLOAT rs_twbCoilIn;
    FLOAT rs_tdbCoilIn;
    INT rs_wetCoil;
    FLOAT rs_SHR;
    FLOAT rs_fChg;
    FLOAT rs_fSize;
    FLOAT rs_fanHRtdC;
    FLOAT rs_capnfX;
    FLOAT rs_capAdjF;
    FLOAT rs_SEERnfX;
    FLOAT rs_EERnfX;
    FLOAT rs_fCondCap;
    FLOAT rs_fCondSEER;
    FLOAT rs_fCondEER;
    FLOAT rs_SEERnf;
    FLOAT rs_EERnf;
    FLOAT rs_EERt;
    FLOAT rs_effCt;
    FLOAT rs_capTotCt;
    FLOAT rs_capLatCt;
    FLOAT rs_capSenCt;
    RSYSOAVTYCH rs_OAVType;
    TI rs_OAVReliefZi;
    FLOAT rs_OAVTdbInlet;
    FLOAT rs_OAVTdiff;
    FLOAT rs_OAVAvfDs;
    FLOAT rs_OAVFanPwr;
    FLOAT rs_OAVAvfMinF;
    FLOAT rs_avfOAV;
    FLOAT rs_fanHeatOAV;
    FLOAT rs_amfOAV;
    struct
    { TI dsi[ 2];
      FLOAT ductLkXF[ 2];
    } rs_ducts[ 2];
    int rs_CanHaveDucts( int iHC) const;
    int rs_DsHC() const { return rs_mode > rsmHEAT; }
    int rs_Dsi( int iSR, int iHC=-1) const { if (iHC<0) iHC=rs_DsHC(); return rs_ducts[ iHC].dsi[ iSR]; }
    FLOAT rs_fEffH;
    FLOAT rs_fEffC;
    FLOAT rs_tdbOut;
    RSYSMODECTRLCH rs_modeCtrl;
    INT rs_mode;
    INT rs_modeLs;
    INT rs_modeLastActive;
    DBL rs_amfReq[2];
    FLOAT rs_znLoad[2];
    FLOAT rs_capSenNetFS;
    DBL rs_amf;
    FLOAT rs_PLF;
    FLOAT rs_PLR;
    FLOAT rs_loadF;
    FLOAT rs_loadFLs;
    FLOAT rs_runF;
    FLOAT rs_speedF;
    FLOAT rs_speedFMin;
    FLOAT rs_runFAux;
    DBL rs_outSen;
    DBL rs_outLat;
    DBL rs_outFan;
    DBL rs_outDefrost;
    DBL rs_outAux;
    DBL rs_outSenTot;
    LI rs_calcCount[2];
    DBL rs_inPrimary;
    DBL rs_inFan;
    DBL rs_inDefrost;
    DBL rs_inAux;
    unsigned char sstat[250];		// fld status bytes (base class excluded)
};		// RSYS

// RSYS field numbers (subscripts for RSYS.sstat[] / sfirRSYS[])
#define RSYS_NAME 0
#define RSYS_OWNTI 1
#define RSYS_TYPE 2
#define RSYS_DESC 3
#define RSYS_PERFMAP 4
#define RSYS_AREASERVED 5
#define RSYS_ZONESSERVED 6
#define RSYS_ELECMTRI 7
#define RSYS_FUELMTRI 8
#define RSYS_PARELEC 9
#define RSYS_PARFUEL 10
#define RSYS_CAPNOMH 11
#define RSYS_CAPNOMC 12
#define RSYS_FAN 13
#define RSYS_ADJFORFANHT 44
#define RSYS_ASRET 45
#define RSYS_ASIN 47
#define RSYS_TWBIN 49
#define RSYS_ASOUT 50
#define RSYS_ASOUTAUX 52
#define RSYS_ASSUP 54
#define RSYS_ASSUPAUX 56
#define RSYS_TSUPLS 58
#define RSYS_DSEH 59
#define RSYS_DSEC 60
#define RSYS_ISAUSZH 61
#define RSYS_ISAUSZC 62
#define RSYS_TDDESH 63
#define RSYS_TDDESC 64
#define RSYS_FXCAP 65
#define RSYS_FXCAPCDAY 67
#define RSYS_FXCAPHDAY 68
#define RSYS_FXCAPHTARG 69
#define RSYS_FXCAPHASF 70
#define RSYS_FXCAPCTARG 71
#define RSYS_FXCAPCASF 72
#define RSYS_FXCAPAUXHTARG 73
#define RSYS_AUSZH 74
#define RSYS_AUSZC 90
#define RSYS_HSPF 106
#define RSYS_CAP47 107
#define RSYS_COP47 108
#define RSYS_CAP35 109
#define RSYS_COP35 110
#define RSYS_CAP17 111
#define RSYS_COP17 112
#define RSYS_CAP05 113
#define RSYS_COP05 114
#define RSYS_CAPRAT1747 115
#define RSYS_CAPRAT0547 116
#define RSYS_CAPRAT9547 117
#define RSYS_LOADFMIN47 118
#define RSYS_LOADFMIN17 119
#define RSYS_LOADFMIN05 120
#define RSYS_COPMIN47 121
#define RSYS_COPMIN35 122
#define RSYS_COPMIN17 123
#define RSYS_COPMIN05 124
#define RSYS_CDH 125
#define RSYS_INP47 126
#define RSYS_INP35 127
#define RSYS_INP17 128
#define RSYS_INP05 129
#define RSYS_ASHPCAPF 130
#define RSYS_ASHPINPF 132
#define RSYS_TYPEAUXH 134
#define RSYS_CTRLAUXH 135
#define RSYS_CAPAUXH 136
#define RSYS_CAPAUXHINP 137
#define RSYS_AFUEAUXH 138
#define RSYS_EFFAUXH 139
#define RSYS_UNDERSIZEDAUXCOUNT 140
#define RSYS_ASHPLOCKOUTT 141
#define RSYS_DEFROSTMODEL 142
#define RSYS_AFUE 143
#define RSYS_CAPH 144
#define RSYS_CAPH_AS 145
#define RSYS_CAPH_ASNOV 146
#define RSYS_FANHRTDH 147
#define RSYS_FANPWRH 148
#define RSYS_FANHEATH 149
#define RSYS_AMFH 150
#define RSYS_EFFHT 151
#define RSYS_CAPHT 152
#define RSYS_INPHT 153
#define RSYS_CAPDFHT 154
#define RSYS_CAPHTMIN 155
#define RSYS_INPHTMIN 156
#define RSYS_CAPDFHTMIN 157
#define RSYS_COPHTADJ 158
#define RSYS_CAP95 159
#define RSYS_CAP95_AS 160
#define RSYS_CAP95_ASNOV 161
#define RSYS_COP95 162
#define RSYS_EER95 163
#define RSYS_SEER 164
#define RSYS_CAP115 165
#define RSYS_COP115 166
#define RSYS_CAPRAT11595 167
#define RSYS_CAP82 168
#define RSYS_COP82 169
#define RSYS_CAPRAT8295 170
#define RSYS_LOADFMIN115 171
#define RSYS_LOADFMIN95 172
#define RSYS_LOADFMIN82 173
#define RSYS_COPMIN115 174
#define RSYS_COPMIN95 175
#define RSYS_COPMIN82 176
#define RSYS_VFPERTON 177
#define RSYS_FANPWRC 178
#define RSYS_FANHEATC 179
#define RSYS_FANDELTATC 180
#define RSYS_AMFC 181
#define RSYS_CDC 182
#define RSYS_RHINTEST 183
#define RSYS_RHIN 184
#define RSYS_TWBCOILIN 185
#define RSYS_TDBCOILIN 186
#define RSYS_WETCOIL 187
#define RSYS_SHR 188
#define RSYS_FCHG 189
#define RSYS_FSIZE 190
#define RSYS_FANHRTDC 191
#define RSYS_CAPNFX 192
#define RSYS_CAPADJF 193
#define RSYS_SEERNFX 194
#define RSYS_EERNFX 195
#define RSYS_FCONDCAP 196
#define RSYS_FCONDSEER 197
#define RSYS_FCONDEER 198
#define RSYS_SEERNF 199
#define RSYS_EERNF 200
#define RSYS_EERT 201
#define RSYS_EFFCT 202
#define RSYS_CAPTOTCT 203
#define RSYS_CAPLATCT 204
#define RSYS_CAPSENCT 205
#define RSYS_OAVTYPE 206
#define RSYS_OAVRELIEFZI 207
#define RSYS_OAVTDBINLET 208
#define RSYS_OAVTDIFF 209
#define RSYS_OAVAVFDS 210
#define RSYS_OAVFANPWR 211
#define RSYS_OAVAVFMINF 212
#define RSYS_AVFOAV 213
#define RSYS_FANHEATOAV 214
#define RSYS_AMFOAV 215
#define RSYS_FEFFH 216
#define RSYS_FEFFC 217
#define RSYS_TDBOUT 218
#define RSYS_MODECTRL 219
#define RSYS_MODE 220
#define RSYS_MODELS 221
#define RSYS_MODELASTACTIVE 222
#define RSYS_AMFREQ 223
#define RSYS_ZNLOAD 225
#define RSYS_CAPSENNETFS 227
#define RSYS_AMF 228
#define RSYS_PLF 229
#define RSYS_PLR 230
#define RSYS_LOADF 231
#define RSYS_LOADFLS 232
#define RSYS_RUNF 233
#define RSYS_SPEEDF 234
#define RSYS_SPEEDFMIN 235
#define RSYS_RUNFAUX 236
#define RSYS_OUTSEN 237
#define RSYS_OUTLAT 238
#define RSYS_OUTFAN 239
#define RSYS_OUTDEFROST 240
#define RSYS_OUTAUX 241
#define RSYS_OUTSENTOT 242
#define RSYS_CALCCOUNT 243
#define RSYS_INPRIMARY 245
#define RSYS_INFAN 246
#define RSYS_INDEFROST 247
#define RSYS_INAUX 248

#define RSYS_NFIELDS 249  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirRSYS[];				// RSYS small fields-in-record table (srfd.cpp)

#define  makAncRSYS(name)        anc<RSYS> name( "RSYS", sfirRSYS, RSYS_NFIELDS, RTRSYS) 
#define  makAncRSYS2(name,what)  anc<RSYS> name( what, sfirRSYS, RSYS_NFIELDS, RTRSYS)	// 'what' override


/*--- RSYSRES_IVL_SUB ---*/

// RSYSRES_IVL_SUB record structure
struct RSYSRES_IVL_SUB
 { 
    void rsr_Accum( const RSYSRES_IVL_SUB* src, int firstFlg, int lastFlg);
    void rsr_SetPrior() const;
    void rsr_Zero() { memset( this, 0, sizeof( RSYSRES_IVL_SUB)); }
    INT n;
    FLOAT hrsOn;
    FLOAT hrsOnAux;
    FLOAT qhPrimary;
    FLOAT qhDefrost;
    FLOAT qhAux;
    FLOAT qhFan;
    FLOAT qhNet;
    FLOAT qcSen;
    FLOAT qcLat;
    FLOAT qcFan;
    FLOAT qcSenNet;
    FLOAT qvFan;
    FLOAT fhPrimary;
    FLOAT fhDefrost;
    FLOAT fhAux;
    FLOAT fhParasitic;
    FLOAT fhTot;
    FLOAT ehPrimary;
    FLOAT ehDefrost;
    FLOAT ehAux;
    FLOAT ehFan;
    FLOAT ehParasitic;
    FLOAT ehTot;
    FLOAT ecPrimary;
    FLOAT ecFan;
    FLOAT ecParasitic;
    FLOAT ecTot;
    FLOAT evFan;
    FLOAT evParasitic;
    FLOAT evTot;
    FLOAT qhZoneSen;
    FLOAT qhZoneLat;
    FLOAT qcZoneSen;
    FLOAT qcZoneLat;
    FLOAT qvZoneSen;
    FLOAT qvZoneLat;
};		// RSYSRES_IVL_SUB

// RSYSRES_IVL_SUB field numbers (subscripts for RSYSRES_IVL_SUB.sstat[] / sfirRSYSRES_IVL_SUB[])
#define RSYSRES_IVL_SUB_N 0
#define RSYSRES_IVL_SUB_HRSON 1
#define RSYSRES_IVL_SUB_HRSONAUX 2
#define RSYSRES_IVL_SUB_QHPRIMARY 3
#define RSYSRES_IVL_SUB_QHDEFROST 4
#define RSYSRES_IVL_SUB_QHAUX 5
#define RSYSRES_IVL_SUB_QHFAN 6
#define RSYSRES_IVL_SUB_QHNET 7
#define RSYSRES_IVL_SUB_QCSEN 8
#define RSYSRES_IVL_SUB_QCLAT 9
#define RSYSRES_IVL_SUB_QCFAN 10
#define RSYSRES_IVL_SUB_QCSENNET 11
#define RSYSRES_IVL_SUB_QVFAN 12
#define RSYSRES_IVL_SUB_FHPRIMARY 13
#define RSYSRES_IVL_SUB_FHDEFROST 14
#define RSYSRES_IVL_SUB_FHAUX 15
#define RSYSRES_IVL_SUB_FHPARASITIC 16
#define RSYSRES_IVL_SUB_FHTOT 17
#define RSYSRES_IVL_SUB_EHPRIMARY 18
#define RSYSRES_IVL_SUB_EHDEFROST 19
#define RSYSRES_IVL_SUB_EHAUX 20
#define RSYSRES_IVL_SUB_EHFAN 21
#define RSYSRES_IVL_SUB_EHPARASITIC 22
#define RSYSRES_IVL_SUB_EHTOT 23
#define RSYSRES_IVL_SUB_ECPRIMARY 24
#define RSYSRES_IVL_SUB_ECFAN 25
#define RSYSRES_IVL_SUB_ECPARASITIC 26
#define RSYSRES_IVL_SUB_ECTOT 27
#define RSYSRES_IVL_SUB_EVFAN 28
#define RSYSRES_IVL_SUB_EVPARASITIC 29
#define RSYSRES_IVL_SUB_EVTOT 30
#define RSYSRES_IVL_SUB_QHZONESEN 31
#define RSYSRES_IVL_SUB_QHZONELAT 32
#define RSYSRES_IVL_SUB_QCZONESEN 33
#define RSYSRES_IVL_SUB_QCZONELAT 34
#define RSYSRES_IVL_SUB_QVZONESEN 35
#define RSYSRES_IVL_SUB_QVZONELAT 36

#define RSYSRES_IVL_SUB_NFIELDS 37  					// excludes rec start ovh; is # sstat[] bytes.



/*--- RSYSRES_SUB ---*/

// RSYSRES_SUB record structure
struct RSYSRES_SUB
 { 
    RSYSRES_IVL_SUB Y;
    RSYSRES_IVL_SUB M;
    RSYSRES_IVL_SUB D;
    RSYSRES_IVL_SUB H;
    RSYSRES_IVL_SUB S;
};		// RSYSRES_SUB

// RSYSRES_SUB field numbers (subscripts for RSYSRES_SUB.sstat[] / sfirRSYSRES_SUB[])
#define RSYSRES_SUB_Y 0
#define RSYSRES_SUB_M 37
#define RSYSRES_SUB_D 74
#define RSYSRES_SUB_H 111
#define RSYSRES_SUB_S 148

#define RSYSRES_SUB_NFIELDS 185  					// excludes rec start ovh; is # sstat[] bytes.



/*--- RSYSRES ---*/

// RSYSRES record class
class RSYSRES : public record 
{ public:
    RSYSRES( basAnc *_b, TI i, SI noZ=0)  :  record( _b, i, noZ)  {} 
    virtual ~RSYSRES() {} 
    RSYSRES& Copy( const RSYSRES& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    RSYSRES& operator=( const RSYSRES& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0) { record::Copy( pSrc, options); };

    RSYSRES_SUB curr;
    RSYSRES_SUB prior;
    unsigned char sstat[372];		// fld status bytes (base class excluded)
};		// RSYSRES

// RSYSRES field numbers (subscripts for RSYSRES.sstat[] / sfirRSYSRES[])
#define RSYSRES_NAME 0
#define RSYSRES_OWNTI 1
#define RSYSRES_CURR 2
#define RSYSRES_PRIOR 187

#define RSYSRES_NFIELDS 372  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirRSYSRES[];				// RSYSRES small fields-in-record table (srfd.cpp)

#define  makAncRSYSRES(name)        anc<RSYSRES> name( "RSYSRes", sfirRSYSRES, RSYSRES_NFIELDS, RTRSYSRES) 
#define  makAncRSYSRES2(name,what)  anc<RSYSRES> name( what, sfirRSYSRES, RSYSRES_NFIELDS, RTRSYSRES)	// 'what' override


/*--- AFMTR_IVL ---*/

// AFMTR_IVL record structure
struct AFMTR_IVL
 { 
    void amt_Clear() { memset( this, 0, sizeof( AFMTR_IVL));}
    void amt_Copy( const AFMTR_IVL* sIvl, float mult=1.f);
    void amt_AccumCat( AFCAT cat, FLOAT v) { (&amt_unknown)[ cat] += v; amt_total += v; }
    void amt_Accum( const AFMTR_IVL* sIvl, int firstFlg, int lastFlg, int options=0);
    static const int NAFCATS;
    INT amt_count;
    FLOAT amt_total;
    FLOAT amt_unknown;
    FLOAT amt_infEx;
    FLOAT amt_vntEx;
    FLOAT amt_fanEx;
    FLOAT amt_infUz;
    FLOAT amt_vntUz;
    FLOAT amt_fanUz;
    FLOAT amt_infCz;
    FLOAT amt_vntCz;
    FLOAT amt_fanCz;
    FLOAT amt_ductLk;
    FLOAT amt_hvac;
};		// AFMTR_IVL

// AFMTR_IVL field numbers (subscripts for AFMTR_IVL.sstat[] / sfirAFMTR_IVL[])
#define AFMTR_IVL_COUNT 0
#define AFMTR_IVL_TOTAL 1
#define AFMTR_IVL_UNKNOWN 2
#define AFMTR_IVL_INFEX 3
#define AFMTR_IVL_VNTEX 4
#define AFMTR_IVL_FANEX 5
#define AFMTR_IVL_INFUZ 6
#define AFMTR_IVL_VNTUZ 7
#define AFMTR_IVL_FANUZ 8
#define AFMTR_IVL_INFCZ 9
#define AFMTR_IVL_VNTCZ 10
#define AFMTR_IVL_FANCZ 11
#define AFMTR_IVL_DUCTLK 12
#define AFMTR_IVL_HVAC 13

#define AFMTR_IVL_NFIELDS 14  					// excludes rec start ovh; is # sstat[] bytes.



/*--- AFMTR ---*/

// AFMTR record class
class AFMTR : public record 
{ public:
    AFMTR( basAnc *_b, TI i, SI noZ=0)  :  record( _b, i, noZ)  {} 
    virtual ~AFMTR() {} 
    AFMTR& Copy( const AFMTR& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    AFMTR& operator=( const AFMTR& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0) { record::Copy( pSrc, options); };

    RC amt_CkF();
    bool amt_IsSumOf() const { return ss == b->n; }
    RC amt_BegSubhr();
    void amt_AccumCat( AFCAT afCat, float amf);
    void amt_Accum( IVLCH ivl, int firstflg, int lastFlg);
    AFMTR_IVL* amt_GetAFMTR_IVL( IVLCH ivl, int iPN=0);
    AFMTR_IVL Y[2];
    AFMTR_IVL M[2];
    AFMTR_IVL D[2];
    AFMTR_IVL H[2];
    AFMTR_IVL S[2];
    unsigned char sstat[142];		// fld status bytes (base class excluded)
};		// AFMTR

// AFMTR field numbers (subscripts for AFMTR.sstat[] / sfirAFMTR[])
#define AFMTR_NAME 0
#define AFMTR_OWNTI 1
#define AFMTR_Y 2
#define AFMTR_M 30
#define AFMTR_D 58
#define AFMTR_H 86
#define AFMTR_S 114

#define AFMTR_NFIELDS 142  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirAFMTR[];				// AFMTR small fields-in-record table (srfd.cpp)

#define  makAncAFMTR(name)        anc<AFMTR> name( "AFMETER", sfirAFMTR, AFMTR_NFIELDS, RTAFMTR) 
#define  makAncAFMTR2(name,what)  anc<AFMTR> name( what, sfirAFMTR, AFMTR_NFIELDS, RTAFMTR)	// 'what' override


/*--- DHWMTR_IVL ---*/

// DHWMTR_IVL record structure
struct DHWMTR_IVL
 { 
    void wmt_Clear() { memset( this, 0, sizeof( DHWMTR_IVL));}
    void wmt_Copy( const DHWMTR_IVL* s, float mult=1.f);
    float wmt_GetByEUX( DHWEUXCH eux) { return (&total)[ eux-1]; };
    void wmt_AccumEU( DHWEUCH eu, FLOAT v) { (&unknown)[ eu] += v; total += v; }
    void wmt_Accum( const DHWMTR_IVL* sIvl, int options=0, float mult=1.f);
    void wmt_AccumTo( double* useTots) const { VAccum( useTots, NDHWENDUSES+1, &total); }
    void wmt_SetPrior() const;
    FLOAT total;
    FLOAT unknown;
    FLOAT faucet;
    FLOAT shower;
    FLOAT bath;
    FLOAT cwashr;
    FLOAT dwashr;
};		// DHWMTR_IVL

// DHWMTR_IVL field numbers (subscripts for DHWMTR_IVL.sstat[] / sfirDHWMTR_IVL[])
#define DHWMTR_IVL_TOTAL 0
#define DHWMTR_IVL_UNKNOWN 1
#define DHWMTR_IVL_FAUCET 2
#define DHWMTR_IVL_SHOWER 3
#define DHWMTR_IVL_BATH 4
#define DHWMTR_IVL_CWASHR 5
#define DHWMTR_IVL_DWASHR 6

#define DHWMTR_IVL_NFIELDS 7  					// excludes rec start ovh; is # sstat[] bytes.



/*--- DHWMTR_SUB ---*/

// DHWMTR_SUB record structure
struct DHWMTR_SUB
 { 
    RC wmt_CkF();
    RC wmt_Init( IVLCH ivl);
    void wmt_Accum( IVLCH ivl, int firstflg);
    DHWMTR_IVL Y;
    DHWMTR_IVL M;
    DHWMTR_IVL D;
    DHWMTR_IVL H;
};		// DHWMTR_SUB

// DHWMTR_SUB field numbers (subscripts for DHWMTR_SUB.sstat[] / sfirDHWMTR_SUB[])
#define DHWMTR_SUB_Y 0
#define DHWMTR_SUB_M 7
#define DHWMTR_SUB_D 14
#define DHWMTR_SUB_H 21

#define DHWMTR_SUB_NFIELDS 28  					// excludes rec start ovh; is # sstat[] bytes.



/*--- DHWMTR ---*/

// DHWMTR record class
class DHWMTR : public record 
{ public:
    DHWMTR( basAnc *_b, TI i, SI noZ=0)  :  record( _b, i, noZ)  {} 
    virtual ~DHWMTR() {} 
    DHWMTR& Copy( const DHWMTR& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    DHWMTR& operator=( const DHWMTR& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0) { record::Copy( pSrc, options); };

    RC wmt_CkF();
    RC wmt_Init( IVLCH ivl);
    void wmt_Accum( IVLCH ivl, int firstflg);
    DHWMTR_SUB curr;
    DHWMTR_SUB prior;
    unsigned char sstat[58];		// fld status bytes (base class excluded)
};		// DHWMTR

// DHWMTR field numbers (subscripts for DHWMTR.sstat[] / sfirDHWMTR[])
#define DHWMTR_NAME 0
#define DHWMTR_OWNTI 1
#define DHWMTR_CURR 2
#define DHWMTR_PRIOR 30

#define DHWMTR_NFIELDS 58  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirDHWMTR[];				// DHWMTR small fields-in-record table (srfd.cpp)

#define  makAncDHWMTR(name)        anc<DHWMTR> name( "DHWMETER", sfirDHWMTR, DHWMTR_NFIELDS, RTDHWMTR) 
#define  makAncDHWMTR2(name,what)  anc<DHWMTR> name( what, sfirDHWMTR, DHWMTR_NFIELDS, RTDHWMTR)	// 'what' override


/*--- DHWSYSRES_IVL ---*/

// DHWSYSRES_IVL record structure
struct DHWSYSRES_IVL
 { 
    void wsr_Clear() { memset( this, 0, sizeof( DHWSYSRES_IVL));}
    void wsr_Copy( const DHWSYSRES_IVL* s, float mult=1.f);
    void wsr_Accum( const DHWSYSRES_IVL* sIvl, int firstFlg, int lastFlg);
    void wsr_AccumTick( const struct DHWTICK& tk, float tLpIn);
    static const size_t wsr_NFLOAT;
    FLOAT qLoad;
    FLOAT qLoss;
    FLOAT qLoop;
    FLOAT qDWHR;
    FLOAT qSSF;
    FLOAT qSolar;
    FLOAT qWH;
    FLOAT qLH;
    FLOAT qXBU;
};		// DHWSYSRES_IVL

// DHWSYSRES_IVL field numbers (subscripts for DHWSYSRES_IVL.sstat[] / sfirDHWSYSRES_IVL[])
#define DHWSYSRES_IVL_QLOAD 0
#define DHWSYSRES_IVL_QLOSS 1
#define DHWSYSRES_IVL_QLOOP 2
#define DHWSYSRES_IVL_QDWHR 3
#define DHWSYSRES_IVL_QSSF 4
#define DHWSYSRES_IVL_QSOLAR 5
#define DHWSYSRES_IVL_QWH 6
#define DHWSYSRES_IVL_QLH 7
#define DHWSYSRES_IVL_QXBU 8

#define DHWSYSRES_IVL_NFIELDS 9  					// excludes rec start ovh; is # sstat[] bytes.



/*--- DHWSYSRES ---*/

// DHWSYSRES record class
class DHWSYSRES : public record 
{ public:
    DHWSYSRES( basAnc *_b, TI i, SI noZ=0)  :  record( _b, i, noZ)  {} 
    virtual ~DHWSYSRES() {} 
    DHWSYSRES& Copy( const DHWSYSRES& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    DHWSYSRES& operator=( const DHWSYSRES& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0) { record::Copy( pSrc, options); };

    RC wsr_Init( IVLCH ivl=-1);
    DHWSYSRES_IVL Y;
    DHWSYSRES_IVL M;
    DHWSYSRES_IVL D;
    DHWSYSRES_IVL H;
    DHWSYSRES_IVL S;
    unsigned char sstat[48];		// fld status bytes (base class excluded)
};		// DHWSYSRES

// DHWSYSRES field numbers (subscripts for DHWSYSRES.sstat[] / sfirDHWSYSRES[])
#define DHWSYSRES_NAME 0
#define DHWSYSRES_OWNTI 1
#define DHWSYSRES_Y 2
#define DHWSYSRES_M 11
#define DHWSYSRES_D 20
#define DHWSYSRES_H 29
#define DHWSYSRES_S 38

#define DHWSYSRES_NFIELDS 47  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirDHWSYSRES[];				// DHWSYSRES small fields-in-record table (srfd.cpp)

#define  makAncDHWSYSRES(name)        anc<DHWSYSRES> name( "DHWSYSRES", sfirDHWSYSRES, DHWSYSRES_NFIELDS, RTDHWSYSRES) 
#define  makAncDHWSYSRES2(name,what)  anc<DHWSYSRES> name( what, sfirDHWSYSRES, DHWSYSRES_NFIELDS, RTDHWSYSRES)	// 'what' override


/*--- SEGTOTS ---*/

// SEGTOTS record structure
struct SEGTOTS
 { 
    SEGTOTS();
    void st_Init();
    void st_Accum( const SEGTOTS& src, double count=1.);
    DBL st_count;
    DBL st_len;
    DBL st_vol;
    DBL st_exArea;
    DBL st_UA;
};		// SEGTOTS

// SEGTOTS field numbers (subscripts for SEGTOTS.sstat[] / sfirSEGTOTS[])
#define SEGTOTS_COUNT 0
#define SEGTOTS_LEN 1
#define SEGTOTS_VOL 2
#define SEGTOTS_EXAREA 3
#define SEGTOTS_UA 4

#define SEGTOTS_NFIELDS 5  					// excludes rec start ovh; is # sstat[] bytes.



/*--- DHWSYS ---*/

// DHWSYS record class
class DHWSYS : public record 
{ public:
    DHWSYS( basAnc *_b, TI i, SI noZ=0)  :  record( _b, i, noZ)  {} 
    virtual ~DHWSYS(); 
    DHWSYS& Copy( const DHWSYS& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    DHWSYS& operator=( const DHWSYS& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0);

    virtual DHWSYS& CopyFrom( const record* src, int copyName=1, int dupPtrs=0);
    RC ws_CkF();
    RC ws_CheckVals( int erOp);
    RC ws_CheckSubObject( record* r);
    RC ws_Init( int pass);
    RC ws_RddInit();
    DHWSYSRES* ws_GetDHWSYSRES() const;
    float ws_GetTSetpoint( int whfcn) const;
    int ws_GetTSetpointFN( int whfcn) const;
    virtual RC RunDup( const record* pSrc, int options=0);
    RC ws_DoHour( IVLCH ivl, float centralMult=1.f);
    RC ws_AccumCentralUse( const DHWSYS* pWSChild);
    RC ws_DoHourDrawAccounting( float mult);
    RC ws_DoEndPreRun();
    RC ws_ApplySizingResults( float heatingCap, float* heatingCapTopN, float volRunning);
    int ws_AssignDHWUSEtoFX( const DHWUSE* pWU);
    void ws_AccumUseTick( DHWEUCH hwEndUse, int iTk, double fxUseMix, double whUse);
    RC ws_DoSubhr();
    RC ws_DoSubhrStart( int iTk0);
    RC ws_DoSubhrTick( int iTk);
    RC ws_DoSubhrEnd();
    RC ws_EndIvl( int ivl);
    void ws_SetMTRPtrs();
    float ws_BranchFlow() const;
    WSCALCMODECH ws_calcMode;
    TI ws_centralDHWSYSi;
    int ws_HasCentralDHWSYS() const { return ws_centralDHWSYSi > 0; }
    DHWSYS* ws_GetCentralDHWSYS() const;
    int ws_IsCentralDHWSYS() const;
    FLOAT ws_mult;
    TI ws_elecMtri;
    TI ws_fuelMtri;
    FLOAT ws_inElec;
    FLOAT ws_inFuel;
    MTR* ws_pMtrElec; MTR* ws_pMtrFuel;
    TI ws_swTi;
    DHWSOLARSYS* ws_pDHWSOLARSYS;
    FLOAT ws_qSlr;
    DBL ws_SSFAnnualSolar;
    DBL ws_SSFAnnualReq;
    FLOAT ws_SSFAnnual;
    FLOAT ws_tInlet;
    FLOAT ws_tInletX;
    FLOAT ws_hwUse;
    struct DHWTICK* ws_ticks;
    INT ws_iTk0DWHR;
    INT ws_iTkNDWHR;
    void ws_TickInit( double whUseHr);
    float ws_TickAvgTInletX( float& whUseTot) const;
    RC ws_AddLossesToDraws( struct DHWTICK* ticksh);
    RC ws_DoHourDWHR();
    FLOAT ws_qDWHR;
    FLOAT ws_qDWHRWH;
    TI ws_WHhwMtri;
    TI ws_FXhwMtri;
    DHWMTR* ws_pWHhwMtr; DHWMTR* ws_pFXhwMtr;
    FLOAT ws_whUseNoHR;
    DHWMTR_IVL ws_fxUseMix;
    DBL ws_fxUseMixTot[8];
    DHWMTR_IVL ws_fxUseMixLH;
    DHWMTR_IVL ws_whUse;
    DBL ws_whUseTot[8];
    SI ws_drawMaxDur;
    VMovingSum< float> ws_drawMaxMS;
    FLOAT ws_drawMax;
    SI ws_loadMaxDur;
    VMovingSum< float> ws_loadMaxMS;
    FLOAT ws_loadMax;
    struct DHWSIZER* ws_pSizer;
    FLOAT ws_tSetpointDes;
    FLOAT ws_tInletDes;
    FLOAT ws_ashpTSrcDes;
    FLOAT ws_heatingCapDesTopN[10];
    FLOAT ws_heatingCapDes;
    FLOAT ws_volRunningDes;
    FLOAT ws_fxDes;
    FLOAT ws_tUse;
    FLOAT ws_tSetpoint;
    FLOAT ws_tSetpointLH;
    DHWDRMETH ws_drMethod;
    DHWDRSIG ws_drSignal;
    INT ws_drStatusHPWH;
    DBL ws_tOutPrimSum;
    FLOAT ws_tOutPrimLT;
    TI ws_dayUsei;
    CHP ws_dayUseName;
    INT ws_childDHWDAYUSEFlag;
    bool ws_HasDHWDAYUSEDraws() const { return ws_dayUseName != NULL || ws_childDHWDAYUSEFlag; }
    FLOAT ws_parElec;
    FLOAT ws_SDLM;
    FLOAT ws_DSM;
    FLOAT ws_SSF;
    void ws_TickApplySSF();
    FLOAT ws_WF;
    INT ws_drawCount[6];
    FLOAT ws_drawsPerDay[6];
    FLOAT ws_drawDurF[6];
    DHWBRANCHMODELCH ws_branchModel;
    FLOAT ws_drawWaste[6];
    FLOAT ws_dayWasteDrawF[6];
    FLOAT ws_dayWasteVol;
    FLOAT ws_dayWasteBranchVolF;
    FLOAT ws_dayWaste;
    FLOAT ws_dayWasteScale;
    double ws_DrawWaste( int iEU) const { return ws_drawWaste[ iEU] + ws_dayWasteDrawF[ iEU]*ws_dayWasteScale; }
    FLOAT ws_childDHWSYSCount;
    FLOAT ws_whCount;
    FLOAT ws_wlhCount;
    FLOAT ws_whCountUseTS;
    FLOAT ws_wlhCountUseTS;
    INT ws_wtCount;
    INT ws_wpCount;
    INT ws_wlCount;
    INT ws_configChecked;
    SEGTOTS ws_loopSegTotals;
    SEGTOTS ws_branchTotals;
    INT ws_wrCount;
    INT ws_wrFeedWHCount;
    INT ws_wrFxDrainCount;
    SI ws_fxCount[6];
    int ws_ShowerCount() const { return ws_fxCount[ C_DHWEUCH_SHOWER]; }
    struct DHWFX* ws_fxList;
    TI ws_loadShareDHWSYSi;
    INT ws_loadShareCount[6];
    int ws_loadShareIdxRange[ NDHWENDUSESPP][ 2];
    int& ws_LSR( int iEU, int lh) { return ws_loadShareIdxRange[ iEU][lh]; }
    void ws_LSRSet( int iEU, int fx0, int nFx) { ws_LSR( iEU,0) = nFx>0 ? fx0 : -1; ws_LSR( iEU,1) = nFx>0 ? fx0+nFx-1 : -1; }
    bool ws_IsLSR( int iEU, int idx) { return idx>=ws_LSR( iEU,0) && idx<=ws_LSR( iEU,1); }
    INT ws_loadShareWS0[6];
    NOYESCH ws_drawCSV;
    FILE* ws_pFDrawCSV;
    RC ws_WriteDrawCSV();
    FLOAT ws_HHWO;
    FLOAT ws_DLM;
    FLOAT ws_volRL;
    FLOAT ws_tRL;
    FLOAT ws_HRBL;
    FLOAT ws_t24WL;
    DBL ws_t24WLTot;
    FLOAT ws_HRDL;
    FLOAT ws_HJLsh;
    FLOAT ws_HJL;
    FLOAT ws_HARL;
    unsigned char sstat[186];		// fld status bytes (base class excluded)
};		// DHWSYS

// DHWSYS field numbers (subscripts for DHWSYS.sstat[] / sfirDHWSYS[])
#define DHWSYS_NAME 0
#define DHWSYS_OWNTI 1
#define DHWSYS_CALCMODE 2
#define DHWSYS_CENTRALDHWSYSI 3
#define DHWSYS_MULT 4
#define DHWSYS_ELECMTRI 5
#define DHWSYS_FUELMTRI 6
#define DHWSYS_INELEC 7
#define DHWSYS_INFUEL 8
#define DHWSYS_SWTI 9
#define DHWSYS_QSLR 10
#define DHWSYS_SSFANNUALSOLAR 11
#define DHWSYS_SSFANNUALREQ 12
#define DHWSYS_SSFANNUAL 13
#define DHWSYS_TINLET 14
#define DHWSYS_TINLETX 15
#define DHWSYS_HWUSE 16
#define DHWSYS_ITK0DWHR 17
#define DHWSYS_ITKNDWHR 18
#define DHWSYS_QDWHR 19
#define DHWSYS_QDWHRWH 20
#define DHWSYS_WHHWMTRI 21
#define DHWSYS_FXHWMTRI 22
#define DHWSYS_WHUSENOHR 23
#define DHWSYS_FXUSEMIX 24
#define DHWSYS_FXUSEMIXTOT 31
#define DHWSYS_FXUSEMIXLH 39
#define DHWSYS_WHUSE 46
#define DHWSYS_WHUSETOT 53
#define DHWSYS_DRAWMAXDUR 61
#define DHWSYS_DRAWMAX 62
#define DHWSYS_LOADMAXDUR 63
#define DHWSYS_LOADMAX 64
#define DHWSYS_TSETPOINTDES 65
#define DHWSYS_TINLETDES 66
#define DHWSYS_ASHPTSRCDES 67
#define DHWSYS_HEATINGCAPDESTOPN 68
#define DHWSYS_HEATINGCAPDES 78
#define DHWSYS_VOLRUNNINGDES 79
#define DHWSYS_FXDES 80
#define DHWSYS_TUSE 81
#define DHWSYS_TSETPOINT 82
#define DHWSYS_TSETPOINTLH 83
#define DHWSYS_DRMETHOD 84
#define DHWSYS_DRSIGNAL 85
#define DHWSYS_DRSTATUSHPWH 86
#define DHWSYS_TOUTPRIMSUM 87
#define DHWSYS_TOUTPRIMLT 88
#define DHWSYS_DAYUSEI 89
#define DHWSYS_DAYUSENAME 90
#define DHWSYS_CHILDDHWDAYUSEFLAG 91
#define DHWSYS_PARELEC 92
#define DHWSYS_SDLM 93
#define DHWSYS_DSM 94
#define DHWSYS_SSF 95
#define DHWSYS_WF 96
#define DHWSYS_DRAWCOUNT 97
#define DHWSYS_DRAWSPERDAY 103
#define DHWSYS_DRAWDURF 109
#define DHWSYS_BRANCHMODEL 115
#define DHWSYS_DRAWWASTE 116
#define DHWSYS_DAYWASTEDRAWF 122
#define DHWSYS_DAYWASTEVOL 128
#define DHWSYS_DAYWASTEBRANCHVOLF 129
#define DHWSYS_DAYWASTE 130
#define DHWSYS_DAYWASTESCALE 131
#define DHWSYS_CHILDDHWSYSCOUNT 132
#define DHWSYS_WHCOUNT 133
#define DHWSYS_WLHCOUNT 134
#define DHWSYS_WHCOUNTUSETS 135
#define DHWSYS_WLHCOUNTUSETS 136
#define DHWSYS_WTCOUNT 137
#define DHWSYS_WPCOUNT 138
#define DHWSYS_WLCOUNT 139
#define DHWSYS_CONFIGCHECKED 140
#define DHWSYS_LOOPSEGTOTALS 141
#define DHWSYS_BRANCHTOTALS 146
#define DHWSYS_WRCOUNT 151
#define DHWSYS_WRFEEDWHCOUNT 152
#define DHWSYS_WRFXDRAINCOUNT 153
#define DHWSYS_FXCOUNT 154
#define DHWSYS_LOADSHAREDHWSYSI 160
#define DHWSYS_LOADSHARECOUNT 161
#define DHWSYS_LOADSHAREWS0 167
#define DHWSYS_DRAWCSV 173
#define DHWSYS_HHWO 174
#define DHWSYS_DLM 175
#define DHWSYS_VOLRL 176
#define DHWSYS_TRL 177
#define DHWSYS_HRBL 178
#define DHWSYS_T24WL 179
#define DHWSYS_T24WLTOT 180
#define DHWSYS_HRDL 181
#define DHWSYS_HJLSH 182
#define DHWSYS_HJL 183
#define DHWSYS_HARL 184

#define DHWSYS_NFIELDS 185  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirDHWSYS[];				// DHWSYS small fields-in-record table (srfd.cpp)

#define  makAncDHWSYS(name)        anc<DHWSYS> name( "DHWSys", sfirDHWSYS, DHWSYS_NFIELDS, RTDHWSYS) 
#define  makAncDHWSYS2(name,what)  anc<DHWSYS> name( what, sfirDHWSYS, DHWSYS_NFIELDS, RTDHWSYS)	// 'what' override


/*--- HPWHLINK ---*/

// HPWHLINK record structure
struct HPWHLINK
 { 
    virtual ~HPWHLINK();
    static WStr hw_GetHPWHVersion();
    static void hw_HPWHMessageCallback( const std::string message, void* contextPtr);
    void hw_HPWHReceiveMessage( const std::string message);
    void hw_Cleanup();
    RC hw_Init( record* pOwner);
    RC hw_InitGeneric( float vol, float EF, float resUse);
    RC hw_SetHeatingCap( float heatingCap, float ashpTSrcDes,	float tInletDes, float tUseDes);
    RC hw_GetHeatingCap( float& heatingCap, float ashpTSrcDes, float tInletDes, float tUseDes) const;
    enum HPWHATTR { hwatSMALL=0x1000, hwatLARGE=0x2000, hwatMASK=0xf000 };
    static int hw_HPWHInfo( WHASHPTYCH ashpTy, int& attrs);
    static int hw_IsAttr( WHASHPTYCH ashpTy, int attr) { int attrs; return hw_HPWHInfo( ashpTy, attrs) >= 0 ? (attr & attrs) != 0 : -1; }
    RC hw_InitPreset( WHASHPTYCH ashpTy);
    RC hw_InitResistance( WHRESTYCH resTy, float vol, float EF, float resHt, float resHt2, float tUse);
    RC hw_InitTank( float vol);
    RC hw_AdjustUAIf( float UA, float insulR, float tankCount=1.f);
    RC hw_InitFinalize( float inHtSupply, float inHtLoopRet);
    RC hw_GetInfo( float& vol, float& UA, float& insulR, float tankCount=1.f) const;
    float hw_GetTankSurfaceArea( float tankCount=1.f, float vol=-1.f) const;
    void hw_InitTotals();
    bool hw_HasCompressor() const;
    bool hw_IsSetpointFixed() const;
    float hw_GetTankVol() const;
    RC hw_DeriveVolFromVolRunning( float volRunning, float heatingCap, float tempRise, float& totVol) const;
    void hw_SetNQTXNodes( int nQTXNodes);
    float hw_GetTankQTXTemp() const { return float( hw_GetTankAvgTemp( 0, hw_nQTXNodes)); }
    double hw_GetTankAvgTemp( int iNode0=0, int nNodes=999) const;
    double hw_GetEstimatedTOut() const;
    void hw_SetQTX( float qTX);
    RC hw_DoHour( float& tSetpoint);
    RC hw_DoSubhrStart( float tEx, float tASHPSrc=-999.f);
    RC hw_DoSubhrTick( DHWTICK& tk, float tInlet, float scaleWH=1.f, float tMix=-1., float tMains=-1.f, float* pTOutNoMix=NULL, int drStatus=0);
    RC hw_DoSubhrTick( int iTk, float draw, float tInlet, float* pTOut, float scaleWH=1.f);
    RC hw_DoSubhrEnd( float mult, ZNR* pZn, ZNR* pZnASHPSrc);
    record* hw_pOwner;
    class HPWH* hw_pHPWH;
    INT hw_HSCount;
    int* hw_HSMap;
    FLOAT hw_tEx;
    FLOAT hw_tASHPSrc;
    FLOAT hw_qTXTick;
    INT hw_nQTXNodes;
    std::vector< double>* hw_pNodePowerExtra_W;
    FLOAT hw_fMixUse;
    FLOAT hw_fMixRL;
    DBL hw_inElec[2];
    FLOAT hw_HPWHxBU;
    DBL hw_qEnv;
    DBL hw_qLoss;
    DBL hw_qHW;
    DBL hw_qTX;
    INT hw_tankTempSet;
    FLOAT hw_tankHCNominal;
    DBL hw_tankHCStart;
    DBL hw_tHWOutF;
    INT hw_nzDrawCount;
    FLOAT hw_tHWOut;
    INT hw_bWriteCSV;
    FILE* hw_pFCSV;
    INT hw_balErrCount;
    DBL hw_balErrMax;
};		// HPWHLINK

// HPWHLINK field numbers (subscripts for HPWHLINK.sstat[] / sfirHPWHLINK[])
#define HPWHLINK_HSCOUNT 0
#define HPWHLINK_TEX 1
#define HPWHLINK_TASHPSRC 2
#define HPWHLINK_QTXTICK 3
#define HPWHLINK_NQTXNODES 4
#define HPWHLINK_FMIXUSE 5
#define HPWHLINK_FMIXRL 6
#define HPWHLINK_INELEC 7
#define HPWHLINK_HPWHXBU 9
#define HPWHLINK_QENV 10
#define HPWHLINK_QLOSS 11
#define HPWHLINK_QHW 12
#define HPWHLINK_QTX 13
#define HPWHLINK_TANKTEMPSET 14
#define HPWHLINK_TANKHCNOMINAL 15
#define HPWHLINK_TANKHCSTART 16
#define HPWHLINK_THWOUTF 17
#define HPWHLINK_NZDRAWCOUNT 18
#define HPWHLINK_THWOUT 19
#define HPWHLINK_BWRITECSV 20
#define HPWHLINK_BALERRCOUNT 21
#define HPWHLINK_BALERRMAX 22

#define HPWHLINK_NFIELDS 23  					// excludes rec start ovh; is # sstat[] bytes.



/*--- DHWHEATER ---*/

// DHWHEATER record class
class DHWHEATER : public record 
{ public:
    DHWHEATER( basAnc *_b, TI i, SI noZ=0)  :  record( _b, i, noZ)  {} 
    virtual ~DHWHEATER(); 
    DHWHEATER& Copy( const DHWHEATER& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    DHWHEATER& operator=( const DHWHEATER& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0) { record::Copy( pSrc, options); };

    RC wh_CkF();
    virtual RC RunDup( const record* pSrc, int options=0);
    RC wh_Init();
    void wh_InitRunTotals();
    RC wh_RddInit();
    void wh_SetDesc();
    DHWSYS* wh_GetDHWSYS() const { return (DHWSYS *)getOwner();}
    DHWHEATER* wh_GetInputDHWHEATER() const;
    int wh_IsElec() const { return wh_heatSrc != C_WHHEATSRCCH_FUEL; }
    int wh_IsStorage() const { return wh_type==C_WHTYPECH_STRGSML || wh_type==C_WHTYPECH_STRGLRG || wh_type==C_WHTYPECH_BUILTUP; }
    int wh_IsScalable() const;
    int wh_CanSetVolFromVolRunning() const;
    int wh_UsesDerivedLDEF() const;
    int wh_IsHPWHModel() const { return wh_heatSrc==C_WHHEATSRCCH_ASHPX || wh_heatSrc==C_WHHEATSRCCH_ELRESX; }
    int wh_CanHaveLoopReturn() const { return wh_IsHPWHModel(); }
    int wh_CanHaveDHWLOOPHEATER() const { return wh_GetFunction()==whfcnPRIMARY && wh_IsHPWHModel(); }
    int wh_IsInstUEFModel() const { return wh_type==C_WHTYPECH_INSTUEF; }
    int wh_IsSubhrModel() const { return wh_IsHPWHModel() || wh_IsInstUEFModel(); }
    int wh_UsesTSetpoint() const { return wh_IsHPWHModel(); }
    float wh_CalcLDEF( float arl, int options=0);
    RC wh_DoHour();
    RC wh_DoSubhrStart();
    RC wh_DoSubhrTick( struct DHWTICK& tk, float scaleWH);
    RC wh_InstUEFInit();
    RC wh_InstUEFDoSubhrTick( double draw, float tInletWH, float scaleWH, float tUse);
    RC wh_DoSubhrEnd( bool bIsLH);
    RC wh_DoEndPreRun();
    RC wh_EndIvl( IVLCH ivl, float HARL, float wsMult);
    static WStr wh_GetHPWHVersion();
    int wh_ReportBalErrorsIf() const;
    virtual void ReceiveRuntimeMessage( const char* msg);
    RC wh_HPWHInit();
    static void wh_DRMapValidate();
    static int wh_DRMapSigToDRStatus( DHWDRSIG drSig);
    FLOAT wh_mult;
    WHHEATSRCCH wh_heatSrc;
    WHTYPECH wh_type;
    ANAME wh_desc;
    virtual const char* GetDescription( int options=0) { options; return wh_desc; }
    INT wh_fcn;
    enum { whfcnUNKNOWN=0, whfcnPRIMARY, whfcnLOOPHEATER, whfcnCOUNT=whfcnLOOPHEATER, whfcnLASTHEATER=0x100 };
    int wh_GetFunction() const { return wh_fcn & 0xff; }
    int wh_SetFunction();
    bool wh_IsLastHeater() const { return (wh_fcn & whfcnLASTHEATER) != 0; }
    WHASHPTYCH wh_ashpTy;
    WHRESTYCH wh_resTy;
    TI wh_znTi;
    ZNR* wh_pZn;
    FLOAT wh_tEx;
    TI wh_ashpSrcZnTi;
    ZNR* wh_pAshpSrcZn;
    FLOAT wh_ashpTSrc;
    FLOAT wh_ashpResUse;
    FLOAT wh_tankCount;
    FLOAT wh_heatingCap;
    FLOAT wh_vol;
    FLOAT wh_volRunning;
    FLOAT wh_UA;
    FLOAT wh_insulR;
    FLOAT wh_inHtSupply;
    FLOAT wh_inHtLoopRet;
    FLOAT wh_EF;
    FLOAT wh_LDEF;
    FLOAT wh_UEF;
    FLOAT wh_ratedFlow;
    FLOAT wh_annualFuel;
    FLOAT wh_annualElec;
    FLOAT wh_cycLossFuel;
    FLOAT wh_cycLossElec;
    FLOAT wh_maxFlowX;
    FLOAT wh_maxInpX;
    FLOAT wh_eff;
    FLOAT wh_SBL;
    FLOAT wh_pilotPwr;
    FLOAT wh_parElec;
    FLOAT wh_tHWOut;
    INT wh_stbyTicks;
    FLOAT wh_loadCFwdF;
    DBL wh_loadCFwdMax;
    DBL wh_loadCFwd;
    FLOAT wh_nTickFullLoad;
    DBL wh_nColdStarts;
    FLOAT wh_effSh;
    FLOAT wh_operElec;
    FLOAT wh_stbyElec;
    FLOAT wh_resHtPwr;
    FLOAT wh_resHtPwr2;
    HPWHLINK wh_HPWH;
    FLOAT wh_qXBU;
    DBL wh_qEnv;
    DBL wh_qLoss;
    FLOAT wh_qHW;
    INT wh_nzDrawCount;
    INT wh_bWriteCSV;
    FILE* wh_pFCSV;
    DBL wh_totHARL;
    INT wh_hrCount;
    DBL wh_totOut;
    FLOAT wh_inElecSh;
    FLOAT wh_inElecBUSh;
    FLOAT wh_inElecXBUSh;
    FLOAT wh_inFuelSh;
    FLOAT wh_inElec;
    FLOAT wh_inElecBU;
    FLOAT wh_inElecXBU;
    FLOAT wh_inFuel;
    DBL wh_inElecTot;
    DBL wh_inFuelTot;
    TI wh_elecMtri;
    TI wh_fuelMtri;
    ENDUSECH wh_xBUEndUse;
    MTR* wh_pMtrElec; MTR* wh_pMtrFuel;
    DHWSYSRES_IVL* wh_pResSh;
    INT wh_unMetSh;
    INT wh_unMetHrs;
    INT wh_balErrCount;
    FLOAT wh_tInlet;
    FLOAT wh_draw;
    unsigned char sstat[98];		// fld status bytes (base class excluded)
};		// DHWHEATER

// DHWHEATER field numbers (subscripts for DHWHEATER.sstat[] / sfirDHWHEATER[])
#define DHWHEATER_NAME 0
#define DHWHEATER_OWNTI 1
#define DHWHEATER_MULT 2
#define DHWHEATER_HEATSRC 3
#define DHWHEATER_TYPE 4
#define DHWHEATER_DESC 5
#define DHWHEATER_FCN 6
#define DHWHEATER_ASHPTY 7
#define DHWHEATER_RESTY 8
#define DHWHEATER_ZNTI 9
#define DHWHEATER_TEX 10
#define DHWHEATER_ASHPSRCZNTI 11
#define DHWHEATER_ASHPTSRC 12
#define DHWHEATER_ASHPRESUSE 13
#define DHWHEATER_TANKCOUNT 14
#define DHWHEATER_HEATINGCAP 15
#define DHWHEATER_VOL 16
#define DHWHEATER_VOLRUNNING 17
#define DHWHEATER_UA 18
#define DHWHEATER_INSULR 19
#define DHWHEATER_INHTSUPPLY 20
#define DHWHEATER_INHTLOOPRET 21
#define DHWHEATER_EF 22
#define DHWHEATER_LDEF 23
#define DHWHEATER_UEF 24
#define DHWHEATER_RATEDFLOW 25
#define DHWHEATER_ANNUALFUEL 26
#define DHWHEATER_ANNUALELEC 27
#define DHWHEATER_CYCLOSSFUEL 28
#define DHWHEATER_CYCLOSSELEC 29
#define DHWHEATER_MAXFLOWX 30
#define DHWHEATER_MAXINPX 31
#define DHWHEATER_EFF 32
#define DHWHEATER_SBL 33
#define DHWHEATER_PILOTPWR 34
#define DHWHEATER_PARELEC 35
#define DHWHEATER_THWOUT 36
#define DHWHEATER_STBYTICKS 37
#define DHWHEATER_LOADCFWDF 38
#define DHWHEATER_LOADCFWDMAX 39
#define DHWHEATER_LOADCFWD 40
#define DHWHEATER_NTICKFULLLOAD 41
#define DHWHEATER_NCOLDSTARTS 42
#define DHWHEATER_EFFSH 43
#define DHWHEATER_OPERELEC 44
#define DHWHEATER_STBYELEC 45
#define DHWHEATER_RESHTPWR 46
#define DHWHEATER_RESHTPWR2 47
#define DHWHEATER_HPWH 48
#define DHWHEATER_QXBU 71
#define DHWHEATER_QENV 72
#define DHWHEATER_QLOSS 73
#define DHWHEATER_QHW 74
#define DHWHEATER_NZDRAWCOUNT 75
#define DHWHEATER_BWRITECSV 76
#define DHWHEATER_TOTHARL 77
#define DHWHEATER_HRCOUNT 78
#define DHWHEATER_TOTOUT 79
#define DHWHEATER_INELECSH 80
#define DHWHEATER_INELECBUSH 81
#define DHWHEATER_INELECXBUSH 82
#define DHWHEATER_INFUELSH 83
#define DHWHEATER_INELEC 84
#define DHWHEATER_INELECBU 85
#define DHWHEATER_INELECXBU 86
#define DHWHEATER_INFUEL 87
#define DHWHEATER_INELECTOT 88
#define DHWHEATER_INFUELTOT 89
#define DHWHEATER_ELECMTRI 90
#define DHWHEATER_FUELMTRI 91
#define DHWHEATER_XBUENDUSE 92
#define DHWHEATER_UNMETSH 93
#define DHWHEATER_UNMETHRS 94
#define DHWHEATER_BALERRCOUNT 95
#define DHWHEATER_TINLET 96
#define DHWHEATER_DRAW 97

#define DHWHEATER_NFIELDS 98  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirDHWHEATER[];				// DHWHEATER small fields-in-record table (srfd.cpp)

#define  makAncDHWHEATER(name)        anc<DHWHEATER> name( "DHWHeater", sfirDHWHEATER, DHWHEATER_NFIELDS, RTDHWHEATER) 
#define  makAncDHWHEATER2(name,what)  anc<DHWHEATER> name( what, sfirDHWHEATER, DHWHEATER_NFIELDS, RTDHWHEATER)	// 'what' override


/*--- DHWHEATREC ---*/

// DHWHEATREC record class
class DHWHEATREC : public record 
{ public:
    DHWHEATREC( basAnc *_b, TI i, SI noZ=0)  :  record( _b, i, noZ)  {} 
    virtual ~DHWHEATREC(); 
    DHWHEATREC& Copy( const DHWHEATREC& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    DHWHEATREC& operator=( const DHWHEATREC& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0) { record::Copy( pSrc, options); };

    RC wr_CkF();
    RC wr_Init();
    void wr_InitTicks();
    DHWSYS* wr_GetDHWSYS() const { return (DHWSYS *)getOwner(); }
    float wr_EffAdjusted( float vp, float tpI, float vd, float tdI);
    void wr_EffAdjustedTest();
    bool wr_IsEffFlowIndependent() const { return wr_type == C_DWHRTYCH_SETEF || wr_effRated < .00001f; }
    int wr_IsEquiv( const DHWHEATREC& wr) const;
    float wr_CalcTick( DHWSYS* pWS, struct DHWHRTICK& wrtk, float vOther, float& whUseNoHR, float& fxUseMix, float& qR, float& qRWH);
    inline float wr_HX( float vp, float tpI, float vd, float td) const
    { if (vp<=0.f) return tpI; float f=wr_eff*min(vp, vd)/vp; return f*td+(1.f-f)*tpI;}
    RC wr_SetFXConnections( DHWSYS* pWS, int& iFx);
    struct DHWHRTICK* wr_ticks;
    SI wr_mult;
    DHWEUCH wr_hwEndUse;
    DWHRTYCH wr_type;
    SI wr_nFXDrain;
    SI wr_nFXCold;
    NOYESCH wr_feedsWH;
    bool wr_FeedsFX() const { return wr_nFXCold > 0; }
    bool wr_FeedsWH() const { return wr_feedsWH==C_NOYESCH_YES; }
    FLOAT wr_effRated;
    FLOAT wr_tdInDiff;
    FLOAT wr_tdInWarmup;
    FLOAT wr_eff;
    FLOAT wr_tpO;
    FLOAT wr_vp;
    unsigned char sstat[14];		// fld status bytes (base class excluded)
};		// DHWHEATREC

// DHWHEATREC field numbers (subscripts for DHWHEATREC.sstat[] / sfirDHWHEATREC[])
#define DHWHEATREC_NAME 0
#define DHWHEATREC_OWNTI 1
#define DHWHEATREC_MULT 2
#define DHWHEATREC_HWENDUSE 3
#define DHWHEATREC_TYPE 4
#define DHWHEATREC_NFXDRAIN 5
#define DHWHEATREC_NFXCOLD 6
#define DHWHEATREC_FEEDSWH 7
#define DHWHEATREC_EFFRATED 8
#define DHWHEATREC_TDINDIFF 9
#define DHWHEATREC_TDINWARMUP 10
#define DHWHEATREC_EFF 11
#define DHWHEATREC_TPO 12
#define DHWHEATREC_VP 13

#define DHWHEATREC_NFIELDS 14  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirDHWHEATREC[];				// DHWHEATREC small fields-in-record table (srfd.cpp)

#define  makAncDHWHEATREC(name)        anc<DHWHEATREC> name( "DHWHeatRec", sfirDHWHEATREC, DHWHEATREC_NFIELDS, RTDHWHEATREC) 
#define  makAncDHWHEATREC2(name,what)  anc<DHWHEATREC> name( what, sfirDHWHEATREC, DHWHEATREC_NFIELDS, RTDHWHEATREC)	// 'what' override


/*--- DHWTANK ---*/

// DHWTANK record class
class DHWTANK : public record 
{ public:
    DHWTANK( basAnc *_b, TI i, SI noZ=0)  :  record( _b, i, noZ)  {} 
    virtual ~DHWTANK() {} 
    DHWTANK& Copy( const DHWTANK& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    DHWTANK& operator=( const DHWTANK& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0) { record::Copy( pSrc, options); };

    virtual RC RunDup( const record* pSrc, int options=0);
    RC wt_CkF();
    DHWSYS* wt_GetDHWSYS() const { return (DHWSYS*)getOwner();}
    RC wt_Init();
    RC wt_DoHour();
    RC wt_DoSubhr( float tUse);
    static FLOAT TankSurfArea_CEC(float vol);
    SI wt_mult;
    FLOAT wt_UA;
    FLOAT wt_vol;
    FLOAT wt_insulR;
    FLOAT wt_tTank;
    TI wt_znTi;
    ZNR* wt_pZn;
    FLOAT wt_tEx;
    FLOAT wt_xLoss;
    FLOAT wt_qLossSh;
    FLOAT wt_qLoss;
    unsigned char sstat[12];		// fld status bytes (base class excluded)
};		// DHWTANK

// DHWTANK field numbers (subscripts for DHWTANK.sstat[] / sfirDHWTANK[])
#define DHWTANK_NAME 0
#define DHWTANK_OWNTI 1
#define DHWTANK_MULT 2
#define DHWTANK_UA 3
#define DHWTANK_VOL 4
#define DHWTANK_INSULR 5
#define DHWTANK_TTANK 6
#define DHWTANK_ZNTI 7
#define DHWTANK_TEX 8
#define DHWTANK_XLOSS 9
#define DHWTANK_QLOSSSH 10
#define DHWTANK_QLOSS 11

#define DHWTANK_NFIELDS 12  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirDHWTANK[];				// DHWTANK small fields-in-record table (srfd.cpp)

#define  makAncDHWTANK(name)        anc<DHWTANK> name( "DHWTank", sfirDHWTANK, DHWTANK_NFIELDS, RTDHWTANK) 
#define  makAncDHWTANK2(name,what)  anc<DHWTANK> name( what, sfirDHWTANK, DHWTANK_NFIELDS, RTDHWTANK)	// 'what' override


/*--- DHWPUMP ---*/

// DHWPUMP record class
class DHWPUMP : public record 
{ public:
    DHWPUMP( basAnc *_b, TI i, SI noZ=0)  :  record( _b, i, noZ)  {} 
    virtual ~DHWPUMP() {} 
    DHWPUMP& Copy( const DHWPUMP& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    DHWPUMP& operator=( const DHWPUMP& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0) { record::Copy( pSrc, options); };

    RC wp_CkF();
    virtual RC RunDup( const record* pSrc, int options=0);
    DHWSYS* wp_GetDHWSYS() const { return (DHWSYS*)getOwner(); }
    float wp_DoHour( int mult, float runF=1.f);
    SI wp_mult;
    TI wp_elecMtri;
    MTR* wp_pMtrElec;
    FLOAT wp_pwr;
    FLOAT wp_liqHeatF;
    FLOAT wp_inElec;
    unsigned char sstat[8];		// fld status bytes (base class excluded)
};		// DHWPUMP

// DHWPUMP field numbers (subscripts for DHWPUMP.sstat[] / sfirDHWPUMP[])
#define DHWPUMP_NAME 0
#define DHWPUMP_OWNTI 1
#define DHWPUMP_MULT 2
#define DHWPUMP_ELECMTRI 3
#define DHWPUMP_PWR 4
#define DHWPUMP_LIQHEATF 5
#define DHWPUMP_INELEC 6

#define DHWPUMP_NFIELDS 7  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirDHWPUMP[];				// DHWPUMP small fields-in-record table (srfd.cpp)

#define  makAncDHWPUMP(name)        anc<DHWPUMP> name( "DHWPump", sfirDHWPUMP, DHWPUMP_NFIELDS, RTDHWPUMP) 
#define  makAncDHWPUMP2(name,what)  anc<DHWPUMP> name( what, sfirDHWPUMP, DHWPUMP_NFIELDS, RTDHWPUMP)	// 'what' override


/*--- DHWLOOP ---*/

// DHWLOOP record class
class DHWLOOP : public record 
{ public:
    DHWLOOP( basAnc *_b, TI i, SI noZ=0)  :  record( _b, i, noZ)  {} 
    virtual ~DHWLOOP() {} 
    DHWLOOP& Copy( const DHWLOOP& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    DHWLOOP& operator=( const DHWLOOP& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0) { record::Copy( pSrc, options); };

    RC wl_CkF();
    virtual RC RunDup( const record* pSrc, int options=0);
    RC wl_Init();
    DHWSYS* wl_GetDHWSYS() const { return(DHWSYS*)getOwner(); }
    RC wl_DoHour( int wsMult);
    SI wl_mult;
    SI wl_wlpCount;
    FLOAT wl_flow;
    FLOAT wl_runF;
    FLOAT wl_tIn1;
    FLOAT wl_fUA;
    FLOAT wl_lossMakeupPwr;
    FLOAT wl_lossMakeupEff;
    TI wl_elecMtri;
    MTR* wl_pMtrElec;
    SEGTOTS wl_segTotals;
    SEGTOTS wl_branchTotals;
    FLOAT wl_volRL;
    FLOAT wl_qLiqLP;
    FLOAT wl_HRLL;
    FLOAT wl_HRLLnet;
    FLOAT wl_HRBL;
    FLOAT wl_t24WL;
    FLOAT wl_tRL;
    unsigned char sstat[28];		// fld status bytes (base class excluded)
};		// DHWLOOP

// DHWLOOP field numbers (subscripts for DHWLOOP.sstat[] / sfirDHWLOOP[])
#define DHWLOOP_NAME 0
#define DHWLOOP_OWNTI 1
#define DHWLOOP_MULT 2
#define DHWLOOP_WLPCOUNT 3
#define DHWLOOP_FLOW 4
#define DHWLOOP_RUNF 5
#define DHWLOOP_TIN1 6
#define DHWLOOP_FUA 7
#define DHWLOOP_LOSSMAKEUPPWR 8
#define DHWLOOP_LOSSMAKEUPEFF 9
#define DHWLOOP_ELECMTRI 10
#define DHWLOOP_SEGTOTALS 11
#define DHWLOOP_BRANCHTOTALS 16
#define DHWLOOP_VOLRL 21
#define DHWLOOP_QLIQLP 22
#define DHWLOOP_HRLL 23
#define DHWLOOP_HRLLNET 24
#define DHWLOOP_HRBL 25
#define DHWLOOP_T24WL 26
#define DHWLOOP_TRL 27

#define DHWLOOP_NFIELDS 28  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirDHWLOOP[];				// DHWLOOP small fields-in-record table (srfd.cpp)

#define  makAncDHWLOOP(name)        anc<DHWLOOP> name( "DHWLoop", sfirDHWLOOP, DHWLOOP_NFIELDS, RTDHWLOOP) 
#define  makAncDHWLOOP2(name,what)  anc<DHWLOOP> name( what, sfirDHWLOOP, DHWLOOP_NFIELDS, RTDHWLOOP)	// 'what' override


/*--- PBC ---*/

// PBC record structure
struct PBC : public SBCBASE
 { 
    void sb_Init( PIPESEG* pPS);
    virtual int sb_Class() const;
    virtual double sb_AreaNet() const;
    virtual const char* sb_ParentName() const;
    PIPESEGP sb_pPS;
};		// PBC

// PBC field numbers (subscripts for PBC.sstat[] / sfirPBC[])
#define PBC_ABSSLR 0
#define PBC_AWABSSLR 1
#define PBC_EPSLW 2
#define PBC_ZI 3
#define PBC_F 4
#define PBC_FP 5
#define PBC_FRRAD 6
#define PBC_FSKY 7
#define PBC_FAIR 8
#define PBC_HCNAT 9
#define PBC_HCFRC 10
#define PBC_HCMULT 11
#define PBC_HXA 12
#define PBC_HXR 13
#define PBC_HXTOT 14
#define PBC_URAT 15
#define PBC_FRAT 16
#define PBC_CX 17
#define PBC_SGTARG 18
#define PBC_SG 21
#define PBC_TSRF 22
#define PBC_TSRFLS 23
#define PBC_QRABS 24
#define PBC_TXA 25
#define PBC_TXR 26
#define PBC_TXE 27
#define PBC_W 28
#define PBC_QSRF 29
#define PBC_PPS 30

#define PBC_NFIELDS 31  					// excludes rec start ovh; is # sstat[] bytes.



/*--- PIPERUN ---*/

// PIPERUN record structure
struct PIPERUN
 { 
    PIPERUN();
    float pr_DeriveSizeFromFlow( float flow, float desVel);
    float pr_GetOD( int bInsul) const;
    float pr_CalcUA( float fUA=1.f);
    float pr_SetBeta( float mCp, float fUA=1.f);
    float pr_TempOutlet( float tIn, float tEx) const { return pr_beta*tIn + (1.f-pr_beta)*tEx;}
    void pr_CalcGeom();
    float pr_CalcTOut( float tIn, float flow) const;
    FLOAT pr_len;
    FLOAT pr_size;
    FLOAT pr_insulK;
    FLOAT pr_insulThk;
    FLOAT pr_exH;
    SEGTOTS pr_totals;
    FLOAT pr_beta;
};		// PIPERUN

// PIPERUN field numbers (subscripts for PIPERUN.sstat[] / sfirPIPERUN[])
#define PIPERUN_LEN 0
#define PIPERUN_SIZE 1
#define PIPERUN_INSULK 2
#define PIPERUN_INSULTHK 3
#define PIPERUN_EXH 4
#define PIPERUN_TOTALS 5
#define PIPERUN_BETA 10

#define PIPERUN_NFIELDS 11  					// excludes rec start ovh; is # sstat[] bytes.



/*--- PIPESEG ---*/

// PIPESEG record class
class PIPESEG : public record 
{ public:
    PIPESEG( basAnc *_b, TI i, SI noZ=0);
    virtual ~PIPESEG() {} 
    PIPESEG& Copy( const PIPESEG& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    PIPESEG& operator=( const PIPESEG& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0) { record::Copy( pSrc, options); };

    float ps_CalcUA( float fUA=1.f);
    float ps_CalcTOut( float tIn, float flow) const;
    void ps_CalcGeom();
    float ps_GetOD( int bInsul) const;
    FLOAT ps_len;
    FLOAT ps_size;
    FLOAT ps_insulK;
    FLOAT ps_insulThk;
    FLOAT ps_exH;
    PBC ps_sbcO;
    EXCNDCH ps_exCnd;
    FLOAT ps_exT;
    SEGTOTS ps_totals;
    FLOAT ps_fRhoCpX;
    FLOAT ps_fvf;
    FLOAT ps_tIn;
    FLOAT ps_tOut;
    FLOAT ps_PLWF;
    FLOAT ps_PLCD;
    FLOAT ps_PL;
    unsigned char sstat[52];		// fld status bytes (base class excluded)
};		// PIPESEG

// PIPESEG field numbers (subscripts for PIPESEG.sstat[] / sfirPIPESEG[])
#define PIPESEG_NAME 0
#define PIPESEG_OWNTI 1
#define PIPESEG_LEN 2
#define PIPESEG_SIZE 3
#define PIPESEG_INSULK 4
#define PIPESEG_INSULTHK 5
#define PIPESEG_EXH 6
#define PIPESEG_SBCO 7
#define PIPESEG_EXCND 38
#define PIPESEG_EXT 39
#define PIPESEG_TOTALS 40
#define PIPESEG_FRHOCPX 45
#define PIPESEG_FVF 46
#define PIPESEG_TIN 47
#define PIPESEG_TOUT 48
#define PIPESEG_PLWF 49
#define PIPESEG_PLCD 50
#define PIPESEG_PL 51

#define PIPESEG_NFIELDS 52  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirPIPESEG[];				// PIPESEG small fields-in-record table (srfd.cpp)

#define  makAncPIPESEG(name)        anc<PIPESEG> name( "PipeSeg", sfirPIPESEG, PIPESEG_NFIELDS, RTPIPESEG) 
#define  makAncPIPESEG2(name,what)  anc<PIPESEG> name( what, sfirPIPESEG, PIPESEG_NFIELDS, RTPIPESEG)	// 'what' override


/*--- DHWLOOPSEG ---*/

// DHWLOOPSEG record class
class DHWLOOPSEG : public PIPESEG 
{ public:
    DHWLOOPSEG( basAnc *_b, TI i, SI noZ=0)  :  PIPESEG( _b, i, noZ)  {} 
    virtual ~DHWLOOPSEG() {} 
    DHWLOOPSEG& Copy( const DHWLOOPSEG& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    DHWLOOPSEG& operator=( const DHWLOOPSEG& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0) { record::Copy( pSrc, options); };

    RC wg_CkF();
    virtual RC RunDup( const record* pSrc, int options=0);
    RC wg_Init();
    DHWLOOPSEG* wg_GetInputDHWLOOPSEG() const;
    DHWLOOP* wg_GetDHWLOOP() const { return (DHWLOOP*)getOwner(); }
    DHWSYS* wg_GetDHWSYS() const;
    float wg_CalcUA();
    RC wg_DoHour( float tIn);
    DHWLSEGTYCH wg_ty;
    FLOAT wg_wbCount;
    FLOAT wg_fNoDraw;
    FLOAT wg_LL;
    FLOAT wg_BL;
    FLOAT wg_t24WL;
    unsigned char sstat[58];		// fld status bytes (base class excluded)
};		// DHWLOOPSEG

// DHWLOOPSEG field numbers (subscripts for DHWLOOPSEG.sstat[] / sfirDHWLOOPSEG[])
#define DHWLOOPSEG_NAME 0
#define DHWLOOPSEG_OWNTI 1
#define DHWLOOPSEG_LEN 2
#define DHWLOOPSEG_SIZE 3
#define DHWLOOPSEG_INSULK 4
#define DHWLOOPSEG_INSULTHK 5
#define DHWLOOPSEG_EXH 6
#define DHWLOOPSEG_SBCO 7
#define DHWLOOPSEG_EXCND 38
#define DHWLOOPSEG_EXT 39
#define DHWLOOPSEG_TOTALS 40
#define DHWLOOPSEG_FRHOCPX 45
#define DHWLOOPSEG_FVF 46
#define DHWLOOPSEG_TIN 47
#define DHWLOOPSEG_TOUT 48
#define DHWLOOPSEG_PLWF 49
#define DHWLOOPSEG_PLCD 50
#define DHWLOOPSEG_PL 51
#define DHWLOOPSEG_TY 52
#define DHWLOOPSEG_WBCOUNT 53
#define DHWLOOPSEG_FNODRAW 54
#define DHWLOOPSEG_LL 55
#define DHWLOOPSEG_BL 56
#define DHWLOOPSEG_T24WL 57

#define DHWLOOPSEG_NFIELDS 58  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirDHWLOOPSEG[];				// DHWLOOPSEG small fields-in-record table (srfd.cpp)

#define  makAncDHWLOOPSEG(name)        anc<DHWLOOPSEG> name( "DHWLoopSeg", sfirDHWLOOPSEG, DHWLOOPSEG_NFIELDS, RTDHWLOOPSEG) 
#define  makAncDHWLOOPSEG2(name,what)  anc<DHWLOOPSEG> name( what, sfirDHWLOOPSEG, DHWLOOPSEG_NFIELDS, RTDHWLOOPSEG)	// 'what' override


/*--- DHWLOOPBRANCH ---*/

// DHWLOOPBRANCH record class
class DHWLOOPBRANCH : public PIPESEG 
{ public:
    DHWLOOPBRANCH( basAnc *_b, TI i, SI noZ=0)  :  PIPESEG( _b, i, noZ)  {} 
    virtual ~DHWLOOPBRANCH() {} 
    DHWLOOPBRANCH& Copy( const DHWLOOPBRANCH& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    DHWLOOPBRANCH& operator=( const DHWLOOPBRANCH& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0) { record::Copy( pSrc, options); };

    RC wb_CkF();
    virtual RC RunDup( const record* pSrc, int options=0);
    RC wb_Init();
    DHWLOOPSEG* wb_GetDHWLOOPSEG() const { return (DHWLOOPSEG *)getOwner();}
    DHWLOOP* wb_GetDHWLOOP() const;
    DHWSYS* wb_GetDHWSYS() const;
    float wb_CalcUA();
    RC wb_DoHour( float tIn);
    FLOAT wb_mult;
    FLOAT wb_fUA;
    FLOAT wb_fWaste;
    FLOAT wb_flow;
    FLOAT wb_HBUL;
    FLOAT wb_HBWL;
    FLOAT wb_t24WL;
    unsigned char sstat[60];		// fld status bytes (base class excluded)
};		// DHWLOOPBRANCH

// DHWLOOPBRANCH field numbers (subscripts for DHWLOOPBRANCH.sstat[] / sfirDHWLOOPBRANCH[])
#define DHWLOOPBRANCH_NAME 0
#define DHWLOOPBRANCH_OWNTI 1
#define DHWLOOPBRANCH_LEN 2
#define DHWLOOPBRANCH_SIZE 3
#define DHWLOOPBRANCH_INSULK 4
#define DHWLOOPBRANCH_INSULTHK 5
#define DHWLOOPBRANCH_EXH 6
#define DHWLOOPBRANCH_SBCO 7
#define DHWLOOPBRANCH_EXCND 38
#define DHWLOOPBRANCH_EXT 39
#define DHWLOOPBRANCH_TOTALS 40
#define DHWLOOPBRANCH_FRHOCPX 45
#define DHWLOOPBRANCH_FVF 46
#define DHWLOOPBRANCH_TIN 47
#define DHWLOOPBRANCH_TOUT 48
#define DHWLOOPBRANCH_PLWF 49
#define DHWLOOPBRANCH_PLCD 50
#define DHWLOOPBRANCH_PL 51
#define DHWLOOPBRANCH_MULT 52
#define DHWLOOPBRANCH_FUA 53
#define DHWLOOPBRANCH_FWASTE 54
#define DHWLOOPBRANCH_FLOW 55
#define DHWLOOPBRANCH_HBUL 56
#define DHWLOOPBRANCH_HBWL 57
#define DHWLOOPBRANCH_T24WL 58

#define DHWLOOPBRANCH_NFIELDS 59  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirDHWLOOPBRANCH[];				// DHWLOOPBRANCH small fields-in-record table (srfd.cpp)

#define  makAncDHWLOOPBRANCH(name)        anc<DHWLOOPBRANCH> name( "DHWLoopBranch", sfirDHWLOOPBRANCH, DHWLOOPBRANCH_NFIELDS, RTDHWLOOPBRANCH) 
#define  makAncDHWLOOPBRANCH2(name,what)  anc<DHWLOOPBRANCH> name( what, sfirDHWLOOPBRANCH, DHWLOOPBRANCH_NFIELDS, RTDHWLOOPBRANCH)	// 'what' override


/*--- DHWLOOPPUMP ---*/

// DHWLOOPPUMP record class
class DHWLOOPPUMP : public DHWPUMP 
{ public:
    DHWLOOPPUMP( basAnc *_b, TI i, SI noZ=0)  :  DHWPUMP( _b, i, noZ)  {} 
    virtual ~DHWLOOPPUMP() {} 
    DHWLOOPPUMP& Copy( const DHWLOOPPUMP& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    DHWLOOPPUMP& operator=( const DHWLOOPPUMP& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0) { record::Copy( pSrc, options); };

    RC wlp_CkF();
    virtual RC RunDup( const record* pSrc, int options=0);
    DHWLOOP* wlp_GetDHWLOOP() const { return (DHWLOOP*)getOwner(); }
    DHWSYS* wlp_GetDHWSYS() const;
    SI wlp_dummy;
    unsigned char sstat[8];		// fld status bytes (base class excluded)
};		// DHWLOOPPUMP

// DHWLOOPPUMP field numbers (subscripts for DHWLOOPPUMP.sstat[] / sfirDHWLOOPPUMP[])
#define DHWLOOPPUMP_NAME 0
#define DHWLOOPPUMP_OWNTI 1
#define DHWLOOPPUMP_MULT 2
#define DHWLOOPPUMP_ELECMTRI 3
#define DHWLOOPPUMP_PWR 4
#define DHWLOOPPUMP_LIQHEATF 5
#define DHWLOOPPUMP_INELEC 6
#define DHWLOOPPUMP_DUMMY 7

#define DHWLOOPPUMP_NFIELDS 8  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirDHWLOOPPUMP[];				// DHWLOOPPUMP small fields-in-record table (srfd.cpp)

#define  makAncDHWLOOPPUMP(name)        anc<DHWLOOPPUMP> name( "DHWLoopPump", sfirDHWLOOPPUMP, DHWLOOPPUMP_NFIELDS, RTDHWLOOPPUMP) 
#define  makAncDHWLOOPPUMP2(name,what)  anc<DHWLOOPPUMP> name( what, sfirDHWLOOPPUMP, DHWLOOPPUMP_NFIELDS, RTDHWLOOPPUMP)	// 'what' override


/*--- DHWDAYUSE ---*/

// DHWDAYUSE record class
class DHWDAYUSE : public record 
{ public:
    DHWDAYUSE( basAnc *_b, TI i, SI noZ=0)  :  record( _b, i, noZ)  {} 
    virtual ~DHWDAYUSE() {} 
    DHWDAYUSE& Copy( const DHWDAYUSE& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    DHWDAYUSE& operator=( const DHWDAYUSE& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0) { record::Copy( pSrc, options); };

    RC wdu_CkF();
    RC wdu_Init( int pass);
    RC wdu_DoHour( DHWSYS* pWS) const;
    FLOAT wdu_mult;
    SI wdu_wuSsBeg;
    SI wdu_wuSsEnd;
    INT wdu_wuCount;
    unsigned char sstat[6];		// fld status bytes (base class excluded)
};		// DHWDAYUSE

// DHWDAYUSE field numbers (subscripts for DHWDAYUSE.sstat[] / sfirDHWDAYUSE[])
#define DHWDAYUSE_NAME 0
#define DHWDAYUSE_OWNTI 1
#define DHWDAYUSE_MULT 2
#define DHWDAYUSE_WUSSBEG 3
#define DHWDAYUSE_WUSSEND 4
#define DHWDAYUSE_WUCOUNT 5

#define DHWDAYUSE_NFIELDS 6  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirDHWDAYUSE[];				// DHWDAYUSE small fields-in-record table (srfd.cpp)

#define  makAncDHWDAYUSE(name)        anc<DHWDAYUSE> name( "DHWDayUse", sfirDHWDAYUSE, DHWDAYUSE_NFIELDS, RTDHWDAYUSE) 
#define  makAncDHWDAYUSE2(name,what)  anc<DHWDAYUSE> name( what, sfirDHWDAYUSE, DHWDAYUSE_NFIELDS, RTDHWDAYUSE)	// 'what' override


/*--- DHWUSE ---*/

// DHWUSE record class
class DHWUSE : public record 
{ public:
    DHWUSE( basAnc *_b, TI i, SI noZ=0)  :  record( _b, i, noZ)  {} 
    virtual ~DHWUSE() {} 
    DHWUSE& Copy( const DHWUSE& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    DHWUSE& operator=( const DHWUSE& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0) { record::Copy( pSrc, options); };

    RC wu_CkF();
    DHWDAYUSE* wu_GetDHWDAYUSE() const { return (DHWDAYUSE*)getOwner();}
    RC wu_DoHour( DHWSYS* pWS, float mult, int iH);
    RC wu_DoHour1( DHWSYS* pWS, float mult, int iH, double begM, double begMHot, double endM);
    RC wu_CalcHotF( float tHot, float tCold, float& hotF) const;
    DHWEUCH wu_hwEndUse;
    SI wu_eventID;
    FLOAT wu_start;
    FLOAT wu_dur;
    FLOAT wu_flow;
    FLOAT wu_hotF;
    FLOAT wu_temp;
    FLOAT wu_heatRecEF;
    INT wu_drawSeqN;
    unsigned char sstat[12];		// fld status bytes (base class excluded)
};		// DHWUSE

// DHWUSE field numbers (subscripts for DHWUSE.sstat[] / sfirDHWUSE[])
#define DHWUSE_NAME 0
#define DHWUSE_OWNTI 1
#define DHWUSE_HWENDUSE 2
#define DHWUSE_EVENTID 3
#define DHWUSE_START 4
#define DHWUSE_DUR 5
#define DHWUSE_FLOW 6
#define DHWUSE_HOTF 7
#define DHWUSE_TEMP 8
#define DHWUSE_HEATRECEF 9
#define DHWUSE_DRAWSEQN 10

#define DHWUSE_NFIELDS 11  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirDHWUSE[];				// DHWUSE small fields-in-record table (srfd.cpp)

#define  makAncDHWUSE(name)        anc<DHWUSE> name( "DHWUse", sfirDHWUSE, DHWUSE_NFIELDS, RTDHWUSE) 
#define  makAncDHWUSE2(name,what)  anc<DHWUSE> name( what, sfirDHWUSE, DHWUSE_NFIELDS, RTDHWUSE)	// 'what' override


/*--- DHWSOLARSYS ---*/

// DHWSOLARSYS record class
class DHWSOLARSYS : public record 
{ public:
    DHWSOLARSYS( basAnc *_b, TI i, SI noZ=0)  :  record( _b, i, noZ)  {} 
    virtual ~DHWSOLARSYS() {} 
    DHWSOLARSYS& Copy( const DHWSOLARSYS& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    DHWSOLARSYS& operator=( const DHWSOLARSYS& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0) { record::Copy( pSrc, options); };

    virtual void ReceiveRuntimeMessage(const char* msg);
    RC sw_CkF();
    RC sw_Init();
    RC sw_DoHour();
    RC sw_EndIvl( IVLCH ivl);
    RC sw_DoSubhrStart( int iTk0);
    RC sw_DoSubhrEnd();
    void sw_TickStart();
    RC sw_TickAccumDraw( DHWSYS* pWS, float vol, float tInlet);
    RC sw_TickCalc( int iTk);
    RC sw_DoSubhrTick(double vol, float tInlet, TI ws_ss, TI wh_ss, float& tOutlet);
    FLOAT sw_GetAvailableTemp();
    int sw_ReportBalErrorsIf() const;
    TI sw_elecMtri;
    ENDUSECH sw_endUse;
    MTR* sw_pMtrElec;
    FLOAT sw_parElec;
    INT sw_wsCount;
    FLOAT sw_scAreaTot;
    FLOAT sw_scCount;
    HPWHLINK sw_tank;
    FLOAT sw_tankVol;
    FLOAT sw_tankUA;
    FLOAT sw_tankInsulR;
    TI sw_tankZnTi;
    ZNR* sw_tankpZn;
    FLOAT sw_tankTEx;
    FLOAT sw_tankTAvg;
    FLOAT sw_tankQLoss;
    FLOAT sw_tankHXEff;
    FLOAT sw_tankTHxLimit;
    INT sw_overHeatTkCount;
    FLOAT sw_tickVol;
    FLOAT sw_tickVolT;
    FLOAT sw_tickTankTOutlet;
    FLOAT sw_drawVol;
    FLOAT sw_tankQGain;
    DBL sw_tankQGainTot;
    FLOAT sw_tankTInlet;
    FLOAT sw_tankTOutlet;
    FLOAT sw_tankTHx;
    FLOAT sw_totOut;
    FLOAT sw_scFluidSpHt;
    FLOAT sw_scFluidDens;
    FLOAT sw_scFluidVHC;
    FLOAT sw_scTInlet;
    FLOAT sw_scTOutlet;
    SI sw_overHeatHrCount;
    FLOAT sw_SSFAnnual;
    unsigned char sstat[58];		// fld status bytes (base class excluded)
};		// DHWSOLARSYS

// DHWSOLARSYS field numbers (subscripts for DHWSOLARSYS.sstat[] / sfirDHWSOLARSYS[])
#define DHWSOLARSYS_NAME 0
#define DHWSOLARSYS_OWNTI 1
#define DHWSOLARSYS_ELECMTRI 2
#define DHWSOLARSYS_ENDUSE 3
#define DHWSOLARSYS_PARELEC 4
#define DHWSOLARSYS_WSCOUNT 5
#define DHWSOLARSYS_SCAREATOT 6
#define DHWSOLARSYS_SCCOUNT 7
#define DHWSOLARSYS_TANK 8
#define DHWSOLARSYS_TANKVOL 31
#define DHWSOLARSYS_TANKUA 32
#define DHWSOLARSYS_TANKINSULR 33
#define DHWSOLARSYS_TANKZNTI 34
#define DHWSOLARSYS_TANKTEX 35
#define DHWSOLARSYS_TANKTAVG 36
#define DHWSOLARSYS_TANKQLOSS 37
#define DHWSOLARSYS_TANKHXEFF 38
#define DHWSOLARSYS_TANKTHXLIMIT 39
#define DHWSOLARSYS_OVERHEATTKCOUNT 40
#define DHWSOLARSYS_TICKVOL 41
#define DHWSOLARSYS_TICKVOLT 42
#define DHWSOLARSYS_TICKTANKTOUTLET 43
#define DHWSOLARSYS_DRAWVOL 44
#define DHWSOLARSYS_TANKQGAIN 45
#define DHWSOLARSYS_TANKQGAINTOT 46
#define DHWSOLARSYS_TANKTINLET 47
#define DHWSOLARSYS_TANKTOUTLET 48
#define DHWSOLARSYS_TANKTHX 49
#define DHWSOLARSYS_TOTOUT 50
#define DHWSOLARSYS_SCFLUIDSPHT 51
#define DHWSOLARSYS_SCFLUIDDENS 52
#define DHWSOLARSYS_SCFLUIDVHC 53
#define DHWSOLARSYS_SCTINLET 54
#define DHWSOLARSYS_SCTOUTLET 55
#define DHWSOLARSYS_OVERHEATHRCOUNT 56
#define DHWSOLARSYS_SSFANNUAL 57

#define DHWSOLARSYS_NFIELDS 58  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirDHWSOLARSYS[];				// DHWSOLARSYS small fields-in-record table (srfd.cpp)

#define  makAncDHWSOLARSYS(name)        anc<DHWSOLARSYS> name( "DHWSolarSys", sfirDHWSOLARSYS, DHWSOLARSYS_NFIELDS, RTDHWSOLARSYS) 
#define  makAncDHWSOLARSYS2(name,what)  anc<DHWSOLARSYS> name( what, sfirDHWSOLARSYS, DHWSOLARSYS_NFIELDS, RTDHWSOLARSYS)	// 'what' override


/*--- DHWSOLARCOLLECTOR ---*/

// DHWSOLARCOLLECTOR record class
class DHWSOLARCOLLECTOR : public record 
{ public:
    DHWSOLARCOLLECTOR( basAnc *_b, TI i, SI noZ=0)  :  record( _b, i, noZ)  {} 
    virtual ~DHWSOLARCOLLECTOR(); 
    DHWSOLARCOLLECTOR& Copy( const DHWSOLARCOLLECTOR& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    DHWSOLARCOLLECTOR& operator=( const DHWSOLARCOLLECTOR& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0) { record::Copy( pSrc, options); };

    RC sc_CkF();
    RC sc_Init();
    static float sc_Deriveb0( float ktaX, float incA);
    RC sc_InitIAM();
    float sc_Kta( float incA) const;
    float sc_FlowCorrection() const;
    RC sc_InitPiping();
    float sc_MCpTest() const;
    RC sc_DoHour();
    RC sc_DoHourEnd();
    float sc_TempOutlet( float tInlet, float& colEff) const;
    RC sc_DoSubhrTick();
    FLOAT sc_mult;
    FLOAT sc_multLR;
    FLOAT sc_area;
    FLOAT sc_tilt;
    FLOAT sc_azm;
    FLOAT sc_testFRUL;
    FLOAT sc_testFRTA;
    FLOAT sc_testMassFlow;
    FLOAT sc_oprMassFlow;
    FLOAT sc_kta60;
    PIPERUN sc_piping;
    FLOAT sc_pipingTEx;
    FLOAT sc_areaTot;
    FLOAT sc_flowCorrection;
    FLOAT sc_oprFRUL;
    FLOAT sc_oprFRTA;
    FLOAT sc_oprMCp;
    FLOAT sc_oprVolFlow;
    FLOAT sc_b0;
    FLOAT sc_ktaDS;
    FLOAT sc_ktaDG;
    FLOAT sc_incA;
    FLOAT sc_ktaDB;
    FLOAT sc_poaRadDB;
    FLOAT sc_poaRadDS;
    FLOAT sc_poaRadDG;
    FLOAT sc_poaRadTot;
    FLOAT sc_poaRadIAM;
    FLOAT sc_pumpPwr;
    FLOAT sc_tickPumpQ;
    FLOAT sc_pumpLiqHeatF;
    FLOAT sc_pumpDT;
    FLOAT sc_pumpOnDeltaT;
    FLOAT sc_pumpOffDeltaT;
    FLOAT sc_tOutletM;
    FLOAT sc_tOutletB;
    FLOAT sc_effM;
    FLOAT sc_effB;
    FLOAT sc_tInlet;
    FLOAT sc_eff;
    FLOAT sc_tickQFluid;
    FLOAT sc_hrQFluid;
    DBL sc_totQFluid;
    FLOAT sc_tOutletP;
    FLOAT sc_tOutlet;
    FLOAT sc_tickVol;
    INT sc_tickOp;
    FLOAT sc_pumpInElec;
    unsigned char sstat[60];		// fld status bytes (base class excluded)
};		// DHWSOLARCOLLECTOR

// DHWSOLARCOLLECTOR field numbers (subscripts for DHWSOLARCOLLECTOR.sstat[] / sfirDHWSOLARCOLLECTOR[])
#define DHWSOLARCOLLECTOR_NAME 0
#define DHWSOLARCOLLECTOR_OWNTI 1
#define DHWSOLARCOLLECTOR_MULT 2
#define DHWSOLARCOLLECTOR_MULTLR 3
#define DHWSOLARCOLLECTOR_AREA 4
#define DHWSOLARCOLLECTOR_TILT 5
#define DHWSOLARCOLLECTOR_AZM 6
#define DHWSOLARCOLLECTOR_TESTFRUL 7
#define DHWSOLARCOLLECTOR_TESTFRTA 8
#define DHWSOLARCOLLECTOR_TESTMASSFLOW 9
#define DHWSOLARCOLLECTOR_OPRMASSFLOW 10
#define DHWSOLARCOLLECTOR_KTA60 11
#define DHWSOLARCOLLECTOR_PIPING 12
#define DHWSOLARCOLLECTOR_PIPINGTEX 23
#define DHWSOLARCOLLECTOR_AREATOT 24
#define DHWSOLARCOLLECTOR_FLOWCORRECTION 25
#define DHWSOLARCOLLECTOR_OPRFRUL 26
#define DHWSOLARCOLLECTOR_OPRFRTA 27
#define DHWSOLARCOLLECTOR_OPRMCP 28
#define DHWSOLARCOLLECTOR_OPRVOLFLOW 29
#define DHWSOLARCOLLECTOR_B0 30
#define DHWSOLARCOLLECTOR_KTADS 31
#define DHWSOLARCOLLECTOR_KTADG 32
#define DHWSOLARCOLLECTOR_INCA 33
#define DHWSOLARCOLLECTOR_KTADB 34
#define DHWSOLARCOLLECTOR_POARADDB 35
#define DHWSOLARCOLLECTOR_POARADDS 36
#define DHWSOLARCOLLECTOR_POARADDG 37
#define DHWSOLARCOLLECTOR_POARADTOT 38
#define DHWSOLARCOLLECTOR_POARADIAM 39
#define DHWSOLARCOLLECTOR_PUMPPWR 40
#define DHWSOLARCOLLECTOR_TICKPUMPQ 41
#define DHWSOLARCOLLECTOR_PUMPLIQHEATF 42
#define DHWSOLARCOLLECTOR_PUMPDT 43
#define DHWSOLARCOLLECTOR_PUMPONDELTAT 44
#define DHWSOLARCOLLECTOR_PUMPOFFDELTAT 45
#define DHWSOLARCOLLECTOR_TOUTLETM 46
#define DHWSOLARCOLLECTOR_TOUTLETB 47
#define DHWSOLARCOLLECTOR_EFFM 48
#define DHWSOLARCOLLECTOR_EFFB 49
#define DHWSOLARCOLLECTOR_TINLET 50
#define DHWSOLARCOLLECTOR_EFF 51
#define DHWSOLARCOLLECTOR_TICKQFLUID 52
#define DHWSOLARCOLLECTOR_HRQFLUID 53
#define DHWSOLARCOLLECTOR_TOTQFLUID 54
#define DHWSOLARCOLLECTOR_TOUTLETP 55
#define DHWSOLARCOLLECTOR_TOUTLET 56
#define DHWSOLARCOLLECTOR_TICKVOL 57
#define DHWSOLARCOLLECTOR_TICKOP 58
#define DHWSOLARCOLLECTOR_PUMPINELEC 59

#define DHWSOLARCOLLECTOR_NFIELDS 60  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirDHWSOLARCOLLECTOR[];				// DHWSOLARCOLLECTOR small fields-in-record table (srfd.cpp)

#define  makAncDHWSOLARCOLLECTOR(name)        anc<DHWSOLARCOLLECTOR> name( "DHWSolarCollector", sfirDHWSOLARCOLLECTOR, DHWSOLARCOLLECTOR_NFIELDS, RTDHWSOLARCOLLECTOR) 
#define  makAncDHWSOLARCOLLECTOR2(name,what)  anc<DHWSOLARCOLLECTOR> name( what, sfirDHWSOLARCOLLECTOR, DHWSOLARCOLLECTOR_NFIELDS, RTDHWSOLARCOLLECTOR)	// 'what' override


/*--- PVARRAY ---*/

// PVARRAY record class
class PVARRAY : public record 
{ public:
    PVARRAY( basAnc *_b, TI i, SI noZ=0);
    virtual ~PVARRAY() {} 
    PVARRAY& Copy( const PVARRAY& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    PVARRAY& operator=( const PVARRAY& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0);

    virtual PVARRAY& CopyFrom( const record* src, int copyName=1, int dupPtrs=0);
    void FixUp();
    RC Validate( int options=0);
    RC pv_CkF();
    virtual RC RunDup( const record* pSrc, int options=0);
    int pv_HasPenumbraShading() const;
    int pv_AxisCount() const;
    RC pv_SetupShading( int& nS, const class CT3D* MT, int options=0) { return pv_g.gx_SetupShading( nS, MT, options);}
    void pv_ClearShading() { pv_g.gx_ClearShading(); }
    int pv_CalcBeamShading( float& cosi, float& fBeam) { return pv_g.gx_CalcBeamShading( cosi, fBeam);}
    RC pv_Init();
    RC pv_DoHour();
    RC pv_CalcPOA();
    RC pv_CalcCellTemp();
    RC pv_CalcNOCT();
    float pv_CalcConv(float tCell, float tAir, float vWind);
    RC pv_CalcRefr(float n1, float n2, float theta1, float& theta2, float& tau);
    float pv_CalcSkyTemp(float tAir);
    void pv_SetMTRPtrs();
    MTR* pv_pMtrElec;
    void* pv_ssc_data;
    SURFGEOM pv_g;
    TI pv_elecMtri;
    ENDUSECH pv_endUse;
    FLOAT pv_dcCap;
    PVMODCH pv_moduleType;
    FLOAT pv_tempCoeff;
    FLOAT pv_covRefrInd;
    PVARRCH pv_arrayType;
    FLOAT pv_tilt;
    FLOAT pv_azm;
    FLOAT pv_grndRefl;
    FLOAT pv_gcr;
    FLOAT pv_dcacRat;
    FLOAT pv_sif;
    FLOAT pv_invEff;
    FLOAT pv_sysLoss;
    FLOAT pv_tCell;
    FLOAT pv_aoi;
    FLOAT pv_panelTilt;
    FLOAT pv_panelAzm;
    FLOAT pv_panelRot;
    FLOAT pv_poa;
    FLOAT pv_poaBeam;
    FLOAT pv_radIBeam;
    FLOAT pv_radIBeamEff;
    FLOAT pv_radI;
    FLOAT pv_radIEff;
    FLOAT pv_radTrans;
    FLOAT pv_dcOut;
    FLOAT pv_acOut;
    FLOAT pv_tauNorm;
    FLOAT pv_inoct;
    FLOAT pv_convRatio;
    FLOAT pv_tGrndRatio;
    FLOAT pv_thermCap;
    FLOAT pv_radILs;
    FLOAT pv_tCellLs;
    SI pv_modMap;
    SI pv_arrMap;
    unsigned char sstat[82];		// fld status bytes (base class excluded)
};		// PVARRAY

// PVARRAY field numbers (subscripts for PVARRAY.sstat[] / sfirPVARRAY[])
#define PVARRAY_NAME 0
#define PVARRAY_OWNTI 1
#define PVARRAY_G 2
#define PVARRAY_ELECMTRI 44
#define PVARRAY_ENDUSE 45
#define PVARRAY_DCCAP 46
#define PVARRAY_MODULETYPE 47
#define PVARRAY_TEMPCOEFF 48
#define PVARRAY_COVREFRIND 49
#define PVARRAY_ARRAYTYPE 50
#define PVARRAY_TILT 51
#define PVARRAY_AZM 52
#define PVARRAY_GRNDREFL 53
#define PVARRAY_GCR 54
#define PVARRAY_DCACRAT 55
#define PVARRAY_SIF 56
#define PVARRAY_INVEFF 57
#define PVARRAY_SYSLOSS 58
#define PVARRAY_TCELL 59
#define PVARRAY_AOI 60
#define PVARRAY_PANELTILT 61
#define PVARRAY_PANELAZM 62
#define PVARRAY_PANELROT 63
#define PVARRAY_POA 64
#define PVARRAY_POABEAM 65
#define PVARRAY_RADIBEAM 66
#define PVARRAY_RADIBEAMEFF 67
#define PVARRAY_RADI 68
#define PVARRAY_RADIEFF 69
#define PVARRAY_RADTRANS 70
#define PVARRAY_DCOUT 71
#define PVARRAY_ACOUT 72
#define PVARRAY_TAUNORM 73
#define PVARRAY_INOCT 74
#define PVARRAY_CONVRATIO 75
#define PVARRAY_TGRNDRATIO 76
#define PVARRAY_THERMCAP 77
#define PVARRAY_RADILS 78
#define PVARRAY_TCELLLS 79
#define PVARRAY_MODMAP 80
#define PVARRAY_ARRMAP 81

#define PVARRAY_NFIELDS 82  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirPVARRAY[];				// PVARRAY small fields-in-record table (srfd.cpp)

#define  makAncPVARRAY(name)        anc<PVARRAY> name( "PVArray", sfirPVARRAY, PVARRAY_NFIELDS, RTPVARRAY) 
#define  makAncPVARRAY2(name,what)  anc<PVARRAY> name( what, sfirPVARRAY, PVARRAY_NFIELDS, RTPVARRAY)	// 'what' override


/*--- BATTERY ---*/

// BATTERY record class
class BATTERY : public record 
{ public:
    BATTERY( basAnc *_b, TI i, SI noZ=0)  :  record( _b, i, noZ)  {} 
    virtual ~BATTERY() {} 
    BATTERY& Copy( const BATTERY& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    BATTERY& operator=( const BATTERY& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0) { record::Copy( pSrc, options); };

    RC bt_CkF();
    virtual RC RunDup( const record* pSrc, int options=0);
    RC bt_Init();
    RC bt_DoHour( int stage);
    float bt_CalcAdjLoad(const MTR& m) const;
    float bt_ChgReqTDVPeakSave();
    TI bt_meter;
    ENDUSECH bt_endUse;
    NOYESCH bt_useUsrChg;
    BATCTRLALGVC bt_controlAlg;
    FLOAT bt_maxCap;
    FLOAT bt_initSOE;
    FLOAT bt_initCycles;
    FLOAT bt_chgEff;
    FLOAT bt_dschgEff;
    FLOAT bt_maxChgPwr;
    FLOAT bt_maxDschgPwr;
    FLOAT bt_chgReq;
    FLOAT bt_soeBegIvl;
    FLOAT bt_loadSeen;
    FLOAT bt_soe;
    FLOAT bt_soelh;
    FLOAT bt_cycles;
    FLOAT bt_cycleslh;
    FLOAT bt_energy;
    FLOAT bt_energylh;
    unsigned char sstat[22];		// fld status bytes (base class excluded)
};		// BATTERY

// BATTERY field numbers (subscripts for BATTERY.sstat[] / sfirBATTERY[])
#define BATTERY_NAME 0
#define BATTERY_OWNTI 1
#define BATTERY_METER 2
#define BATTERY_ENDUSE 3
#define BATTERY_USEUSRCHG 4
#define BATTERY_CONTROLALG 5
#define BATTERY_MAXCAP 6
#define BATTERY_INITSOE 7
#define BATTERY_INITCYCLES 8
#define BATTERY_CHGEFF 9
#define BATTERY_DSCHGEFF 10
#define BATTERY_MAXCHGPWR 11
#define BATTERY_MAXDSCHGPWR 12
#define BATTERY_CHGREQ 13
#define BATTERY_SOEBEGIVL 14
#define BATTERY_LOADSEEN 15
#define BATTERY_SOE 16
#define BATTERY_SOELH 17
#define BATTERY_CYCLES 18
#define BATTERY_CYCLESLH 19
#define BATTERY_ENERGY 20
#define BATTERY_ENERGYLH 21

#define BATTERY_NFIELDS 22  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirBATTERY[];				// BATTERY small fields-in-record table (srfd.cpp)

#define  makAncBATTERY(name)        anc<BATTERY> name( "Battery", sfirBATTERY, BATTERY_NFIELDS, RTBATTERY) 
#define  makAncBATTERY2(name,what)  anc<BATTERY> name( what, sfirBATTERY, BATTERY_NFIELDS, RTBATTERY)	// 'what' override


/*--- GAIN ---*/

// GAIN record class
class GAIN : public record 
{ public:
    GAIN( basAnc *_b, TI i, SI noZ=0)  :  record( _b, i, noZ)  {} 
    virtual ~GAIN() {} 
    GAIN& Copy( const GAIN& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    GAIN& operator=( const GAIN& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0) { record::Copy( pSrc, options); };

    virtual RC RunDup( const record* pSrc, int options=0);
    RC gn_CkF( int options);
    RC gn_DoHour() const;
    FLOAT gnPower;
    TI mtri;
    ENDUSECH gnEndUse;
    FLOAT gnFrLat;
    FLOAT gnFrRad;
    FLOAT gnFrZn;
    FLOAT gnFrPl;
    FLOAT gnFrRtn;
    FLOAT gnDlFrPow;
    TI gn_dhwsysi;
    TI gn_dhwmtri;
    DHWEUXCH gn_dhwEndUse;
    unsigned char sstat[14];		// fld status bytes (base class excluded)
};		// GAIN

// GAIN field numbers (subscripts for GAIN.sstat[] / sfirGAIN[])
#define GAIN_NAME 0
#define GAIN_OWNTI 1
#define GAIN_GNPOWER 2
#define GAIN_MTRI 3
#define GAIN_GNENDUSE 4
#define GAIN_GNFRLAT 5
#define GAIN_GNFRRAD 6
#define GAIN_GNFRZN 7
#define GAIN_GNFRPL 8
#define GAIN_GNFRRTN 9
#define GAIN_GNDLFRPOW 10
#define GAIN_DHWSYSI 11
#define GAIN_DHWMTRI 12
#define GAIN_DHWENDUSE 13

#define GAIN_NFIELDS 14  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirGAIN[];				// GAIN small fields-in-record table (srfd.cpp)

#define  makAncGAIN(name)        anc<GAIN> name( "gain", sfirGAIN, GAIN_NFIELDS, RTGAIN) 
#define  makAncGAIN2(name,what)  anc<GAIN> name( what, sfirGAIN, GAIN_NFIELDS, RTGAIN)	// 'what' override


/*--- MTR_IVL_SUB ---*/

// MTR_IVL_SUB record structure
struct MTR_IVL_SUB
 { 
    void mtr_Accum( ENDUSECH eu, float v) { if (eu) (&clg)[ eu-1] += v; }
    void mtr_Accum1( const MTR_IVL_SUB* mtrSub1, IVLCH ivl, int options=0);
    double mtr_NetBldgLoad() const;
    RC mtr_Validate() const;
    FLOAT tot;
    FLOAT clg;
    FLOAT htg;
    FLOAT hpBU;
    FLOAT dhw;
    FLOAT dhwBU;
    FLOAT dhwMFL;
    FLOAT fanC;
    FLOAT fanH;
    FLOAT fanV;
    FLOAT fan;
    FLOAT aux;
    FLOAT proc;
    FLOAT lit;
    FLOAT rcp;
    FLOAT ext;
    FLOAT refr;
    FLOAT dish;
    FLOAT dry;
    FLOAT wash;
    FLOAT cook;
    FLOAT usr1;
    FLOAT usr2;
    FLOAT bt;
    FLOAT pv;
    FLOAT allEU;
    FLOAT cost;
    FLOAT dmdCost;
    FLOAT dmd;
    SHOY dmdShoy;
};		// MTR_IVL_SUB

// MTR_IVL_SUB field numbers (subscripts for MTR_IVL_SUB.sstat[] / sfirMTR_IVL_SUB[])
#define MTR_IVL_SUB_TOT 0
#define MTR_IVL_SUB_CLG 1
#define MTR_IVL_SUB_HTG 2
#define MTR_IVL_SUB_HPBU 3
#define MTR_IVL_SUB_DHW 4
#define MTR_IVL_SUB_DHWBU 5
#define MTR_IVL_SUB_DHWMFL 6
#define MTR_IVL_SUB_FANC 7
#define MTR_IVL_SUB_FANH 8
#define MTR_IVL_SUB_FANV 9
#define MTR_IVL_SUB_FAN 10
#define MTR_IVL_SUB_AUX 11
#define MTR_IVL_SUB_PROC 12
#define MTR_IVL_SUB_LIT 13
#define MTR_IVL_SUB_RCP 14
#define MTR_IVL_SUB_EXT 15
#define MTR_IVL_SUB_REFR 16
#define MTR_IVL_SUB_DISH 17
#define MTR_IVL_SUB_DRY 18
#define MTR_IVL_SUB_WASH 19
#define MTR_IVL_SUB_COOK 20
#define MTR_IVL_SUB_USR1 21
#define MTR_IVL_SUB_USR2 22
#define MTR_IVL_SUB_BT 23
#define MTR_IVL_SUB_PV 24
#define MTR_IVL_SUB_ALLEU 25
#define MTR_IVL_SUB_COST 26
#define MTR_IVL_SUB_DMDCOST 27
#define MTR_IVL_SUB_DMD 28
#define MTR_IVL_SUB_DMDSHOY 29

#define MTR_IVL_SUB_NFIELDS 30  					// excludes rec start ovh; is # sstat[] bytes.



/*--- MTR ---*/

// MTR record class
class MTR : public record 
{ public:
    MTR( basAnc *_b, TI i, SI noZ=0)  :  record( _b, i, noZ)  {} 
    virtual ~MTR() {} 
    MTR& Copy( const MTR& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    MTR& operator=( const MTR& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0) { record::Copy( pSrc, options); };

    FLOAT rate;
    FLOAT dmdRate;
    void mtr_HrInit();
    MTR_IVL_SUB Y;
    MTR_IVL_SUB M;
    MTR_IVL_SUB D;
    MTR_IVL_SUB H;
    unsigned char sstat[124];		// fld status bytes (base class excluded)
};		// MTR

// MTR field numbers (subscripts for MTR.sstat[] / sfirMTR[])
#define MTR_NAME 0
#define MTR_OWNTI 1
#define MTR_RATE 2
#define MTR_DMDRATE 3
#define MTR_Y 4
#define MTR_M 34
#define MTR_D 64
#define MTR_H 94

#define MTR_NFIELDS 124  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirMTR[];				// MTR small fields-in-record table (srfd.cpp)

#define  makAncMTR(name)        anc<MTR> name( "meter", sfirMTR, MTR_NFIELDS, RTMTR) 
#define  makAncMTR2(name,what)  anc<MTR> name( what, sfirMTR, MTR_NFIELDS, RTMTR)	// 'what' override


/*--- HDAY ---*/

// HDAY record class
class HDAY : public record 
{ public:
    HDAY( basAnc *_b, TI i, SI noZ=0)  :  record( _b, i, noZ)  {} 
    virtual ~HDAY() {} 
    HDAY& Copy( const HDAY& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    HDAY& operator=( const HDAY& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0) { record::Copy( pSrc, options); };

    DOY hdDateTrue;
    DOY hdDateObs;
    NOYESCH hdOnMonday;
    HDAYCASECH hdCase;
    DOWCH hdDow;
    MONCH hdMon;
    unsigned char sstat[8];		// fld status bytes (base class excluded)
};		// HDAY

// HDAY field numbers (subscripts for HDAY.sstat[] / sfirHDAY[])
#define HDAY_NAME 0
#define HDAY_OWNTI 1
#define HDAY_HDDATETRUE 2
#define HDAY_HDDATEOBS 3
#define HDAY_HDONMONDAY 4
#define HDAY_HDCASE 5
#define HDAY_HDDOW 6
#define HDAY_HDMON 7

#define HDAY_NFIELDS 8  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirHDAY[];				// HDAY small fields-in-record table (srfd.cpp)

#define  makAncHDAY(name)        anc<HDAY> name( "holiday", sfirHDAY, HDAY_NFIELDS, RTHDAY) 
#define  makAncHDAY2(name,what)  anc<HDAY> name( what, sfirHDAY, HDAY_NFIELDS, RTHDAY)	// 'what' override


/*--- COIL ---*/

// COIL record structure
struct COIL
 { 
    RC setup( COILAPPCH app, record *r, SI coilFn, BOO rqd, BOO prohib);
    COILTYCH coilTy;
    OFFAVAILVC sched;
    FLOAT captRat;
    FLOAT captRat_As;
    FLOAT captRat_AsNov;
    FLOAT bCaptRat;
    FLOAT eirRat;
    TI mtri;
    FLOAT auxOn;
    TI auxOnMtri;
    FLOAT auxOff;
    TI auxOffMtri;
    FLOAT auxOnAtall;
    TI auxOnAtallMtri;
    FLOAT auxFullOff;
    TI auxFullOffMtri;
    FLOAT q;
    FLOAT qPr;
    FLOAT p;
    FLOAT plr;
    FLOAT plrAv;
    FLOAT eir;
    FLOAT pAuxOn;
    FLOAT pAuxOff;
    FLOAT pAuxOnAtall;
    FLOAT pAuxFullOff;
    BOO notDone;
};		// COIL

// COIL field numbers (subscripts for COIL.sstat[] / sfirCOIL[])
#define COIL_COILTY 0
#define COIL_SCHED 1
#define COIL_CAPTRAT 2
#define COIL_CAPTRAT_AS 3
#define COIL_CAPTRAT_ASNOV 4
#define COIL_BCAPTRAT 5
#define COIL_EIRRAT 6
#define COIL_MTRI 7
#define COIL_AUXON 8
#define COIL_AUXONMTRI 9
#define COIL_AUXOFF 10
#define COIL_AUXOFFMTRI 11
#define COIL_AUXONATALL 12
#define COIL_AUXONATALLMTRI 13
#define COIL_AUXFULLOFF 14
#define COIL_AUXFULLOFFMTRI 15
#define COIL_Q 16
#define COIL_QPR 17
#define COIL_P 18
#define COIL_PLR 19
#define COIL_PLRAV 20
#define COIL_EIR 21
#define COIL_PAUXON 22
#define COIL_PAUXOFF 23
#define COIL_PAUXONATALL 24
#define COIL_PAUXFULLOFF 25
#define COIL_NOTDONE 26

#define COIL_NFIELDS 27  					// excludes rec start ovh; is # sstat[] bytes.



/*--- COOLCOIL ---*/

// COOLCOIL record structure
struct COOLCOIL : public COIL
 { 
    RC setup( COILAPPCH app, record *r, SI coilFn, BOO rqd, BOO prohib);
    RC reSetup( AH *ah);
    RC setup(AH *ah);
    RC chwSetup(AH *ah);
    RC dxSetup(AH *ah);
    FLOAT capsRat;
    FLOAT capsRat_As;
    FLOAT capsRat_AsNov;
    FLOAT minTEvap;
    FLOAT k1;
    FLOAT dsTDbCnd;
    FLOAT dsTDbEn;
    FLOAT dsTWbEn;
    FLOAT vfR;
    FLOAT vfRperTon;
    FLOAT minUnldPlr;
    FLOAT minFsldPlr;
    PYBIQUAD pydxCaptT;
    PYCUBIC pydxCaptF;
    FLOAT pydxCaptFLim;
    PYBIQUAD pydxEirT;
    PYCUBIC pydxEirUl;
    TI cpi;
    FLOAT gpmDs;
    FLOAT ntuoDs;
    FLOAT ntuiDs;
    DBL wsatMinTEvap;
    DBL hsatMinTEvap;
    DBL efecOR;
    DBL ntuR;
    DBL eirMinUnldPlr;
    DBL menR;
    TI nxAh4cp;
    DBL mwDs;
    BOO wantQflag;
    DBL tewd;
    DBL chwQ;
    DBL tr;
    FLOAT cpTsPr;
    FLOAT trPr;
    BOO fullLoadWet;
    DBL frCprOn;
    DBL tWbEn;
    DBL hen;
    DBL tDbCnd;
    DBL efecO;
    DBL capt;
    DBL caps;
    DBL plrVf;
    DBL plrSens;
    DBL qs;
    DBL ql;
    FLOAT xLGain;
    FLOAT xLGainYr;
    LI nSubhrsLX;
    BOO minTLtd;
    BOO cfm2Few;
};		// COOLCOIL

// COOLCOIL field numbers (subscripts for COOLCOIL.sstat[] / sfirCOOLCOIL[])
#define COOLCOIL_COILTY 0
#define COOLCOIL_SCHED 1
#define COOLCOIL_CAPTRAT 2
#define COOLCOIL_CAPTRAT_AS 3
#define COOLCOIL_CAPTRAT_ASNOV 4
#define COOLCOIL_BCAPTRAT 5
#define COOLCOIL_EIRRAT 6
#define COOLCOIL_MTRI 7
#define COOLCOIL_AUXON 8
#define COOLCOIL_AUXONMTRI 9
#define COOLCOIL_AUXOFF 10
#define COOLCOIL_AUXOFFMTRI 11
#define COOLCOIL_AUXONATALL 12
#define COOLCOIL_AUXONATALLMTRI 13
#define COOLCOIL_AUXFULLOFF 14
#define COOLCOIL_AUXFULLOFFMTRI 15
#define COOLCOIL_Q 16
#define COOLCOIL_QPR 17
#define COOLCOIL_P 18
#define COOLCOIL_PLR 19
#define COOLCOIL_PLRAV 20
#define COOLCOIL_EIR 21
#define COOLCOIL_PAUXON 22
#define COOLCOIL_PAUXOFF 23
#define COOLCOIL_PAUXONATALL 24
#define COOLCOIL_PAUXFULLOFF 25
#define COOLCOIL_NOTDONE 26
#define COOLCOIL_CAPSRAT 27
#define COOLCOIL_CAPSRAT_AS 28
#define COOLCOIL_CAPSRAT_ASNOV 29
#define COOLCOIL_MINTEVAP 30
#define COOLCOIL_K1 31
#define COOLCOIL_DSTDBCND 32
#define COOLCOIL_DSTDBEN 33
#define COOLCOIL_DSTWBEN 34
#define COOLCOIL_VFR 35
#define COOLCOIL_VFRPERTON 36
#define COOLCOIL_MINUNLDPLR 37
#define COOLCOIL_MINFSLDPLR 38
#define COOLCOIL_PYDXCAPTT 39
#define COOLCOIL_PYDXCAPTF 46
#define COOLCOIL_PYDXCAPTFLIM 51
#define COOLCOIL_PYDXEIRT 52
#define COOLCOIL_PYDXEIRUL 59
#define COOLCOIL_CPI 64
#define COOLCOIL_GPMDS 65
#define COOLCOIL_NTUODS 66
#define COOLCOIL_NTUIDS 67
#define COOLCOIL_WSATMINTEVAP 68
#define COOLCOIL_HSATMINTEVAP 69
#define COOLCOIL_EFECOR 70
#define COOLCOIL_NTUR 71
#define COOLCOIL_EIRMINUNLDPLR 72
#define COOLCOIL_MENR 73
#define COOLCOIL_NXAH4CP 74
#define COOLCOIL_MWDS 75
#define COOLCOIL_WANTQFLAG 76
#define COOLCOIL_TEWD 77
#define COOLCOIL_CHWQ 78
#define COOLCOIL_TR 79
#define COOLCOIL_CPTSPR 80
#define COOLCOIL_TRPR 81
#define COOLCOIL_FULLLOADWET 82
#define COOLCOIL_FRCPRON 83
#define COOLCOIL_TWBEN 84
#define COOLCOIL_HEN 85
#define COOLCOIL_TDBCND 86
#define COOLCOIL_EFECO 87
#define COOLCOIL_CAPT 88
#define COOLCOIL_CAPS 89
#define COOLCOIL_PLRVF 90
#define COOLCOIL_PLRSENS 91
#define COOLCOIL_QS 92
#define COOLCOIL_QL 93
#define COOLCOIL_XLGAIN 94
#define COOLCOIL_XLGAINYR 95
#define COOLCOIL_NSUBHRSLX 96
#define COOLCOIL_MINTLTD 97
#define COOLCOIL_CFM2FEW 98

#define COOLCOIL_NFIELDS 99  					// excludes rec start ovh; is # sstat[] bytes.



/*--- HEATCOIL ---*/

// HEATCOIL record structure
struct HEATCOIL : public COIL
 { 
    RC setup( COILAPPCH app, record *r, SI coilFn, BOO rqd, BOO prohib, BOO isAhh=FALSE);
    FLOAT effRat;
    PYCUBIC pyEi;
    FLOAT stackEffect;
    TI hpi;
    TI nxTu4hp;
    TI nxAh4hp;
    FLOAT flueLoss;
    FLOAT qWant;
};		// HEATCOIL

// HEATCOIL field numbers (subscripts for HEATCOIL.sstat[] / sfirHEATCOIL[])
#define HEATCOIL_COILTY 0
#define HEATCOIL_SCHED 1
#define HEATCOIL_CAPTRAT 2
#define HEATCOIL_CAPTRAT_AS 3
#define HEATCOIL_CAPTRAT_ASNOV 4
#define HEATCOIL_BCAPTRAT 5
#define HEATCOIL_EIRRAT 6
#define HEATCOIL_MTRI 7
#define HEATCOIL_AUXON 8
#define HEATCOIL_AUXONMTRI 9
#define HEATCOIL_AUXOFF 10
#define HEATCOIL_AUXOFFMTRI 11
#define HEATCOIL_AUXONATALL 12
#define HEATCOIL_AUXONATALLMTRI 13
#define HEATCOIL_AUXFULLOFF 14
#define HEATCOIL_AUXFULLOFFMTRI 15
#define HEATCOIL_Q 16
#define HEATCOIL_QPR 17
#define HEATCOIL_P 18
#define HEATCOIL_PLR 19
#define HEATCOIL_PLRAV 20
#define HEATCOIL_EIR 21
#define HEATCOIL_PAUXON 22
#define HEATCOIL_PAUXOFF 23
#define HEATCOIL_PAUXONATALL 24
#define HEATCOIL_PAUXFULLOFF 25
#define HEATCOIL_NOTDONE 26
#define HEATCOIL_EFFRAT 27
#define HEATCOIL_PYEI 28
#define HEATCOIL_STACKEFFECT 33
#define HEATCOIL_HPI 34
#define HEATCOIL_NXTU4HP 35
#define HEATCOIL_NXAH4HP 36
#define HEATCOIL_FLUELOSS 37
#define HEATCOIL_QWANT 38

#define HEATCOIL_NFIELDS 39  					// excludes rec start ovh; is # sstat[] bytes.



/*--- AHHEATCOIL ---*/

// AHHEATCOIL record structure
struct AHHEATCOIL : public HEATCOIL
 { 
    RC setup( COILAPPCH app, record *r, SI coilFn, BOO rqd, BOO prohib);
    RC reSetup( AH *ah);
    RC setup( AH *ah);
    DBL cprCapCon( FLOAT tout);
    void doAhpHeat( BOO &coilLimited, AH *ah);
    FLOAT cap17;
    FLOAT cap47;
    FLOAT cap35;
    FLOAT fd35Df;
    FLOAT capIa;
    FLOAT supRh;
    FLOAT tFrMn;
    FLOAT tFrMx;
    FLOAT tFrPk;
    FLOAT dfrFMn;
    FLOAT dfrFMx;
    FLOAT dfrCap;
    FLOAT dfrRh;
    FLOAT tOff;
    FLOAT tOn;
    FLOAT in17;
    FLOAT in47;
    FLOAT inIa;
    FLOAT cd;
    #define tmCycOn  (.1)		// time on  (hours) in ARI cycling performance test
    #define tmCycOff (.4)		// time off (hours) in ARI cycling performance test
    #define tmCycPer (tmCycOn + tmCycOff)	// total cycle time of ARI cycling test
    FLOAT in17c;
    FLOAT in47c;
    FLOAT cdm;
    FLOAT tIa;
    FLOAT qSupLim;
    DBL frFanOn;
    BOO loTLockout;
    BOO supOn;
    FLOAT capCon;
    FLOAT pDfrhCon;
    FLOAT cap;
    FLOAT frCprOn;
    FLOAT pCpr;
    FLOAT pRh;
};		// AHHEATCOIL

// AHHEATCOIL field numbers (subscripts for AHHEATCOIL.sstat[] / sfirAHHEATCOIL[])
#define AHHEATCOIL_COILTY 0
#define AHHEATCOIL_SCHED 1
#define AHHEATCOIL_CAPTRAT 2
#define AHHEATCOIL_CAPTRAT_AS 3
#define AHHEATCOIL_CAPTRAT_ASNOV 4
#define AHHEATCOIL_BCAPTRAT 5
#define AHHEATCOIL_EIRRAT 6
#define AHHEATCOIL_MTRI 7
#define AHHEATCOIL_AUXON 8
#define AHHEATCOIL_AUXONMTRI 9
#define AHHEATCOIL_AUXOFF 10
#define AHHEATCOIL_AUXOFFMTRI 11
#define AHHEATCOIL_AUXONATALL 12
#define AHHEATCOIL_AUXONATALLMTRI 13
#define AHHEATCOIL_AUXFULLOFF 14
#define AHHEATCOIL_AUXFULLOFFMTRI 15
#define AHHEATCOIL_Q 16
#define AHHEATCOIL_QPR 17
#define AHHEATCOIL_P 18
#define AHHEATCOIL_PLR 19
#define AHHEATCOIL_PLRAV 20
#define AHHEATCOIL_EIR 21
#define AHHEATCOIL_PAUXON 22
#define AHHEATCOIL_PAUXOFF 23
#define AHHEATCOIL_PAUXONATALL 24
#define AHHEATCOIL_PAUXFULLOFF 25
#define AHHEATCOIL_NOTDONE 26
#define AHHEATCOIL_EFFRAT 27
#define AHHEATCOIL_PYEI 28
#define AHHEATCOIL_STACKEFFECT 33
#define AHHEATCOIL_HPI 34
#define AHHEATCOIL_NXTU4HP 35
#define AHHEATCOIL_NXAH4HP 36
#define AHHEATCOIL_FLUELOSS 37
#define AHHEATCOIL_QWANT 38
#define AHHEATCOIL_CAP17 39
#define AHHEATCOIL_CAP47 40
#define AHHEATCOIL_CAP35 41
#define AHHEATCOIL_FD35DF 42
#define AHHEATCOIL_CAPIA 43
#define AHHEATCOIL_SUPRH 44
#define AHHEATCOIL_TFRMN 45
#define AHHEATCOIL_TFRMX 46
#define AHHEATCOIL_TFRPK 47
#define AHHEATCOIL_DFRFMN 48
#define AHHEATCOIL_DFRFMX 49
#define AHHEATCOIL_DFRCAP 50
#define AHHEATCOIL_DFRRH 51
#define AHHEATCOIL_TOFF 52
#define AHHEATCOIL_TON 53
#define AHHEATCOIL_IN17 54
#define AHHEATCOIL_IN47 55
#define AHHEATCOIL_INIA 56
#define AHHEATCOIL_CD 57
#define AHHEATCOIL_IN17C 58
#define AHHEATCOIL_IN47C 59
#define AHHEATCOIL_CDM 60
#define AHHEATCOIL_TIA 61
#define AHHEATCOIL_QSUPLIM 62
#define AHHEATCOIL_FRFANON 63
#define AHHEATCOIL_LOTLOCKOUT 64
#define AHHEATCOIL_SUPON 65
#define AHHEATCOIL_CAPCON 66
#define AHHEATCOIL_PDFRHCON 67
#define AHHEATCOIL_CAP 68
#define AHHEATCOIL_FRCPRON 69
#define AHHEATCOIL_PCPR 70
#define AHHEATCOIL_PRH 71

#define AHHEATCOIL_NFIELDS 72  					// excludes rec start ovh; is # sstat[] bytes.



/*--- CCH ---*/

// CCH record structure
struct CCH
 { 
    RC setup( AH *ah, SI cchFn);
    void endSubhr();
    CCHCM cchCM;
    FLOAT pMx;
    FLOAT pMn;
    FLOAT tMx;
    FLOAT tMn;
    FLOAT dt;
    FLOAT tOn;
    FLOAT tOff;
    TI mtri;
    FLOAT p47Off;
    FLOAT p17;
    FLOAT p47;
    FLOAT frCprOn;
    BOO tState;
    FLOAT p;
};		// CCH

// CCH field numbers (subscripts for CCH.sstat[] / sfirCCH[])
#define CCH_CCHCM 0
#define CCH_PMX 1
#define CCH_PMN 2
#define CCH_TMX 3
#define CCH_TMN 4
#define CCH_DT 5
#define CCH_TON 6
#define CCH_TOFF 7
#define CCH_MTRI 8
#define CCH_P47OFF 9
#define CCH_P17 10
#define CCH_P47 11
#define CCH_FRCPRON 12
#define CCH_TSTATE 13
#define CCH_P 14

#define CCH_NFIELDS 15  					// excludes rec start ovh; is # sstat[] bytes.



/*--- AH ---*/

// AH record class
class AH : public record 
{ public:
    AH( basAnc *_b, TI i, SI noZ=0)  :  record( _b, i, noZ)  {} 
    virtual ~AH() {} 
    AH& Copy( const AH& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    AH& operator=( const AH& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0) { record::Copy( pSrc, options); };

    RC setup();
    void fazInit( int isAusz);
    RC rddInit( int isAusz);
    RC ah_pass1AtoB();
    RC ah_begP1b();
    void rddiInit();
    RC ah_SetupSizes();
    void ah_p2Init();
    void endP2Dsd();
    RC ah_p2EndTest();
    RC ah_endAutosize();
    void ah_auszFinal();
    RC begSubhr();
    RC endSubhr();
    RC ah_AfterSubhr();
    RC begHour();
    RC ahEstimate();
    RC ahCompute();
    BOO iter4Fs( BOO &cvgFail);
    void pute4Fs();
    void setFrFanOn( DBL leakCOn);
    BOO incrFanF();
    BOO decrFanF();
    BOO fanXtrap( SI whichway);
    BOO ceeClip( BOO canClip);
    BOO converger();
    BOO binClip();
    void getTsXtrapBounds(DBL d);
    BOO humXtrap();
    BOO humXtrap2();
    BOO humXtrapI( DBL r, char x);
    void doOa();
    void doEco();
    DBL getTsMnFo( BOO outsideCall);
    DBL getTsMxFo( BOO outsideCall);
    DBL tsFo( float approach,  BOO outsideCall);
    DBL tsfo( DBL _tr, DBL _cr);
    BOO tsPoss( DBL _tr, DBL _wr, DBL _cr, int want, DBL & _ts);
    BOO resizeFansIf( float _cMx, float vfDsWas);
    RC setMode();
    BOO setTsSp1( BOO est, DBL &tsOut);
    void wzczSp( BOO est, BOO cooling, BOO maxIt, DBL llim, DBL ulim, TU *ctu, DBL &tTsSp, FLOAT &cznC);
    void zRat();
    void antRatTs();
    void puteRa();
    BOO flagTusIf();
    void flagChanges();
    void upCouple( DBL ts, DBL tsWas, DBL ws, DBL wsWas);
    void upPriors();
    void ahVshNLims( DBL _ts, DBL &cIncr, DBL &cDecr);
    void flagTus();
    BOO nxTu(TU *&tu);
    BOO nxZhx( ZHX *&x);
    BOO nxZn( ZNR *&zp);
    BOO nxTsCzn( ZNR *&z);
    BOO resizeHeatCoilIf( float capt, float captWas);
    BOO resizeCoolCoilIf( float capt, float captWas);
    BOO estCoils( DBL _ten, DBL _wen, DBL _cen, DBL _frFanOn, BOO _coilLockout, int cooling, DBL &_tex, DBL &_wex);
    BOO doCoils( DBL texWant, DBL &lLim, DBL &uLim);
    float coolCapThing( float captWant);
    BOO doHWCoil( DBL texWant, DBL &llLim, DBL &uLim );
    BOO doElecHeatCoil( DBL texWant, DBL &llLim, DBL &uLim );
    BOO doGasOrOilFurn( DBL texWant, DBL &llLim, DBL &uLim );
    BOO doAhpHeatCoil(  DBL texWant, DBL &llLim, DBL &uLim );
    float heatCapThing( float captWant);
    BOO doElecCoolCoil( DBL texWant1, DBL texWant, DBL &llLim, DBL &uLim );
    BOO doChwCoil( DBL texWant1, DBL texWant, DBL &lLim, DBL &uLim);
    BOO doDxCoil( DBL texWant1, DBL texWant, DBL &llLim, DBL &uLim );
    void coilsEndSubhr();
    FLOAT ahTsDsH;
    FLOAT ahTsDsC;
    FLOAT ahccSHR;
    FLOAT coilOversize;
    FLOAT fanOversize;
    BOO asRfan;
    BOO asFlow;
    AUSZ hcAs;
    AUSZ ccAs;
    AUSZ fanAs;
    FLOAT bVfDs;
    FLOAT qcPkS;
    FLOAT qcPkL;
    SI qcPkH;
    SI qcPkD;
    SI qcPkM;
    FLOAT qcPkTDbO;
    FLOAT qcPkWO;
    FLOAT qcPkTen;
    FLOAT qcPkWen;
    FLOAT qcPkTex;
    FLOAT qcPkWex;
    FLOAT qcPkSAs;
    FLOAT qcPkLAs;
    SI qcPkHAs;
    SI qcPkDAs;
    SI qcPkMAs;
    FLOAT qcPkTDbOAs;
    FLOAT qcPkWOAs;
    FLOAT qcPkTenAs;
    FLOAT qcPkWenAs;
    FLOAT qcPkTexAs;
    FLOAT qcPkWexAs;
    TSCMNC ahTsSp;
    NOYESVC ahFanCycles;
    FLOAT ahTsMn;
    FLOAT ahTsMx;
    FLOAT ahTsRaMn;
    FLOAT ahTsRaMx;
    TI ahCtu;
    TI ahWzCzns[16];
    TI ahCzCzns[16];
    OAMNCH oaMnCm;
    FLOAT oaMnFrac;
    FLOAT oaVfDsMn;
    ECOTYCH oaEcoTy;
    RANC oaLimT;
    RANC oaLimE;
    FLOAT oaOaLeak;
    FLOAT oaRaLeak;
    FLOAT ahSOLeak;
    FLOAT ahROLeak;
    FLOAT ahSOLoss;
    FLOAT ahROLoss;
    AHSCHVC ahSch;
    FAN sfan;
    FAN rfan;
    CCH cch;
    AHHEATCOIL ahhc;
    FLOAT ahccBypass;
    COOLCOIL ahcc;
    TI tu1;
    TI zhx1;
    BOO ahRun;
    SI timesReEst;
    AHMODE ahMode;
    DBL ts;
    DBL ws;
    DBL wsls;
    DBL airxTs;
    DBL tsMnFo;
    BOO tsMnFoOk;
    DBL tsMxFo;
    BOO tsMxFoOk;
    DBL tr;
    DBL wr;
    DBL cr;
    DBL cMxfcc;
    DBL frFanOn;
    DBL leakCOn;
    DBL tr1;
    DBL wr1;
    DBL cr1;
    DBL tr2;
    FLOAT rfanQ;
    DBL tmix;
    DBL wen;
    DBL cmix;
    DBL dtMixEn;
    DBL ten;
    DBL cen;
    DBL men;
    DBL tex;
    DBL wex;
    DBL tex1;
    DBL dtExSen;
    DBL tSen;
    DBL dtSenS;
    DBL aTs;
    DBL aWs;
    DBL trNx;
    DBL wrNx;
    DBL crNx;
    DBL cMxnx;
    DBL frFanOnNx;
    DBL leakCOnNx;
    DBL tr1Nx;
    DBL wr1Nx;
    DBL cr1Nx;
    DBL tr2Nx;
    TCUSE uUseAr;
    BOO fcc;
    BOO isZNorZN2;
    DBL tsSp1;
    DBL tsFullFlow;
    BOO ecoEnabled;
    BOO coilLockout;
    DBL po;
    COILUSED coilUsed;
    DBL fanF;
    DBL fanFMax;
    BOO fanLimited;
    BOO coilLimited;
    DBL tPossH;
    DBL tPossC;
    FLOAT tsAhPr;
    TSCMNC ahTsSpPr;
    DBL fanFPr;
    FLOAT tr2NxPr;
    FLOAT cr1NxPr;
    FLOAT wr1NxPr;
    OFFAVAILVC hcSchPr;
    OFFAVAILVC ccSchPr;
    FLOAT tDbOShPr;
    FLOAT wOShPr;
    FLOAT tsPr;
    FLOAT wsPr;
    FLOAT dtPr;
    BOO ahClf;
    BOO ahPtf;
    BOO ahPtf2;
    unsigned char sstat[462];		// fld status bytes (base class excluded)
};		// AH

// AH field numbers (subscripts for AH.sstat[] / sfirAH[])
#define AH_NAME 0
#define AH_OWNTI 1
#define AH_AHTSDSH 2
#define AH_AHTSDSC 3
#define AH_AHCCSHR 4
#define AH_COILOVERSIZE 5
#define AH_FANOVERSIZE 6
#define AH_ASRFAN 7
#define AH_ASFLOW 8
#define AH_HCAS 9
#define AH_CCAS 25
#define AH_FANAS 41
#define AH_BVFDS 57
#define AH_QCPKS 58
#define AH_QCPKL 59
#define AH_QCPKH 60
#define AH_QCPKD 61
#define AH_QCPKM 62
#define AH_QCPKTDBO 63
#define AH_QCPKWO 64
#define AH_QCPKTEN 65
#define AH_QCPKWEN 66
#define AH_QCPKTEX 67
#define AH_QCPKWEX 68
#define AH_QCPKSAS 69
#define AH_QCPKLAS 70
#define AH_QCPKHAS 71
#define AH_QCPKDAS 72
#define AH_QCPKMAS 73
#define AH_QCPKTDBOAS 74
#define AH_QCPKWOAS 75
#define AH_QCPKTENAS 76
#define AH_QCPKWENAS 77
#define AH_QCPKTEXAS 78
#define AH_QCPKWEXAS 79
#define AH_AHTSSP 80
#define AH_AHFANCYCLES 81
#define AH_AHTSMN 82
#define AH_AHTSMX 83
#define AH_AHTSRAMN 84
#define AH_AHTSRAMX 85
#define AH_AHCTU 86
#define AH_AHWZCZNS 87
#define AH_AHCZCZNS 103
#define AH_OAMNCM 119
#define AH_OAMNFRAC 120
#define AH_OAVFDSMN 121
#define AH_OAECOTY 122
#define AH_OALIMT 123
#define AH_OALIME 124
#define AH_OAOALEAK 125
#define AH_OARALEAK 126
#define AH_AHSOLEAK 127
#define AH_AHROLEAK 128
#define AH_AHSOLOSS 129
#define AH_AHROLOSS 130
#define AH_AHSCH 131
#define AH_SFAN 132
#define AH_RFAN 163
#define AH_CCH 194
#define AH_AHHC 209
#define AH_AHCCBYPASS 281
#define AH_AHCC 282
#define AH_TU1 381
#define AH_ZHX1 382
#define AH_AHRUN 383
#define AH_TIMESREEST 384
#define AH_AHMODE 385
#define AH_TS 386
#define AH_WS 387
#define AH_WSLS 388
#define AH_AIRXTS 389
#define AH_TSMNFO 390
#define AH_TSMNFOOK 391
#define AH_TSMXFO 392
#define AH_TSMXFOOK 393
#define AH_TR 394
#define AH_WR 395
#define AH_CR 396
#define AH_CMXFCC 397
#define AH_FRFANON 398
#define AH_LEAKCON 399
#define AH_TR1 400
#define AH_WR1 401
#define AH_CR1 402
#define AH_TR2 403
#define AH_RFANQ 404
#define AH_TMIX 405
#define AH_WEN 406
#define AH_CMIX 407
#define AH_DTMIXEN 408
#define AH_TEN 409
#define AH_CEN 410
#define AH_MEN 411
#define AH_TEX 412
#define AH_WEX 413
#define AH_TEX1 414
#define AH_DTEXSEN 415
#define AH_TSEN 416
#define AH_DTSENS 417
#define AH_ATS 418
#define AH_AWS 419
#define AH_TRNX 420
#define AH_WRNX 421
#define AH_CRNX 422
#define AH_CMXNX 423
#define AH_FRFANONNX 424
#define AH_LEAKCONNX 425
#define AH_TR1NX 426
#define AH_WR1NX 427
#define AH_CR1NX 428
#define AH_TR2NX 429
#define AH_UUSEAR 430
#define AH_FCC 431
#define AH_ISZNORZN2 432
#define AH_TSSP1 433
#define AH_TSFULLFLOW 434
#define AH_ECOENABLED 435
#define AH_COILLOCKOUT 436
#define AH_PO 437
#define AH_COILUSED 438
#define AH_FANF 439
#define AH_FANFMAX 440
#define AH_FANLIMITED 441
#define AH_COILLIMITED 442
#define AH_TPOSSH 443
#define AH_TPOSSC 444
#define AH_TSAHPR 445
#define AH_AHTSSPPR 446
#define AH_FANFPR 447
#define AH_TR2NXPR 448
#define AH_CR1NXPR 449
#define AH_WR1NXPR 450
#define AH_HCSCHPR 451
#define AH_CCSCHPR 452
#define AH_TDBOSHPR 453
#define AH_WOSHPR 454
#define AH_TSPR 455
#define AH_WSPR 456
#define AH_DTPR 457
#define AH_AHCLF 458
#define AH_AHPTF 459
#define AH_AHPTF2 460

#define AH_NFIELDS 461  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirAH[];				// AH small fields-in-record table (srfd.cpp)

#define  makAncAH(name)        anc<AH> name( "airHandler", sfirAH, AH_NFIELDS, RTAH) 
#define  makAncAH2(name,what)  anc<AH> name( what, sfirAH, AH_NFIELDS, RTAH)	// 'what' override


/*--- AHRES_IVL_SUB ---*/

// AHRES_IVL_SUB record structure
struct AHRES_IVL_SUB
 { 
    INT n;
    FLOAT tDbO;
    FLOAT wO;
    FLOAT tr;
    FLOAT wr;
    FLOAT tmix;
    FLOAT wmix;
    FLOAT ts;
    FLOAT ws;
    FLOAT po;
    FLOAT frFanOn;
    FLOAT vf;
    FLOAT qh;
    FLOAT qc;
    FLOAT qs;
    FLOAT ql;
    FLOAT qO;
    FLOAT qFan;
    FLOAT qLoss;
    FLOAT qLoad;
    FLOAT qBal;
    FLOAT ph;
    FLOAT pc;
    FLOAT pAuxH;
    FLOAT pAuxC;
    FLOAT pFan;
    FLOAT hrsOn;
    LI nSubhr;
    LI nIter1;
    LI nIter2;
    LI nIter4;
    LI nIterFan;
};		// AHRES_IVL_SUB

// AHRES_IVL_SUB field numbers (subscripts for AHRES_IVL_SUB.sstat[] / sfirAHRES_IVL_SUB[])
#define AHRES_IVL_SUB_N 0
#define AHRES_IVL_SUB_TDBO 1
#define AHRES_IVL_SUB_WO 2
#define AHRES_IVL_SUB_TR 3
#define AHRES_IVL_SUB_WR 4
#define AHRES_IVL_SUB_TMIX 5
#define AHRES_IVL_SUB_WMIX 6
#define AHRES_IVL_SUB_TS 7
#define AHRES_IVL_SUB_WS 8
#define AHRES_IVL_SUB_PO 9
#define AHRES_IVL_SUB_FRFANON 10
#define AHRES_IVL_SUB_VF 11
#define AHRES_IVL_SUB_QH 12
#define AHRES_IVL_SUB_QC 13
#define AHRES_IVL_SUB_QS 14
#define AHRES_IVL_SUB_QL 15
#define AHRES_IVL_SUB_QO 16
#define AHRES_IVL_SUB_QFAN 17
#define AHRES_IVL_SUB_QLOSS 18
#define AHRES_IVL_SUB_QLOAD 19
#define AHRES_IVL_SUB_QBAL 20
#define AHRES_IVL_SUB_PH 21
#define AHRES_IVL_SUB_PC 22
#define AHRES_IVL_SUB_PAUXH 23
#define AHRES_IVL_SUB_PAUXC 24
#define AHRES_IVL_SUB_PFAN 25
#define AHRES_IVL_SUB_HRSON 26
#define AHRES_IVL_SUB_NSUBHR 27
#define AHRES_IVL_SUB_NITER1 28
#define AHRES_IVL_SUB_NITER2 29
#define AHRES_IVL_SUB_NITER4 30
#define AHRES_IVL_SUB_NITERFAN 31

#define AHRES_IVL_SUB_NFIELDS 32  					// excludes rec start ovh; is # sstat[] bytes.



/*--- AHRES ---*/

// AHRES record class
class AHRES : public record 
{ public:
    AHRES( basAnc *_b, TI i, SI noZ=0)  :  record( _b, i, noZ)  {} 
    virtual ~AHRES() {} 
    AHRES& Copy( const AHRES& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    AHRES& operator=( const AHRES& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0) { record::Copy( pSrc, options); };

    AHRES_IVL_SUB Y;
    AHRES_IVL_SUB M;
    AHRES_IVL_SUB D;
    AHRES_IVL_SUB H;
    AHRES_IVL_SUB S;
    unsigned char sstat[162];		// fld status bytes (base class excluded)
};		// AHRES

// AHRES field numbers (subscripts for AHRES.sstat[] / sfirAHRES[])
#define AHRES_NAME 0
#define AHRES_OWNTI 1
#define AHRES_Y 2
#define AHRES_M 34
#define AHRES_D 66
#define AHRES_H 98
#define AHRES_S 130

#define AHRES_NFIELDS 162  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirAHRES[];				// AHRES small fields-in-record table (srfd.cpp)

#define  makAncAHRES(name)        anc<AHRES> name( "ahRes", sfirAHRES, AHRES_NFIELDS, RTAHRES) 
#define  makAncAHRES2(name,what)  anc<AHRES> name( what, sfirAHRES, AHRES_NFIELDS, RTAHRES)	// 'what' override


/*--- TU ---*/

// TU record class
class TU : public record 
{ public:
    TU( basAnc *_b, TI i, SI noZ=0)  :  record( _b, i, noZ)  {} 
    virtual ~TU() {} 
    TU& Copy( const TU& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    TU& operator=( const TU& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0) { record::Copy( pSrc, options); };

    RC setup();
    void fazInit( int isAusz);
    RC tu_pass1AtoB();
    RC tu_begP1b();
    void rddiInit();
    RC tu_SetupSizes();
    void tu_p2Init();
    void endP2Dsd();
    RC tu_p2EndTest();
    RC tu_endAutosize();
    void tu_auszFinal();
    BOO resizeIf( DBL &cv, BOO isCooling, DBL cvLim, BOO decrOnly);
    RC begHour();
    RC begSubhr();
    RC endSubhr();
    RC tuEstimate();
    DBL tfanBackCMx()     { return tfanRunning ? 0. : tfanBkC; }
    DBL aTfanBackC()      { return tfanRunning ? 0. : min( aCv, tfanBkC); }
    DBL tfanBackC(DBL _cv) { return tfanRunning ? 0. : min( _cv, tfanBkC); }
    DBL aRLeakC()         { return (aCv - aTfanBackC()) * tuSRLeak; }
    DBL aCz()             { return (aCv - aTfanBackC()) * (1.-tuSRLeak); }
    DBL znC(DBL _cv)       { return (cv - tfanBackC(_cv)) * (1.-tuSRLeak); }
    DBL vavC(DBL _cz)      { return (_cz + tfanBackCMx()) / (1.-tuSRLeak); }
    DBL rLeakC(DBL _cv)    { return (_cv - tfanBackC(_cv)) * tuSRLeak; }
    DIFFSAMECH tuVfMxHC;
    FLOAT tuOversize;
    BOO asHcSame;
    BOO asKVol;
    AUSZ hcAs;
    AUSZ vhAs;
    AUSZ vcAs;
    FLOAT qhPk;
    FLOAT qcPk;
    FLOAT qhPkAs;
    FLOAT qcPkAs;
    FLOAT bVfMn;
    FLOAT bVfMxH;
    FLOAT bVfMxC;
    BOO dtLoHSh;
    BOO dtLoCSh;
    BOO aDtLoHSh;
    BOO aDtLoCSh;
    BOO aDtLoTem;
    BOO dtLoH;
    BOO dtLoC;
    BOO dtLoHAs;
    BOO dtLoCAs;
    FLOAT tuTLh;
    FLOAT tuQMnLh;
    FLOAT tuQMxLh;
    SI tuPriLh;
    NOYESCH tuLhNeedsFlow;
    HEATCOIL tuhc;
    FLOAT tuTH;
    FLOAT tuTC;
    FLOAT tuVfMn;
    FLOAT tuVfMn_As;
    FLOAT tuVfMn_AsNov;
    TI ai;
    FLOAT tuVfMxH;
    FLOAT tuVfMxH_As;
    FLOAT tuVfMxH_AsNov;
    FLOAT tuVfMxC;
    FLOAT tuVfMxC_As;
    FLOAT tuVfMxC_AsNov;
    FLOAT tuVfDs;
    SI tuPriH;
    SI tuPriC;
    FLOAT tuSRLeak;
    FLOAT tuSRLoss;
    TFANSCHVC tfanSch;
    FLOAT tfanOffLeak;
    FAN tfan;
    TI nxTu4z;
    TI nxTu4a;
    TI xiLh;
    TI xiArH;
    TI xiArC;
    TCCM cmLh;
    TCCM cmAr;
    TI ctrlsAi;
    AHMODE wantMd;
    DBL lhMn;
    DBL lhMx;
    DBL lhMxMx;
    DBL cMn;
    DBL cMxH;
    DBL cMxC;
    TCUSE useLh;
    TCUSE useAr;
    DBL qLhWant;
    DBL cv;
    DBL cz;
    DBL aCv;
    BOO tfanRunning;
    DBL tfanBkC;
    DBL aqO;
    DBL bO;
    DBL tzO;
    DBL wcO;
    DBL cO;
    DBL wzO;
    FLOAT lhMnPr;
    FLOAT lhMxPr;
    FLOAT tzPr;
    FLOAT wzPr;
    FLOAT czPr;
    FLOAT wzOPr;
    unsigned char sstat[200];		// fld status bytes (base class excluded)
};		// TU

// TU field numbers (subscripts for TU.sstat[] / sfirTU[])
#define TU_NAME 0
#define TU_OWNTI 1
#define TU_TUVFMXHC 2
#define TU_TUOVERSIZE 3
#define TU_ASHCSAME 4
#define TU_ASKVOL 5
#define TU_HCAS 6
#define TU_VHAS 22
#define TU_VCAS 38
#define TU_QHPK 54
#define TU_QCPK 55
#define TU_QHPKAS 56
#define TU_QCPKAS 57
#define TU_BVFMN 58
#define TU_BVFMXH 59
#define TU_BVFMXC 60
#define TU_DTLOHSH 61
#define TU_DTLOCSH 62
#define TU_ADTLOHSH 63
#define TU_ADTLOCSH 64
#define TU_ADTLOTEM 65
#define TU_DTLOH 66
#define TU_DTLOC 67
#define TU_DTLOHAS 68
#define TU_DTLOCAS 69
#define TU_TUTLH 70
#define TU_TUQMNLH 71
#define TU_TUQMXLH 72
#define TU_TUPRILH 73
#define TU_TULHNEEDSFLOW 74
#define TU_TUHC 75
#define TU_TUTH 114
#define TU_TUTC 115
#define TU_TUVFMN 116
#define TU_TUVFMN_AS 117
#define TU_TUVFMN_ASNOV 118
#define TU_AI 119
#define TU_TUVFMXH 120
#define TU_TUVFMXH_AS 121
#define TU_TUVFMXH_ASNOV 122
#define TU_TUVFMXC 123
#define TU_TUVFMXC_AS 124
#define TU_TUVFMXC_ASNOV 125
#define TU_TUVFDS 126
#define TU_TUPRIH 127
#define TU_TUPRIC 128
#define TU_TUSRLEAK 129
#define TU_TUSRLOSS 130
#define TU_TFANSCH 131
#define TU_TFANOFFLEAK 132
#define TU_TFAN 133
#define TU_NXTU4Z 164
#define TU_NXTU4A 165
#define TU_XILH 166
#define TU_XIARH 167
#define TU_XIARC 168
#define TU_CMLH 169
#define TU_CMAR 170
#define TU_CTRLSAI 171
#define TU_WANTMD 172
#define TU_LHMN 173
#define TU_LHMX 174
#define TU_LHMXMX 175
#define TU_CMN 176
#define TU_CMXH 177
#define TU_CMXC 178
#define TU_USELH 179
#define TU_USEAR 180
#define TU_QLHWANT 181
#define TU_CV 182
#define TU_CZ 183
#define TU_ACV 184
#define TU_TFANRUNNING 185
#define TU_TFANBKC 186
#define TU_AQO 187
#define TU_BO 188
#define TU_TZO 189
#define TU_WCO 190
#define TU_CO 191
#define TU_WZO 192
#define TU_LHMNPR 193
#define TU_LHMXPR 194
#define TU_TZPR 195
#define TU_WZPR 196
#define TU_CZPR 197
#define TU_WZOPR 198

#define TU_NFIELDS 199  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirTU[];				// TU small fields-in-record table (srfd.cpp)

#define  makAncTU(name)        anc<TU> name( "terminal", sfirTU, TU_NFIELDS, RTTU) 
#define  makAncTU2(name,what)  anc<TU> name( what, sfirTU, TU_NFIELDS, RTTU)	// 'what' override


/*--- ZHX ---*/

// ZHX record class
class ZHX : public record 
{ public:
    ZHX( basAnc *_b, TI i, SI noZ=0)  :  record( _b, i, noZ)  {} 
    virtual ~ZHX() {} 
    ZHX& Copy( const ZHX& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    ZHX& operator=( const ZHX& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0) { record::Copy( pSrc, options); };

    ZHXTY zhxTy;
    FLOAT sp;
    SI spPri;
    TI ui;
    TI zi;
    TI ai;
    TI xiLh;
    TI xiArH;
    TI xiArC;
    TI nxZhx4z;
    TI nxZhxSt4z;
    TI nxZhx4a;
    SI mda;
    unsigned char sstat[16];		// fld status bytes (base class excluded)
};		// ZHX

// ZHX field numbers (subscripts for ZHX.sstat[] / sfirZHX[])
#define ZHX_NAME 0
#define ZHX_OWNTI 1
#define ZHX_ZHXTY 2
#define ZHX_SP 3
#define ZHX_SPPRI 4
#define ZHX_UI 5
#define ZHX_ZI 6
#define ZHX_AI 7
#define ZHX_XILH 8
#define ZHX_XIARH 9
#define ZHX_XIARC 10
#define ZHX_NXZHX4Z 11
#define ZHX_NXZHXST4Z 12
#define ZHX_NXZHX4A 13
#define ZHX_MDA 14

#define ZHX_NFIELDS 15  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirZHX[];				// ZHX small fields-in-record table (srfd.cpp)

#define  makAncZHX(name)        anc<ZHX> name( "zhx", sfirZHX, ZHX_NFIELDS, RTZHX) 
#define  makAncZHX2(name,what)  anc<ZHX> name( what, sfirZHX, ZHX_NFIELDS, RTZHX)	// 'what' override


/*--- PUMP ---*/

// PUMP record structure
struct PUMP
 { 
    RC setup( record *r, SI pumpFn);
    FLOAT gpm;
    FLOAT hdLoss;
    FLOAT motEff;
    FLOAT hydEff;
    FLOAT ovrunF;
    TI mtri;
    DBL mw;
    DBL q;
    DBL p;
};		// PUMP

// PUMP field numbers (subscripts for PUMP.sstat[] / sfirPUMP[])
#define PUMP_GPM 0
#define PUMP_HDLOSS 1
#define PUMP_MOTEFF 2
#define PUMP_HYDEFF 3
#define PUMP_OVRUNF 4
#define PUMP_MTRI 5
#define PUMP_MW 6
#define PUMP_Q 7
#define PUMP_P 8

#define PUMP_NFIELDS 9  					// excludes rec start ovh; is # sstat[] bytes.



/*--- HEATPLANT ---*/

// HEATPLANT record class
class HEATPLANT : public record 
{ public:
    HEATPLANT( basAnc *_b, TI i, SI noZ=0)  :  record( _b, i, noZ)  {} 
    virtual ~HEATPLANT() {} 
    HEATPLANT& Copy( const HEATPLANT& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    HEATPLANT& operator=( const HEATPLANT& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0) { record::Copy( pSrc, options); };

    RC setup();
    BOO hpOn();
    RC hpEstimate(BOO wantHeat=FALSE);
    RC hpCompute();
    void adjCapF();				// adjust capF for overload/underload. cnhp.cpp
    void fazInit(int isAusz);
    void rddiInit();
    void endP2Dsd();
    RC hp_endAutosize();
    BOO nxTu( TU *&tu);
    BOO nxAh( AH *&ah);
    BOO nxBlr( BOILER *&blr);
    BOO nxBlrStg( BOILER *&blr, SI stgi = -1);
    OFFAVAILONVC hpSched;
    FLOAT hpPipeLossF;
    #define NHPSTAGES 7		//number of hpStages
    #define HPSTAGESZ 8		//number+1 of boilers in a stage
    TI hpStage1[8];
    TI hpStage2[8];
    TI hpStage3[8];
    TI hpStage4[8];
    TI hpStage5[8];
    TI hpStage6[8];
    TI hpStage7[8];
    TI blr1;
    TI tu1;
    TI ah1;
    TI hl1;
    DBL qPipeLoss;
    DBL stgCap[7];
    DBL stgPQ[7];
    SI stgN;
    SI stgMxQ;
    BOO hpClf;
    BOO hpPtf;
    OFFONCH hpMode;
    DBL capF;
    SI stgi;
    DBL qNx;
    DBL q;
    FLOAT qPk;
    FLOAT qPkAs;
    OFFONCH hpModePr;
    FLOAT qPr;
    FLOAT capFPr;
    unsigned char sstat[94];		// fld status bytes (base class excluded)
};		// HEATPLANT

// HEATPLANT field numbers (subscripts for HEATPLANT.sstat[] / sfirHEATPLANT[])
#define HEATPLANT_NAME 0
#define HEATPLANT_OWNTI 1
#define HEATPLANT_HPSCHED 2
#define HEATPLANT_HPPIPELOSSF 3
#define HEATPLANT_HPSTAGE1 4
#define HEATPLANT_HPSTAGE2 12
#define HEATPLANT_HPSTAGE3 20
#define HEATPLANT_HPSTAGE4 28
#define HEATPLANT_HPSTAGE5 36
#define HEATPLANT_HPSTAGE6 44
#define HEATPLANT_HPSTAGE7 52
#define HEATPLANT_BLR1 60
#define HEATPLANT_TU1 61
#define HEATPLANT_AH1 62
#define HEATPLANT_HL1 63
#define HEATPLANT_QPIPELOSS 64
#define HEATPLANT_STGCAP 65
#define HEATPLANT_STGPQ 72
#define HEATPLANT_STGN 79
#define HEATPLANT_STGMXQ 80
#define HEATPLANT_HPCLF 81
#define HEATPLANT_HPPTF 82
#define HEATPLANT_HPMODE 83
#define HEATPLANT_CAPF 84
#define HEATPLANT_STGI 85
#define HEATPLANT_QNX 86
#define HEATPLANT_Q 87
#define HEATPLANT_QPK 88
#define HEATPLANT_QPKAS 89
#define HEATPLANT_HPMODEPR 90
#define HEATPLANT_QPR 91
#define HEATPLANT_CAPFPR 92

#define HEATPLANT_NFIELDS 93  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirHEATPLANT[];				// HEATPLANT small fields-in-record table (srfd.cpp)

#define  makAncHEATPLANT(name)        anc<HEATPLANT> name( "heatPlant", sfirHEATPLANT, HEATPLANT_NFIELDS, RTHEATPLANT) 
#define  makAncHEATPLANT2(name,what)  anc<HEATPLANT> name( what, sfirHEATPLANT, HEATPLANT_NFIELDS, RTHEATPLANT)	// 'what' override


/*--- BOILER ---*/

// BOILER record class
class BOILER : public record 
{ public:
    BOILER( basAnc *_b, TI i, SI noZ=0)  :  record( _b, i, noZ)  {} 
    virtual ~BOILER() {} 
    BOILER& Copy( const BOILER& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    BOILER& operator=( const BOILER& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0) { record::Copy( pSrc, options); };

    RC setup();
    RC endSubhr();
    FLOAT blrCap;
    FLOAT blrEffR;
    FLOAT blrEirR;
    PYCUBIC blrPyEi;
    TI mtri;
    PUMP blrp;
    FLOAT auxOn;
    TI auxOnMtri;
    FLOAT auxOff;
    TI auxOffMtri;
    FLOAT auxOnAtall;
    TI auxOnAtallMtri;
    FLOAT auxFullOff;
    TI auxFullOffMtri;
    TI nxBlr4hp;
    BOO used;
    OFFONCH blrMode;
    FLOAT plr;
    FLOAT q;
    FLOAT p;
    FLOAT pAuxOn;
    FLOAT pAuxOff;
    FLOAT pAuxOnAtall;
    FLOAT pAuxFullOff;
    unsigned char sstat[38];		// fld status bytes (base class excluded)
};		// BOILER

// BOILER field numbers (subscripts for BOILER.sstat[] / sfirBOILER[])
#define BOILER_NAME 0
#define BOILER_OWNTI 1
#define BOILER_BLRCAP 2
#define BOILER_BLREFFR 3
#define BOILER_BLREIRR 4
#define BOILER_BLRPYEI 5
#define BOILER_MTRI 10
#define BOILER_BLRP 11
#define BOILER_AUXON 20
#define BOILER_AUXONMTRI 21
#define BOILER_AUXOFF 22
#define BOILER_AUXOFFMTRI 23
#define BOILER_AUXONATALL 24
#define BOILER_AUXONATALLMTRI 25
#define BOILER_AUXFULLOFF 26
#define BOILER_AUXFULLOFFMTRI 27
#define BOILER_NXBLR4HP 28
#define BOILER_USED 29
#define BOILER_BLRMODE 30
#define BOILER_PLR 31
#define BOILER_Q 32
#define BOILER_P 33
#define BOILER_PAUXON 34
#define BOILER_PAUXOFF 35
#define BOILER_PAUXONATALL 36
#define BOILER_PAUXFULLOFF 37

#define BOILER_NFIELDS 38  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirBOILER[];				// BOILER small fields-in-record table (srfd.cpp)

#define  makAncBOILER(name)        anc<BOILER> name( "boiler", sfirBOILER, BOILER_NFIELDS, RTBOILER) 
#define  makAncBOILER2(name,what)  anc<BOILER> name( what, sfirBOILER, BOILER_NFIELDS, RTBOILER)	// 'what' override


/*--- COOLPLANT ---*/

// COOLPLANT record class
class COOLPLANT : public record 
{ public:
    COOLPLANT( basAnc *_b, TI i, SI noZ=0)  :  record( _b, i, noZ)  {} 
    virtual ~COOLPLANT() {} 
    COOLPLANT& Copy( const COOLPLANT& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    COOLPLANT& operator=( const COOLPLANT& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0) { record::Copy( pSrc, options); };

    RC setup();
    BOO cpOn();
    RC cpEstimate(BOO wantCool=FALSE);
    RC cpCompute();
    DBL/*POWER*/ capStg();
    BOO nxAh( AH *&ah);
    BOO nxCh( CHILLER *&ch);
    BOO nxChStg( CHILLER *&ch, SI stgi=-1);
    OFFAVAILONVC cpSched;
    FLOAT cpTsSp;
    FLOAT cpPipeLossF;
    TI cpTowi;
    #define NCPSTAGES 7		//number of cpStages
    #define CPSTAGESZ 8		//number+1 of chillers in a stage
    TI cpStage1[8];
    TI cpStage2[8];
    TI cpStage3[8];
    TI cpStage4[8];
    TI cpStage5[8];
    TI cpStage6[8];
    TI cpStage7[8];
    TI ch1;
    TI ah1;
    TI nxCp4tp;
    DBL mwDsCoils;
    FLOAT stgPPQ[7];
    FLOAT stgCPQ[7];
    FLOAT stgPMw[7];
    FLOAT stgCMw[7];
    SI stgN;
    SI stgMxCap;
    DBL mxCapDs;
    DBL mxPMw;
    DBL mxPMwOv;
    DBL mxCondQ;
    DBL mxCondGpm;
    DBL qPipeLoss;
    DBL cpTs;
    DBL q;
    DBL qTow;
    DBL tTow;
    DBL mwTow;
    DBL tCnd;
    BOO cpClf;
    BOO cpPtf;
    OFFONCH cpMode;
    DBL qLoadNx;
    DBL qLoad;
    DBL tr;
    SI stgi;
    DBL qNeed;
    DBL cap;
    DBL plr;
    DBL puteTs;
    FLOAT cpTsSpPr;
    FLOAT cpTsEstPr;
    OFFONCH cpModePr;
    FLOAT trMxPr;
    FLOAT qLoadPr;
    FLOAT mwTowPr;
    FLOAT tTowPr;
    unsigned char sstat[126];		// fld status bytes (base class excluded)
};		// COOLPLANT

// COOLPLANT field numbers (subscripts for COOLPLANT.sstat[] / sfirCOOLPLANT[])
#define COOLPLANT_NAME 0
#define COOLPLANT_OWNTI 1
#define COOLPLANT_CPSCHED 2
#define COOLPLANT_CPTSSP 3
#define COOLPLANT_CPPIPELOSSF 4
#define COOLPLANT_CPTOWI 5
#define COOLPLANT_CPSTAGE1 6
#define COOLPLANT_CPSTAGE2 14
#define COOLPLANT_CPSTAGE3 22
#define COOLPLANT_CPSTAGE4 30
#define COOLPLANT_CPSTAGE5 38
#define COOLPLANT_CPSTAGE6 46
#define COOLPLANT_CPSTAGE7 54
#define COOLPLANT_CH1 62
#define COOLPLANT_AH1 63
#define COOLPLANT_NXCP4TP 64
#define COOLPLANT_MWDSCOILS 65
#define COOLPLANT_STGPPQ 66
#define COOLPLANT_STGCPQ 73
#define COOLPLANT_STGPMW 80
#define COOLPLANT_STGCMW 87
#define COOLPLANT_STGN 94
#define COOLPLANT_STGMXCAP 95
#define COOLPLANT_MXCAPDS 96
#define COOLPLANT_MXPMW 97
#define COOLPLANT_MXPMWOV 98
#define COOLPLANT_MXCONDQ 99
#define COOLPLANT_MXCONDGPM 100
#define COOLPLANT_QPIPELOSS 101
#define COOLPLANT_CPTS 102
#define COOLPLANT_Q 103
#define COOLPLANT_QTOW 104
#define COOLPLANT_TTOW 105
#define COOLPLANT_MWTOW 106
#define COOLPLANT_TCND 107
#define COOLPLANT_CPCLF 108
#define COOLPLANT_CPPTF 109
#define COOLPLANT_CPMODE 110
#define COOLPLANT_QLOADNX 111
#define COOLPLANT_QLOAD 112
#define COOLPLANT_TR 113
#define COOLPLANT_STGI 114
#define COOLPLANT_QNEED 115
#define COOLPLANT_CAP 116
#define COOLPLANT_PLR 117
#define COOLPLANT_PUTETS 118
#define COOLPLANT_CPTSSPPR 119
#define COOLPLANT_CPTSESTPR 120
#define COOLPLANT_CPMODEPR 121
#define COOLPLANT_TRMXPR 122
#define COOLPLANT_QLOADPR 123
#define COOLPLANT_MWTOWPR 124
#define COOLPLANT_TTOWPR 125

#define COOLPLANT_NFIELDS 126  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirCOOLPLANT[];				// COOLPLANT small fields-in-record table (srfd.cpp)

#define  makAncCOOLPLANT(name)        anc<COOLPLANT> name( "coolPlant", sfirCOOLPLANT, COOLPLANT_NFIELDS, RTCOOLPLANT) 
#define  makAncCOOLPLANT2(name,what)  anc<COOLPLANT> name( what, sfirCOOLPLANT, COOLPLANT_NFIELDS, RTCOOLPLANT)	// 'what' override


/*--- CHILLER ---*/

// CHILLER record class
class CHILLER : public record 
{ public:
    CHILLER( basAnc *_b, TI i, SI noZ=0)  :  record( _b, i, noZ)  {} 
    virtual ~CHILLER() {} 
    CHILLER& Copy( const CHILLER& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    CHILLER& operator=( const CHILLER& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0) { record::Copy( pSrc, options); };

    RC setup();
    RC endSubhr();
    FLOAT chCapDs;
    FLOAT chTsDs;
    FLOAT chTcndDs;
    PYBIQUAD chPyCapT;
    FLOAT chCop;
    FLOAT chEirDs;
    PYBIQUAD chPyEirT;
    PYCUBIC chPyEirUl;
    FLOAT chMinUnldPlr;
    FLOAT chMinFsldPlr;
    FLOAT chMotEff;
    TI mtri;
    PUMP chpp;
    PUMP chcp;
    FLOAT auxOn;
    TI auxOnMtri;
    FLOAT auxOff;
    TI auxOffMtri;
    FLOAT auxOnAtall;
    TI auxOnAtallMtri;
    FLOAT auxFullOff;
    TI auxFullOffMtri;
    TI nxCh4cp;
    BOO used;
    DBL eirMinUnldPlr;
    OFFONCH chMode;
    DBL cap;
    FLOAT q;
    FLOAT p;
    FLOAT pAuxOn;
    FLOAT pAuxOff;
    FLOAT pAuxOnAtall;
    FLOAT pAuxFullOff;
    unsigned char sstat[68];		// fld status bytes (base class excluded)
};		// CHILLER

// CHILLER field numbers (subscripts for CHILLER.sstat[] / sfirCHILLER[])
#define CHILLER_NAME 0
#define CHILLER_OWNTI 1
#define CHILLER_CHCAPDS 2
#define CHILLER_CHTSDS 3
#define CHILLER_CHTCNDDS 4
#define CHILLER_CHPYCAPT 5
#define CHILLER_CHCOP 12
#define CHILLER_CHEIRDS 13
#define CHILLER_CHPYEIRT 14
#define CHILLER_CHPYEIRUL 21
#define CHILLER_CHMINUNLDPLR 26
#define CHILLER_CHMINFSLDPLR 27
#define CHILLER_CHMOTEFF 28
#define CHILLER_MTRI 29
#define CHILLER_CHPP 30
#define CHILLER_CHCP 39
#define CHILLER_AUXON 48
#define CHILLER_AUXONMTRI 49
#define CHILLER_AUXOFF 50
#define CHILLER_AUXOFFMTRI 51
#define CHILLER_AUXONATALL 52
#define CHILLER_AUXONATALLMTRI 53
#define CHILLER_AUXFULLOFF 54
#define CHILLER_AUXFULLOFFMTRI 55
#define CHILLER_NXCH4CP 56
#define CHILLER_USED 57
#define CHILLER_EIRMINUNLDPLR 58
#define CHILLER_CHMODE 59
#define CHILLER_CAP 60
#define CHILLER_Q 61
#define CHILLER_P 62
#define CHILLER_PAUXON 63
#define CHILLER_PAUXOFF 64
#define CHILLER_PAUXONATALL 65
#define CHILLER_PAUXFULLOFF 66

#define CHILLER_NFIELDS 67  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirCHILLER[];				// CHILLER small fields-in-record table (srfd.cpp)

#define  makAncCHILLER(name)        anc<CHILLER> name( "chiller", sfirCHILLER, CHILLER_NFIELDS, RTCHILLER) 
#define  makAncCHILLER2(name,what)  anc<CHILLER> name( what, sfirCHILLER, CHILLER_NFIELDS, RTCHILLER)	// 'what' override


/*--- TOWERPLANT ---*/

// TOWERPLANT record class
class TOWERPLANT : public record 
{ public:
    TOWERPLANT( basAnc *_b, TI i, SI noZ=0)  :  record( _b, i, noZ)  {} 
    virtual ~TOWERPLANT() {} 
    TOWERPLANT& Copy( const TOWERPLANT& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    TOWERPLANT& operator=( const TOWERPLANT& _d) { Copy( static_cast< const record*>(&_d)); return *this; }
    virtual void Copy( const record* pSrc, int options=0) { record::Copy( pSrc, options); };

    RC   setup();
    RC   setupNtuADs();
    RC   setupNtuAOd();
    RC   tpEstimate();
    RC   tpCompute();
    RC   endSubhr();
    RC   findSpeed( DBL q);
    RC   varSpeedF( DBL qWant, DBL &f, DBL &q, FLOAT &guess);
    RC   towModel( DBL f, DBL &q, FLOAT &guess);
    BOO  nxCp( COOLPLANT *&cp);
    SI ctN;
    TPSTGCH tpStg;
    FLOAT tpTsSp;
    TI tpMtr;
    CTTYCH ctTy;
    FLOAT ctLoSpd;
    FLOAT ctShaftPwr;
    FLOAT ctMotEff;
    PYLINEAR ctFcOne;
    PYLINEAR ctFcLo;
    PYLINEAR ctFcHi;
    PYCUBIC ctFcVar;
    FLOAT ctCapDs;
    FLOAT ctVfDs;
    FLOAT ctGpmDs;
    FLOAT ctTDbODs;
    FLOAT ctTWbODs;
    FLOAT ctTwoDs;
    FLOAT ctCapOd;
    FLOAT ctVfOd;
    FLOAT ctGpmOd;
    FLOAT ctTDbOOd;
    FLOAT ctTWbOOd;
    FLOAT ctTwoOd;
    FLOAT ctK;
    FLOAT ctStkFlFr;
    FLOAT ctBldn;
    FLOAT ctDrft;
    FLOAT ctTWm;
    TI cp1;
    TI hl1;
    DBL oneFanP;
    DBL maDs;
    DBL maOd;
    DBL mwDs;
    DBL mwOd;
    DBL maOverMwDs;
    DBL ntuADs;
    DBL ntuAOd;
    DBL tpTs;
    BOO tpClf;
    BOO tpPtf;
    DBL trNx;
    DBL mwAllNx;
    DBL qLoadNx;
    DBL tr;
    DBL mwAll;
    DBL qLoad;
    DBL mwi1;
    DBL qNeed;
    DBL qMax1;
    DBL qMin1;
    TOWLOADCASE towldCase;
    FLOAT qMaxGuess;
    FLOAT qMinGuess;
    FLOAT qLoGuess;
    FLOAT qVarGuess;
    DBL qVarTem;
    DBL puteTs;
    SI nCtOp;
    DBL f;
    FLOAT fanP;
    FLOAT q;
    FLOAT tpTsSpPr;
    FLOAT tpTsEstPr;
    FLOAT tpTsPr;
    FLOAT tDbOShPr;
    FLOAT wOShPr;
    unsigned char sstat[80];		// fld status bytes (base class excluded)
};		// TOWERPLANT

// TOWERPLANT field numbers (subscripts for TOWERPLANT.sstat[] / sfirTOWERPLANT[])
#define TOWERPLANT_NAME 0
#define TOWERPLANT_OWNTI 1
#define TOWERPLANT_CTN 2
#define TOWERPLANT_TPSTG 3
#define TOWERPLANT_TPTSSP 4
#define TOWERPLANT_TPMTR 5
#define TOWERPLANT_CTTY 6
#define TOWERPLANT_CTLOSPD 7
#define TOWERPLANT_CTSHAFTPWR 8
#define TOWERPLANT_CTMOTEFF 9
#define TOWERPLANT_CTFCONE 10
#define TOWERPLANT_CTFCLO 13
#define TOWERPLANT_CTFCHI 16
#define TOWERPLANT_CTFCVAR 19
#define TOWERPLANT_CTCAPDS 24
#define TOWERPLANT_CTVFDS 25
#define TOWERPLANT_CTGPMDS 26
#define TOWERPLANT_CTTDBODS 27
#define TOWERPLANT_CTTWBODS 28
#define TOWERPLANT_CTTWODS 29
#define TOWERPLANT_CTCAPOD 30
#define TOWERPLANT_CTVFOD 31
#define TOWERPLANT_CTGPMOD 32
#define TOWERPLANT_CTTDBOOD 33
#define TOWERPLANT_CTTWBOOD 34
#define TOWERPLANT_CTTWOOD 35
#define TOWERPLANT_CTK 36
#define TOWERPLANT_CTSTKFLFR 37
#define TOWERPLANT_CTBLDN 38
#define TOWERPLANT_CTDRFT 39
#define TOWERPLANT_CTTWM 40
#define TOWERPLANT_CP1 41
#define TOWERPLANT_HL1 42
#define TOWERPLANT_ONEFANP 43
#define TOWERPLANT_MADS 44
#define TOWERPLANT_MAOD 45
#define TOWERPLANT_MWDS 46
#define TOWERPLANT_MWOD 47
#define TOWERPLANT_MAOVERMWDS 48
#define TOWERPLANT_NTUADS 49
#define TOWERPLANT_NTUAOD 50
#define TOWERPLANT_TPTS 51
#define TOWERPLANT_TPCLF 52
#define TOWERPLANT_TPPTF 53
#define TOWERPLANT_TRNX 54
#define TOWERPLANT_MWALLNX 55
#define TOWERPLANT_QLOADNX 56
#define TOWERPLANT_TR 57
#define TOWERPLANT_MWALL 58
#define TOWERPLANT_QLOAD 59
#define TOWERPLANT_MWI1 60
#define TOWERPLANT_QNEED 61
#define TOWERPLANT_QMAX1 62
#define TOWERPLANT_QMIN1 63
#define TOWERPLANT_TOWLDCASE 64
#define TOWERPLANT_QMAXGUESS 65
#define TOWERPLANT_QMINGUESS 66
#define TOWERPLANT_QLOGUESS 67
#define TOWERPLANT_QVARGUESS 68
#define TOWERPLANT_QVARTEM 69
#define TOWERPLANT_PUTETS 70
#define TOWERPLANT_NCTOP 71
#define TOWERPLANT_F 72
#define TOWERPLANT_FANP 73
#define TOWERPLANT_Q 74
#define TOWERPLANT_TPTSSPPR 75
#define TOWERPLANT_TPTSESTPR 76
#define TOWERPLANT_TPTSPR 77
#define TOWERPLANT_TDBOSHPR 78
#define TOWERPLANT_WOSHPR 79

#define TOWERPLANT_NFIELDS 80  					// excludes rec start ovh; is # sstat[] bytes.

extern SFIR sfirTOWERPLANT[];				// TOWERPLANT small fields-in-record table (srfd.cpp)

#define  makAncTOWERPLANT(name)        anc<TOWERPLANT> name( "towerPlant", sfirTOWERPLANT, TOWERPLANT_NFIELDS, RTTOWERPLANT) 
#define  makAncTOWERPLANT2(name,what)  anc<TOWERPLANT> name( what, sfirTOWERPLANT, TOWERPLANT_NFIELDS, RTTOWERPLANT)	// 'what' override


// rccn.h end
